(window.webpackJsonp=window.webpackJsonp||[]).push([["npm.spot-framework"],{"0056":function(module,exports,__webpack_require__){eval("var Collection = __webpack_require__(/*! ampersand-collection */ \"7bd3\");\nvar Group = __webpack_require__(/*! ./group */ \"9083\");\n\nfunction setOrdering (groups, ordering) {\n  if (ordering === 'count') {\n    groups.comparator = function (a, b) {\n      if (a.count === b.count) {\n        return a.value < b.value ? -1 : 1;\n      } else {\n        return b.count - a.count;\n      }\n    };\n  } else if (ordering === 'value') {\n    groups.comparator = 'value';\n  } else {\n    console.error('Ordering not implemented for partition: ', ordering);\n  }\n  groups.sort();\n}\n\nmodule.exports = Collection.extend({\n  indexes: ['value', 'label', 'group', 'groupIndex'],\n  model: Group,\n  comparator: 'label',\n  initialize: function (models, options) {\n    var groups = this;\n    var partition = options.parent;\n\n    // update group index on resort\n    this.on('sort', function () {\n      this.forEach(function (group, i) {\n        group.groupIndex = i;\n      });\n    }, this);\n\n    // this.parent := partition\n    if (partition) {\n      setOrdering(groups, partition.ordering);\n\n      partition.on('change ordering', function () {\n        setOrdering(groups, partition.ordering);\n      });\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMDA1Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvcGFydGl0aW9uL2dyb3VwLWNvbGxlY3Rpb24uanM/OGM1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ2FtcGVyc2FuZC1jb2xsZWN0aW9uJyk7XG52YXIgR3JvdXAgPSByZXF1aXJlKCcuL2dyb3VwJyk7XG5cbmZ1bmN0aW9uIHNldE9yZGVyaW5nIChncm91cHMsIG9yZGVyaW5nKSB7XG4gIGlmIChvcmRlcmluZyA9PT0gJ2NvdW50Jykge1xuICAgIGdyb3Vwcy5jb21wYXJhdG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChhLmNvdW50ID09PSBiLmNvdW50KSB7XG4gICAgICAgIHJldHVybiBhLnZhbHVlIDwgYi52YWx1ZSA/IC0xIDogMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiLmNvdW50IC0gYS5jb3VudDtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKG9yZGVyaW5nID09PSAndmFsdWUnKSB7XG4gICAgZ3JvdXBzLmNvbXBhcmF0b3IgPSAndmFsdWUnO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoJ09yZGVyaW5nIG5vdCBpbXBsZW1lbnRlZCBmb3IgcGFydGl0aW9uOiAnLCBvcmRlcmluZyk7XG4gIH1cbiAgZ3JvdXBzLnNvcnQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0aW9uLmV4dGVuZCh7XG4gIGluZGV4ZXM6IFsndmFsdWUnLCAnbGFiZWwnLCAnZ3JvdXAnLCAnZ3JvdXBJbmRleCddLFxuICBtb2RlbDogR3JvdXAsXG4gIGNvbXBhcmF0b3I6ICdsYWJlbCcsXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgZ3JvdXBzID0gdGhpcztcbiAgICB2YXIgcGFydGl0aW9uID0gb3B0aW9ucy5wYXJlbnQ7XG5cbiAgICAvLyB1cGRhdGUgZ3JvdXAgaW5kZXggb24gcmVzb3J0XG4gICAgdGhpcy5vbignc29ydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXAsIGkpIHtcbiAgICAgICAgZ3JvdXAuZ3JvdXBJbmRleCA9IGk7XG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTtcblxuICAgIC8vIHRoaXMucGFyZW50IDo9IHBhcnRpdGlvblxuICAgIGlmIChwYXJ0aXRpb24pIHtcbiAgICAgIHNldE9yZGVyaW5nKGdyb3VwcywgcGFydGl0aW9uLm9yZGVyaW5nKTtcblxuICAgICAgcGFydGl0aW9uLm9uKCdjaGFuZ2Ugb3JkZXJpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldE9yZGVyaW5nKGdyb3VwcywgcGFydGl0aW9uLm9yZGVyaW5nKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0056\n")},"0112":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Module dependencies.\n */\n\nvar transports = __webpack_require__(/*! ./transports/index */ \"834b\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"ee5b\");\nvar debug = __webpack_require__(/*! debug */ \"433b\")('engine.io-client:socket');\nvar index = __webpack_require__(/*! indexof */ \"3294\");\nvar parser = __webpack_require__(/*! engine.io-parser */ \"aa6c\");\nvar parseuri = __webpack_require__(/*! parseuri */ \"64a0\");\nvar parsejson = __webpack_require__(/*! parsejson */ \"185c\");\nvar parseqs = __webpack_require__(/*! parseqs */ \"914f\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = Socket;\n\n/**\n * Socket constructor.\n *\n * @param {String|Object} uri or options\n * @param {Object} options\n * @api public\n */\n\nfunction Socket (uri, opts) {\n  if (!(this instanceof Socket)) return new Socket(uri, opts);\n\n  opts = opts || {};\n\n  if (uri && 'object' === typeof uri) {\n    opts = uri;\n    uri = null;\n  }\n\n  if (uri) {\n    uri = parseuri(uri);\n    opts.hostname = uri.host;\n    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';\n    opts.port = uri.port;\n    if (uri.query) opts.query = uri.query;\n  } else if (opts.host) {\n    opts.hostname = parseuri(opts.host).host;\n  }\n\n  this.secure = null != opts.secure ? opts.secure\n    : (global.location && 'https:' === location.protocol);\n\n  if (opts.hostname && !opts.port) {\n    // if no port is specified manually, use the protocol default\n    opts.port = this.secure ? '443' : '80';\n  }\n\n  this.agent = opts.agent || false;\n  this.hostname = opts.hostname ||\n    (global.location ? location.hostname : 'localhost');\n  this.port = opts.port || (global.location && location.port\n      ? location.port\n      : (this.secure ? 443 : 80));\n  this.query = opts.query || {};\n  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);\n  this.upgrade = false !== opts.upgrade;\n  this.path = (opts.path || '/engine.io').replace(/\\/$/, '') + '/';\n  this.forceJSONP = !!opts.forceJSONP;\n  this.jsonp = false !== opts.jsonp;\n  this.forceBase64 = !!opts.forceBase64;\n  this.enablesXDR = !!opts.enablesXDR;\n  this.timestampParam = opts.timestampParam || 't';\n  this.timestampRequests = opts.timestampRequests;\n  this.transports = opts.transports || ['polling', 'websocket'];\n  this.readyState = '';\n  this.writeBuffer = [];\n  this.prevBufferLen = 0;\n  this.policyPort = opts.policyPort || 843;\n  this.rememberUpgrade = opts.rememberUpgrade || false;\n  this.binaryType = null;\n  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;\n  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;\n\n  if (true === this.perMessageDeflate) this.perMessageDeflate = {};\n  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {\n    this.perMessageDeflate.threshold = 1024;\n  }\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx || null;\n  this.key = opts.key || null;\n  this.passphrase = opts.passphrase || null;\n  this.cert = opts.cert || null;\n  this.ca = opts.ca || null;\n  this.ciphers = opts.ciphers || null;\n  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? null : opts.rejectUnauthorized;\n  this.forceNode = !!opts.forceNode;\n\n  // other options for Node.js client\n  var freeGlobal = typeof global === 'object' && global;\n  if (freeGlobal.global === freeGlobal) {\n    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {\n      this.extraHeaders = opts.extraHeaders;\n    }\n\n    if (opts.localAddress) {\n      this.localAddress = opts.localAddress;\n    }\n  }\n\n  // set on handshake\n  this.id = null;\n  this.upgrades = null;\n  this.pingInterval = null;\n  this.pingTimeout = null;\n\n  // set on heartbeat\n  this.pingIntervalTimer = null;\n  this.pingTimeoutTimer = null;\n\n  this.open();\n}\n\nSocket.priorWebsocketSuccess = false;\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nSocket.protocol = parser.protocol; // this is an int\n\n/**\n * Expose deps for legacy compatibility\n * and standalone browser access.\n */\n\nSocket.Socket = Socket;\nSocket.Transport = __webpack_require__(/*! ./transport */ \"0d97\");\nSocket.transports = __webpack_require__(/*! ./transports/index */ \"834b\");\nSocket.parser = __webpack_require__(/*! engine.io-parser */ \"aa6c\");\n\n/**\n * Creates transport of the given type.\n *\n * @param {String} transport name\n * @return {Transport}\n * @api private\n */\n\nSocket.prototype.createTransport = function (name) {\n  debug('creating transport \"%s\"', name);\n  var query = clone(this.query);\n\n  // append engine.io protocol identifier\n  query.EIO = parser.protocol;\n\n  // transport name\n  query.transport = name;\n\n  // session id if we already have one\n  if (this.id) query.sid = this.id;\n\n  var transport = new transports[name]({\n    agent: this.agent,\n    hostname: this.hostname,\n    port: this.port,\n    secure: this.secure,\n    path: this.path,\n    query: query,\n    forceJSONP: this.forceJSONP,\n    jsonp: this.jsonp,\n    forceBase64: this.forceBase64,\n    enablesXDR: this.enablesXDR,\n    timestampRequests: this.timestampRequests,\n    timestampParam: this.timestampParam,\n    policyPort: this.policyPort,\n    socket: this,\n    pfx: this.pfx,\n    key: this.key,\n    passphrase: this.passphrase,\n    cert: this.cert,\n    ca: this.ca,\n    ciphers: this.ciphers,\n    rejectUnauthorized: this.rejectUnauthorized,\n    perMessageDeflate: this.perMessageDeflate,\n    extraHeaders: this.extraHeaders,\n    forceNode: this.forceNode,\n    localAddress: this.localAddress\n  });\n\n  return transport;\n};\n\nfunction clone (obj) {\n  var o = {};\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      o[i] = obj[i];\n    }\n  }\n  return o;\n}\n\n/**\n * Initializes transport to use and starts probe.\n *\n * @api private\n */\nSocket.prototype.open = function () {\n  var transport;\n  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {\n    transport = 'websocket';\n  } else if (0 === this.transports.length) {\n    // Emit error on next tick so it can be listened to\n    var self = this;\n    setTimeout(function () {\n      self.emit('error', 'No transports available');\n    }, 0);\n    return;\n  } else {\n    transport = this.transports[0];\n  }\n  this.readyState = 'opening';\n\n  // Retry with the next transport if the transport is disabled (jsonp: false)\n  try {\n    transport = this.createTransport(transport);\n  } catch (e) {\n    this.transports.shift();\n    this.open();\n    return;\n  }\n\n  transport.open();\n  this.setTransport(transport);\n};\n\n/**\n * Sets the current transport. Disables the existing one (if any).\n *\n * @api private\n */\n\nSocket.prototype.setTransport = function (transport) {\n  debug('setting transport %s', transport.name);\n  var self = this;\n\n  if (this.transport) {\n    debug('clearing existing transport %s', this.transport.name);\n    this.transport.removeAllListeners();\n  }\n\n  // set up transport\n  this.transport = transport;\n\n  // set up transport listeners\n  transport\n  .on('drain', function () {\n    self.onDrain();\n  })\n  .on('packet', function (packet) {\n    self.onPacket(packet);\n  })\n  .on('error', function (e) {\n    self.onError(e);\n  })\n  .on('close', function () {\n    self.onClose('transport close');\n  });\n};\n\n/**\n * Probes a transport.\n *\n * @param {String} transport name\n * @api private\n */\n\nSocket.prototype.probe = function (name) {\n  debug('probing transport \"%s\"', name);\n  var transport = this.createTransport(name, { probe: 1 });\n  var failed = false;\n  var self = this;\n\n  Socket.priorWebsocketSuccess = false;\n\n  function onTransportOpen () {\n    if (self.onlyBinaryUpgrades) {\n      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;\n      failed = failed || upgradeLosesBinary;\n    }\n    if (failed) return;\n\n    debug('probe transport \"%s\" opened', name);\n    transport.send([{ type: 'ping', data: 'probe' }]);\n    transport.once('packet', function (msg) {\n      if (failed) return;\n      if ('pong' === msg.type && 'probe' === msg.data) {\n        debug('probe transport \"%s\" pong', name);\n        self.upgrading = true;\n        self.emit('upgrading', transport);\n        if (!transport) return;\n        Socket.priorWebsocketSuccess = 'websocket' === transport.name;\n\n        debug('pausing current transport \"%s\"', self.transport.name);\n        self.transport.pause(function () {\n          if (failed) return;\n          if ('closed' === self.readyState) return;\n          debug('changing transport and sending upgrade packet');\n\n          cleanup();\n\n          self.setTransport(transport);\n          transport.send([{ type: 'upgrade' }]);\n          self.emit('upgrade', transport);\n          transport = null;\n          self.upgrading = false;\n          self.flush();\n        });\n      } else {\n        debug('probe transport \"%s\" failed', name);\n        var err = new Error('probe error');\n        err.transport = transport.name;\n        self.emit('upgradeError', err);\n      }\n    });\n  }\n\n  function freezeTransport () {\n    if (failed) return;\n\n    // Any callback called by transport should be ignored since now\n    failed = true;\n\n    cleanup();\n\n    transport.close();\n    transport = null;\n  }\n\n  // Handle any error that happens while probing\n  function onerror (err) {\n    var error = new Error('probe error: ' + err);\n    error.transport = transport.name;\n\n    freezeTransport();\n\n    debug('probe transport \"%s\" failed because of error: %s', name, err);\n\n    self.emit('upgradeError', error);\n  }\n\n  function onTransportClose () {\n    onerror('transport closed');\n  }\n\n  // When the socket is closed while we're probing\n  function onclose () {\n    onerror('socket closed');\n  }\n\n  // When the socket is upgraded while we're probing\n  function onupgrade (to) {\n    if (transport && to.name !== transport.name) {\n      debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n      freezeTransport();\n    }\n  }\n\n  // Remove all listeners on the transport and on self\n  function cleanup () {\n    transport.removeListener('open', onTransportOpen);\n    transport.removeListener('error', onerror);\n    transport.removeListener('close', onTransportClose);\n    self.removeListener('close', onclose);\n    self.removeListener('upgrading', onupgrade);\n  }\n\n  transport.once('open', onTransportOpen);\n  transport.once('error', onerror);\n  transport.once('close', onTransportClose);\n\n  this.once('close', onclose);\n  this.once('upgrading', onupgrade);\n\n  transport.open();\n};\n\n/**\n * Called when connection is deemed open.\n *\n * @api public\n */\n\nSocket.prototype.onOpen = function () {\n  debug('socket open');\n  this.readyState = 'open';\n  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;\n  this.emit('open');\n  this.flush();\n\n  // we check for `readyState` in case an `open`\n  // listener already closed the socket\n  if ('open' === this.readyState && this.upgrade && this.transport.pause) {\n    debug('starting upgrade probes');\n    for (var i = 0, l = this.upgrades.length; i < l; i++) {\n      this.probe(this.upgrades[i]);\n    }\n  }\n};\n\n/**\n * Handles a packet.\n *\n * @api private\n */\n\nSocket.prototype.onPacket = function (packet) {\n  if ('opening' === this.readyState || 'open' === this.readyState ||\n      'closing' === this.readyState) {\n    debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n\n    this.emit('packet', packet);\n\n    // Socket is live - any packet counts\n    this.emit('heartbeat');\n\n    switch (packet.type) {\n      case 'open':\n        this.onHandshake(parsejson(packet.data));\n        break;\n\n      case 'pong':\n        this.setPing();\n        this.emit('pong');\n        break;\n\n      case 'error':\n        var err = new Error('server error');\n        err.code = packet.data;\n        this.onError(err);\n        break;\n\n      case 'message':\n        this.emit('data', packet.data);\n        this.emit('message', packet.data);\n        break;\n    }\n  } else {\n    debug('packet received with socket readyState \"%s\"', this.readyState);\n  }\n};\n\n/**\n * Called upon handshake completion.\n *\n * @param {Object} handshake obj\n * @api private\n */\n\nSocket.prototype.onHandshake = function (data) {\n  this.emit('handshake', data);\n  this.id = data.sid;\n  this.transport.query.sid = data.sid;\n  this.upgrades = this.filterUpgrades(data.upgrades);\n  this.pingInterval = data.pingInterval;\n  this.pingTimeout = data.pingTimeout;\n  this.onOpen();\n  // In case open handler closes socket\n  if ('closed' === this.readyState) return;\n  this.setPing();\n\n  // Prolong liveness of socket on heartbeat\n  this.removeListener('heartbeat', this.onHeartbeat);\n  this.on('heartbeat', this.onHeartbeat);\n};\n\n/**\n * Resets ping timeout.\n *\n * @api private\n */\n\nSocket.prototype.onHeartbeat = function (timeout) {\n  clearTimeout(this.pingTimeoutTimer);\n  var self = this;\n  self.pingTimeoutTimer = setTimeout(function () {\n    if ('closed' === self.readyState) return;\n    self.onClose('ping timeout');\n  }, timeout || (self.pingInterval + self.pingTimeout));\n};\n\n/**\n * Pings server every `this.pingInterval` and expects response\n * within `this.pingTimeout` or closes connection.\n *\n * @api private\n */\n\nSocket.prototype.setPing = function () {\n  var self = this;\n  clearTimeout(self.pingIntervalTimer);\n  self.pingIntervalTimer = setTimeout(function () {\n    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);\n    self.ping();\n    self.onHeartbeat(self.pingTimeout);\n  }, self.pingInterval);\n};\n\n/**\n* Sends a ping packet.\n*\n* @api private\n*/\n\nSocket.prototype.ping = function () {\n  var self = this;\n  this.sendPacket('ping', function () {\n    self.emit('ping');\n  });\n};\n\n/**\n * Called on `drain` event\n *\n * @api private\n */\n\nSocket.prototype.onDrain = function () {\n  this.writeBuffer.splice(0, this.prevBufferLen);\n\n  // setting prevBufferLen = 0 is very important\n  // for example, when upgrading, upgrade packet is sent over,\n  // and a nonzero prevBufferLen could cause problems on `drain`\n  this.prevBufferLen = 0;\n\n  if (0 === this.writeBuffer.length) {\n    this.emit('drain');\n  } else {\n    this.flush();\n  }\n};\n\n/**\n * Flush write buffers.\n *\n * @api private\n */\n\nSocket.prototype.flush = function () {\n  if ('closed' !== this.readyState && this.transport.writable &&\n    !this.upgrading && this.writeBuffer.length) {\n    debug('flushing %d packets in socket', this.writeBuffer.length);\n    this.transport.send(this.writeBuffer);\n    // keep track of current length of writeBuffer\n    // splice writeBuffer and callbackBuffer on `drain`\n    this.prevBufferLen = this.writeBuffer.length;\n    this.emit('flush');\n  }\n};\n\n/**\n * Sends a message.\n *\n * @param {String} message.\n * @param {Function} callback function.\n * @param {Object} options.\n * @return {Socket} for chaining.\n * @api public\n */\n\nSocket.prototype.write =\nSocket.prototype.send = function (msg, options, fn) {\n  this.sendPacket('message', msg, options, fn);\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {String} packet type.\n * @param {String} data.\n * @param {Object} options.\n * @param {Function} callback function.\n * @api private\n */\n\nSocket.prototype.sendPacket = function (type, data, options, fn) {\n  if ('function' === typeof data) {\n    fn = data;\n    data = undefined;\n  }\n\n  if ('function' === typeof options) {\n    fn = options;\n    options = null;\n  }\n\n  if ('closing' === this.readyState || 'closed' === this.readyState) {\n    return;\n  }\n\n  options = options || {};\n  options.compress = false !== options.compress;\n\n  var packet = {\n    type: type,\n    data: data,\n    options: options\n  };\n  this.emit('packetCreate', packet);\n  this.writeBuffer.push(packet);\n  if (fn) this.once('flush', fn);\n  this.flush();\n};\n\n/**\n * Closes the connection.\n *\n * @api private\n */\n\nSocket.prototype.close = function () {\n  if ('opening' === this.readyState || 'open' === this.readyState) {\n    this.readyState = 'closing';\n\n    var self = this;\n\n    if (this.writeBuffer.length) {\n      this.once('drain', function () {\n        if (this.upgrading) {\n          waitForUpgrade();\n        } else {\n          close();\n        }\n      });\n    } else if (this.upgrading) {\n      waitForUpgrade();\n    } else {\n      close();\n    }\n  }\n\n  function close () {\n    self.onClose('forced close');\n    debug('socket closing - telling transport to close');\n    self.transport.close();\n  }\n\n  function cleanupAndClose () {\n    self.removeListener('upgrade', cleanupAndClose);\n    self.removeListener('upgradeError', cleanupAndClose);\n    close();\n  }\n\n  function waitForUpgrade () {\n    // wait for upgrade to finish since we can't send packets while pausing a transport\n    self.once('upgrade', cleanupAndClose);\n    self.once('upgradeError', cleanupAndClose);\n  }\n\n  return this;\n};\n\n/**\n * Called upon transport error\n *\n * @api private\n */\n\nSocket.prototype.onError = function (err) {\n  debug('socket error %j', err);\n  Socket.priorWebsocketSuccess = false;\n  this.emit('error', err);\n  this.onClose('transport error', err);\n};\n\n/**\n * Called upon transport close.\n *\n * @api private\n */\n\nSocket.prototype.onClose = function (reason, desc) {\n  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {\n    debug('socket close with reason: \"%s\"', reason);\n    var self = this;\n\n    // clear timers\n    clearTimeout(this.pingIntervalTimer);\n    clearTimeout(this.pingTimeoutTimer);\n\n    // stop event from firing again for transport\n    this.transport.removeAllListeners('close');\n\n    // ensure transport won't stay open\n    this.transport.close();\n\n    // ignore further transport communication\n    this.transport.removeAllListeners();\n\n    // set ready state\n    this.readyState = 'closed';\n\n    // clear session id\n    this.id = null;\n\n    // emit close event\n    this.emit('close', reason, desc);\n\n    // clean buffers after, so users can still\n    // grab the buffers on `close` event\n    self.writeBuffer = [];\n    self.prevBufferLen = 0;\n  }\n};\n\n/**\n * Filters upgrades, returning only those matching client transports.\n *\n * @param {Array} server upgrades\n * @api private\n *\n */\n\nSocket.prototype.filterUpgrades = function (upgrades) {\n  var filteredUpgrades = [];\n  for (var i = 0, j = upgrades.length; i < j; i++) {\n    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);\n  }\n  return filteredUpgrades;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"698d\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMDExMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzPzM1YjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzL2luZGV4Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIGluZGV4ID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgcGFyc2Vqc29uID0gcmVxdWlyZSgncGFyc2Vqc29uJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmkgb3Igb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0ICh1cmksIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVyaSwgb3B0cyk7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgaWYgKHVyaSAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIHVyaSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1cmkpIHtcbiAgICB1cmkgPSBwYXJzZXVyaSh1cmkpO1xuICAgIG9wdHMuaG9zdG5hbWUgPSB1cmkuaG9zdDtcbiAgICBvcHRzLnNlY3VyZSA9IHVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzJyB8fCB1cmkucHJvdG9jb2wgPT09ICd3c3MnO1xuICAgIG9wdHMucG9ydCA9IHVyaS5wb3J0O1xuICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG4gIH0gZWxzZSBpZiAob3B0cy5ob3N0KSB7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHBhcnNldXJpKG9wdHMuaG9zdCkuaG9zdDtcbiAgfVxuXG4gIHRoaXMuc2VjdXJlID0gbnVsbCAhPSBvcHRzLnNlY3VyZSA/IG9wdHMuc2VjdXJlXG4gICAgOiAoZ2xvYmFsLmxvY2F0aW9uICYmICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbCk7XG5cbiAgaWYgKG9wdHMuaG9zdG5hbWUgJiYgIW9wdHMucG9ydCkge1xuICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcbiAgICBvcHRzLnBvcnQgPSB0aGlzLnNlY3VyZSA/ICc0NDMnIDogJzgwJztcbiAgfVxuXG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fFxuICAgIChnbG9iYWwubG9jYXRpb24gPyBsb2NhdGlvbi5ob3N0bmFtZSA6ICdsb2NhbGhvc3QnKTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0IHx8IChnbG9iYWwubG9jYXRpb24gJiYgbG9jYXRpb24ucG9ydFxuICAgICAgPyBsb2NhdGlvbi5wb3J0XG4gICAgICA6ICh0aGlzLnNlY3VyZSA/IDQ0MyA6IDgwKSk7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5IHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB0aGlzLnF1ZXJ5KSB0aGlzLnF1ZXJ5ID0gcGFyc2Vxcy5kZWNvZGUodGhpcy5xdWVyeSk7XG4gIHRoaXMudXBncmFkZSA9IGZhbHNlICE9PSBvcHRzLnVwZ3JhZGU7XG4gIHRoaXMucGF0aCA9IChvcHRzLnBhdGggfHwgJy9lbmdpbmUuaW8nKS5yZXBsYWNlKC9cXC8kLywgJycpICsgJy8nO1xuICB0aGlzLmZvcmNlSlNPTlAgPSAhIW9wdHMuZm9yY2VKU09OUDtcbiAgdGhpcy5qc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuICB0aGlzLmZvcmNlQmFzZTY0ID0gISFvcHRzLmZvcmNlQmFzZTY0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSAhIW9wdHMuZW5hYmxlc1hEUjtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcbiAgdGhpcy5wb2xpY3lQb3J0ID0gb3B0cy5wb2xpY3lQb3J0IHx8IDg0MztcbiAgdGhpcy5yZW1lbWJlclVwZ3JhZGUgPSBvcHRzLnJlbWVtYmVyVXBncmFkZSB8fCBmYWxzZTtcbiAgdGhpcy5iaW5hcnlUeXBlID0gbnVsbDtcbiAgdGhpcy5vbmx5QmluYXJ5VXBncmFkZXMgPSBvcHRzLm9ubHlCaW5hcnlVcGdyYWRlcztcbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IGZhbHNlICE9PSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlID8gKG9wdHMucGVyTWVzc2FnZURlZmxhdGUgfHwge30pIDogZmFsc2U7XG5cbiAgaWYgKHRydWUgPT09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUpIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgaWYgKHRoaXMucGVyTWVzc2FnZURlZmxhdGUgJiYgbnVsbCA9PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkID0gMTAyNDtcbiAgfVxuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4IHx8IG51bGw7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXkgfHwgbnVsbDtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlIHx8IG51bGw7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydCB8fCBudWxsO1xuICB0aGlzLmNhID0gb3B0cy5jYSB8fCBudWxsO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnMgfHwgbnVsbDtcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuICB0aGlzLmZvcmNlTm9kZSA9ICEhb3B0cy5mb3JjZU5vZGU7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG4gIGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCkge1xuICAgIGlmIChvcHRzLmV4dHJhSGVhZGVycyAmJiBPYmplY3Qua2V5cyhvcHRzLmV4dHJhSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgICB9XG5cbiAgICBpZiAob3B0cy5sb2NhbEFkZHJlc3MpIHtcbiAgICAgIHRoaXMubG9jYWxBZGRyZXNzID0gb3B0cy5sb2NhbEFkZHJlc3M7XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IG9uIGhhbmRzaGFrZVxuICB0aGlzLmlkID0gbnVsbDtcbiAgdGhpcy51cGdyYWRlcyA9IG51bGw7XG4gIHRoaXMucGluZ0ludGVydmFsID0gbnVsbDtcbiAgdGhpcy5waW5nVGltZW91dCA9IG51bGw7XG5cbiAgLy8gc2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnBpbmdJbnRlcnZhbFRpbWVyID0gbnVsbDtcbiAgdGhpcy5waW5nVGltZW91dFRpbWVyID0gbnVsbDtcblxuICB0aGlzLm9wZW4oKTtcbn1cblxuU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG4vKipcbiAqIEV4cG9zZSBkZXBzIGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eVxuICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG4gKi9cblxuU29ja2V0LlNvY2tldCA9IFNvY2tldDtcblNvY2tldC5UcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpO1xuU29ja2V0LnRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMvaW5kZXgnKTtcblNvY2tldC5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciBxdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuXG4gIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICBxdWVyeS5FSU8gPSBwYXJzZXIucHJvdG9jb2w7XG5cbiAgLy8gdHJhbnNwb3J0IG5hbWVcbiAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcblxuICAvLyBzZXNzaW9uIGlkIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcbiAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cbiAgdmFyIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzW25hbWVdKHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBob3N0bmFtZTogdGhpcy5ob3N0bmFtZSxcbiAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgc2VjdXJlOiB0aGlzLnNlY3VyZSxcbiAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGZvcmNlSlNPTlA6IHRoaXMuZm9yY2VKU09OUCxcbiAgICBqc29ucDogdGhpcy5qc29ucCxcbiAgICBmb3JjZUJhc2U2NDogdGhpcy5mb3JjZUJhc2U2NCxcbiAgICBlbmFibGVzWERSOiB0aGlzLmVuYWJsZXNYRFIsXG4gICAgdGltZXN0YW1wUmVxdWVzdHM6IHRoaXMudGltZXN0YW1wUmVxdWVzdHMsXG4gICAgdGltZXN0YW1wUGFyYW06IHRoaXMudGltZXN0YW1wUGFyYW0sXG4gICAgcG9saWN5UG9ydDogdGhpcy5wb2xpY3lQb3J0LFxuICAgIHNvY2tldDogdGhpcyxcbiAgICBwZng6IHRoaXMucGZ4LFxuICAgIGtleTogdGhpcy5rZXksXG4gICAgcGFzc3BocmFzZTogdGhpcy5wYXNzcGhyYXNlLFxuICAgIGNlcnQ6IHRoaXMuY2VydCxcbiAgICBjYTogdGhpcy5jYSxcbiAgICBjaXBoZXJzOiB0aGlzLmNpcGhlcnMsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICBleHRyYUhlYWRlcnM6IHRoaXMuZXh0cmFIZWFkZXJzLFxuICAgIGZvcmNlTm9kZTogdGhpcy5mb3JjZU5vZGUsXG4gICAgbG9jYWxBZGRyZXNzOiB0aGlzLmxvY2FsQWRkcmVzc1xuICB9KTtcblxuICByZXR1cm4gdHJhbnNwb3J0O1xufTtcblxuZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIG9baV0gPSBvYmpbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU29ja2V0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHJhbnNwb3J0O1xuICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT09IC0xKSB7XG4gICAgdHJhbnNwb3J0ID0gJ3dlYnNvY2tldCc7XG4gIH0gZWxzZSBpZiAoMCA9PT0gdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuICB9XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblxuICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG4gIHRyeSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuICAgIHRoaXMub3BlbigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG4gIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICBkZWJ1Zygnc2V0dGluZyB0cmFuc3BvcnQgJXMnLCB0cmFuc3BvcnQubmFtZSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICBkZWJ1ZygnY2xlYXJpbmcgZXhpc3RpbmcgdHJhbnNwb3J0ICVzJywgdGhpcy50cmFuc3BvcnQubmFtZSk7XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG4gIHRyYW5zcG9ydFxuICAub24oJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25EcmFpbigpO1xuICB9KVxuICAub24oJ3BhY2tldCcsIGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH0pXG4gIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcihlKTtcbiAgfSlcbiAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ3RyYW5zcG9ydCBjbG9zZScpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUHJvYmVzIGEgdHJhbnNwb3J0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wcm9iZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdwcm9iaW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KG5hbWUsIHsgcHJvYmU6IDEgfSk7XG4gIHZhciBmYWlsZWQgPSBmYWxzZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4gKCkge1xuICAgIGlmIChzZWxmLm9ubHlCaW5hcnlVcGdyYWRlcykge1xuICAgICAgdmFyIHVwZ3JhZGVMb3Nlc0JpbmFyeSA9ICF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmIHNlbGYudHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5O1xuICAgICAgZmFpbGVkID0gZmFpbGVkIHx8IHVwZ3JhZGVMb3Nlc0JpbmFyeTtcbiAgICB9XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgb3BlbmVkJywgbmFtZSk7XG4gICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BpbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcbiAgICB0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgaWYgKCdwb25nJyA9PT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PT0gbXNnLmRhdGEpIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgcG9uZycsIG5hbWUpO1xuICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkaW5nJywgdHJhbnNwb3J0KTtcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHJldHVybjtcbiAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09PSB0cmFuc3BvcnQubmFtZTtcblxuICAgICAgICBkZWJ1ZygncGF1c2luZyBjdXJyZW50IHRyYW5zcG9ydCBcIiVzXCInLCBzZWxmLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgc2VsZi50cmFuc3BvcnQucGF1c2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoJ2Nsb3NlZCcgPT09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICAgIGRlYnVnKCdjaGFuZ2luZyB0cmFuc3BvcnQgYW5kIHNlbmRpbmcgdXBncmFkZSBwYWNrZXQnKTtcblxuICAgICAgICAgIGNsZWFudXAoKTtcblxuICAgICAgICAgIHNlbGYuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3VwZ3JhZGUnIH1dKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGUnLCB0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgc2VsZi51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLmZsdXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkJywgbmFtZSk7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG4gICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0ICgpIHtcbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcbiAgICBmYWlsZWQgPSB0cnVlO1xuXG4gICAgY2xlYW51cCgpO1xuXG4gICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIC8vIEhhbmRsZSBhbnkgZXJyb3IgdGhhdCBoYXBwZW5zIHdoaWxlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25lcnJvciAoZXJyKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG4gICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICBmcmVlemVUcmFuc3BvcnQoKTtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCBiZWNhdXNlIG9mIGVycm9yOiAlcycsIG5hbWUsIGVycik7XG5cbiAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UgKCkge1xuICAgIG9uZXJyb3IoJ3RyYW5zcG9ydCBjbG9zZWQnKTtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHNvY2tldCBpcyBjbG9zZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmNsb3NlICgpIHtcbiAgICBvbmVycm9yKCdzb2NrZXQgY2xvc2VkJyk7XG4gIH1cblxuICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgdXBncmFkZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbnVwZ3JhZGUgKHRvKSB7XG4gICAgaWYgKHRyYW5zcG9ydCAmJiB0by5uYW1lICE9PSB0cmFuc3BvcnQubmFtZSkge1xuICAgICAgZGVidWcoJ1wiJXNcIiB3b3JrcyAtIGFib3J0aW5nIFwiJXNcIicsIHRvLm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIHRoZSB0cmFuc3BvcnQgYW5kIG9uIHNlbGZcbiAgZnVuY3Rpb24gY2xlYW51cCAoKSB7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkaW5nJywgb251cGdyYWRlKTtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vbmNlKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25lcnJvcik7XG4gIHRyYW5zcG9ydC5vbmNlKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXG4gIHRoaXMub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgdGhpcy5vbmNlKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgZGVlbWVkIG9wZW4uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3NvY2tldCBvcGVuJyk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09PSB0aGlzLnRyYW5zcG9ydC5uYW1lO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgdGhpcy5mbHVzaCgpO1xuXG4gIC8vIHdlIGNoZWNrIGZvciBgcmVhZHlTdGF0ZWAgaW4gY2FzZSBhbiBgb3BlbmBcbiAgLy8gbGlzdGVuZXIgYWxyZWFkeSBjbG9zZWQgdGhlIHNvY2tldFxuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy51cGdyYWRlICYmIHRoaXMudHJhbnNwb3J0LnBhdXNlKSB7XG4gICAgZGVidWcoJ3N0YXJ0aW5nIHVwZ3JhZGUgcHJvYmVzJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnVwZ3JhZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCByZWNlaXZlOiB0eXBlIFwiJXNcIiwgZGF0YSBcIiVzXCInLCBwYWNrZXQudHlwZSwgcGFja2V0LmRhdGEpO1xuXG4gICAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXG4gICAgLy8gU29ja2V0IGlzIGxpdmUgLSBhbnkgcGFja2V0IGNvdW50c1xuICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG5cbiAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgdGhpcy5vbkhhbmRzaGFrZShwYXJzZWpzb24ocGFja2V0LmRhdGEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3BvbmcnOlxuICAgICAgICB0aGlzLnNldFBpbmcoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdwb25nJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3NlcnZlciBlcnJvcicpO1xuICAgICAgICBlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kc2hha2Ugb2JqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBkYXRhKTtcbiAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy51cGdyYWRlcyA9IHRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG4gIHRoaXMucGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuICB0aGlzLm9uT3BlbigpO1xuICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG4gIHRoaXMuc2V0UGluZygpO1xuXG4gIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbiAgdGhpcy5vbignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG59O1xuXG4vKipcbiAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhlYXJ0YmVhdCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucGluZ1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnY2xvc2VkJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgc2VsZi5vbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgfSwgdGltZW91dCB8fCAoc2VsZi5waW5nSW50ZXJ2YWwgKyBzZWxmLnBpbmdUaW1lb3V0KSk7XG59O1xuXG4vKipcbiAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG4gKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0UGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjbGVhclRpbWVvdXQoc2VsZi5waW5nSW50ZXJ2YWxUaW1lcik7XG4gIHNlbGYucGluZ0ludGVydmFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBwaW5nIHBhY2tldCAtIGV4cGVjdGluZyBwb25nIHdpdGhpbiAlc21zJywgc2VsZi5waW5nVGltZW91dCk7XG4gICAgc2VsZi5waW5nKCk7XG4gICAgc2VsZi5vbkhlYXJ0YmVhdChzZWxmLnBpbmdUaW1lb3V0KTtcbiAgfSwgc2VsZi5waW5nSW50ZXJ2YWwpO1xufTtcblxuLyoqXG4qIFNlbmRzIGEgcGluZyBwYWNrZXQuXG4qXG4qIEBhcGkgcHJpdmF0ZVxuKi9cblxuU29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VuZFBhY2tldCgncGluZycsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmVtaXQoJ3BpbmcnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBvbiBgZHJhaW5gIGV2ZW50XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkRyYWluID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuXG4gIC8vIHNldHRpbmcgcHJldkJ1ZmZlckxlbiA9IDAgaXMgdmVyeSBpbXBvcnRhbnRcbiAgLy8gZm9yIGV4YW1wbGUsIHdoZW4gdXBncmFkaW5nLCB1cGdyYWRlIHBhY2tldCBpcyBzZW50IG92ZXIsXG4gIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG5cbiAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGbHVzaCB3cml0ZSBidWZmZXJzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyAhPT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmXG4gICAgIXRoaXMudXBncmFkaW5nICYmIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgZGVidWcoJ2ZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0JywgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO1xuICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuICAgIHRoaXMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUud3JpdGUgPVxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBvcHRpb25zLCBmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFja2V0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmRQYWNrZXQgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSwgb3B0aW9ucywgZm4pIHtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgZm4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICBmbiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBpZiAoJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9O1xuICB0aGlzLmVtaXQoJ3BhY2tldENyZWF0ZScsIHBhY2tldCk7XG4gIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ2ZvcmNlZCBjbG9zZScpO1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2luZyAtIHRlbGxpbmcgdHJhbnNwb3J0IHRvIGNsb3NlJyk7XG4gICAgc2VsZi50cmFuc3BvcnQuY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSAoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBjbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUgKCkge1xuICAgIC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1Zygnc29ja2V0IGVycm9yICVqJywgZXJyKTtcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5vbkNsb3NlKCd0cmFuc3BvcnQgZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NlIHdpdGggcmVhc29uOiBcIiVzXCInLCByZWFzb24pO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblxuICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcblxuICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcblxuICAgIC8vIGlnbm9yZSBmdXJ0aGVyIHRyYW5zcG9ydCBjb21tdW5pY2F0aW9uXG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICAvLyBzZXQgcmVhZHkgc3RhdGVcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblxuICAgIC8vIGNsZWFyIHNlc3Npb24gaWRcbiAgICB0aGlzLmlkID0gbnVsbDtcblxuICAgIC8vIGVtaXQgY2xvc2UgZXZlbnRcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uLCBkZXNjKTtcblxuICAgIC8vIGNsZWFuIGJ1ZmZlcnMgYWZ0ZXIsIHNvIHVzZXJzIGNhbiBzdGlsbFxuICAgIC8vIGdyYWIgdGhlIGJ1ZmZlcnMgb24gYGNsb3NlYCBldmVudFxuICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcbiAgICBzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbHRlcnMgdXBncmFkZXMsIHJldHVybmluZyBvbmx5IHRob3NlIG1hdGNoaW5nIGNsaWVudCB0cmFuc3BvcnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuICogQGFwaSBwcml2YXRlXG4gKlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmlsdGVyVXBncmFkZXMgPSBmdW5jdGlvbiAodXBncmFkZXMpIHtcbiAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICBpZiAofmluZGV4KHRoaXMudHJhbnNwb3J0cywgdXBncmFkZXNbaV0pKSBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuICB9XG4gIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0112\n")},"072d":function(module,exports){eval("/**\n * Server side filtering\n *\n * Implementation of a dataset backed by a server, which in turn uses fi. postgreSQL\n * Fully asynchronous, based on socketIO.\n *\n * Most methods below result in a message with the methodName and a data object, containing:\n *  * `datasets` and `dataview`, or `dataset`\n *  * `filterId` or `facetId`\n *\n * Data can be requested using the dataview.getData() method\n * responds with a `newData` message containing `filterId` and `data`.\n *\n * @module driver/server\n */\n\n/**\n * Autoconfigure a dataset\n *\n * @param {Dataset} dataset\n */\nfunction scan (dataset) {\n  // Dataset -> Datasets -> Spot\n  var spot = dataset.collection.parent;\n\n  if (spot.isLockedDown) {\n    // spot-server will not respond so no use requesting a scan\n    return;\n  }\n\n  spot.socket.emit('scanData', {\n    dataset: dataset.toJSON()\n  });\n}\n\n/**\n * setMinMax sets the range of a continuous or time facet\n *\n * @param {Dataset} dataset\n * @param {Facet} facet\n */\nfunction setMinMax (dataset, facet) {\n  // Dataset -> Datasets -> Spot\n  var spot = dataset.collection.parent;\n\n  if (spot.isLockedDown) {\n    spot.socket.emit('setMinMax', {\n      datasetId: dataset.getId(),\n      facetId: facet.getId()\n    });\n  } else {\n    spot.socket.emit('setMinMax', {\n      datasetId: dataset.getId(),\n      dataset: dataset.toJSON(),\n      facetId: facet.getId()\n    });\n  }\n}\n\n/**\n * setCategories finds finds all values on an ordinal (categorial) axis\n * Updates the categorialTransform of the facet\n *\n * @param {Dataset} dataset\n * @param {Facet} facet\n */\nfunction setCategories (dataset, facet) {\n  // Dataset -> Datasets -> Spot\n  var spot = dataset.collection.parent;\n\n  facet.categorialTransform.rules.reset();\n  if (spot.isLockedDown) {\n    spot.socket.emit('setCategories', {\n      datasetId: dataset.getId(),\n      facetId: facet.getId()\n    });\n  } else {\n    spot.socket.emit('setCategories', {\n      datasetId: dataset.getId(),\n      dataset: dataset.toJSON(),\n      facetId: facet.getId()\n    });\n  }\n}\n\n/**\n * Calculate 100 percentiles (ie. 1,2,3,4 etc.), and initialize the `facet.continuousTransform`\n *\n * @param {Dataset} dataset\n * @param {Facet} facet\n */\nfunction setPercentiles (dataset, facet) {\n  // Dataset -> Datasets -> Spot\n  var spot = dataset.collection.parent;\n\n  if (spot.isLockedDown) {\n    spot.socket.emit('setPercentiles', {\n      datasetId: dataset.getId(),\n      facetId: facet.getId()\n    });\n  } else {\n    spot.socket.emit('setPercentiles', {\n      datasetId: dataset.getId(),\n      dataset: dataset.toJSON(),\n      facetId: facet.getId()\n    });\n  }\n}\n\n/**\n * Initialize the data filter, and construct the getData callback function on the filter.\n * @param {Dataview} dataview\n * @param {Filter} filter\n */\nfunction initDataFilter (dataview, filter) {\n  // as the SQL server implementation is stateless, nothing to do here\n}\n\n/**\n * The opposite or initDataFilter, it should remove the filter and deallocate other configuration\n * related to the filter.\n * @param {Filter} filter\n */\nfunction releaseDataFilter (filter) {\n  // as the SQL server implementation is stateless, nothing to do here\n}\n\n/**\n * Change the filter parameters for an initialized filter\n * @param {Filter} filter\n */\nfunction updateDataFilter (filter) {\n  // as the SQL server implementation is stateless, nothing to do here\n}\n\n/**\n * Get data for every filter, and trigger a 'newData' event\n *\n * Returns a Promise that resolves to the dataview when all data and metadata has been updated\n *\n * @param {Dataview} dataview\n * @returns {Promise}\n */\nfunction getData (dataview) {\n  var spot = dataview.parent;\n\n  return new Promise(function (resolve, reject) {\n    if (spot.isLockedDown) {\n      spot.socket.emit('getData', {\n        dataview: dataview.toJSON()\n      });\n    } else {\n      spot.socket.emit('getData', {\n        datasets: spot.cachedDatasets,\n        dataview: dataview.toJSON()\n      });\n    }\n\n    dataview.once('newMetaData', function () {\n      resolve(dataview);\n    });\n  });\n}\n\nmodule.exports = {\n  driverType: 'server',\n  scan: scan,\n  setMinMax: setMinMax,\n  setCategories: setCategories,\n  setPercentiles: setPercentiles,\n  initDataFilter: initDataFilter,\n  releaseDataFilter: releaseDataFilter,\n  updateDataFilter: updateDataFilter,\n  getData: getData\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMDcyZC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZHJpdmVyL3NlcnZlci5qcz9lMzc3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2VydmVyIHNpZGUgZmlsdGVyaW5nXG4gKlxuICogSW1wbGVtZW50YXRpb24gb2YgYSBkYXRhc2V0IGJhY2tlZCBieSBhIHNlcnZlciwgd2hpY2ggaW4gdHVybiB1c2VzIGZpLiBwb3N0Z3JlU1FMXG4gKiBGdWxseSBhc3luY2hyb25vdXMsIGJhc2VkIG9uIHNvY2tldElPLlxuICpcbiAqIE1vc3QgbWV0aG9kcyBiZWxvdyByZXN1bHQgaW4gYSBtZXNzYWdlIHdpdGggdGhlIG1ldGhvZE5hbWUgYW5kIGEgZGF0YSBvYmplY3QsIGNvbnRhaW5pbmc6XG4gKiAgKiBgZGF0YXNldHNgIGFuZCBgZGF0YXZpZXdgLCBvciBgZGF0YXNldGBcbiAqICAqIGBmaWx0ZXJJZGAgb3IgYGZhY2V0SWRgXG4gKlxuICogRGF0YSBjYW4gYmUgcmVxdWVzdGVkIHVzaW5nIHRoZSBkYXRhdmlldy5nZXREYXRhKCkgbWV0aG9kXG4gKiByZXNwb25kcyB3aXRoIGEgYG5ld0RhdGFgIG1lc3NhZ2UgY29udGFpbmluZyBgZmlsdGVySWRgIGFuZCBgZGF0YWAuXG4gKlxuICogQG1vZHVsZSBkcml2ZXIvc2VydmVyXG4gKi9cblxuLyoqXG4gKiBBdXRvY29uZmlndXJlIGEgZGF0YXNldFxuICpcbiAqIEBwYXJhbSB7RGF0YXNldH0gZGF0YXNldFxuICovXG5mdW5jdGlvbiBzY2FuIChkYXRhc2V0KSB7XG4gIC8vIERhdGFzZXQgLT4gRGF0YXNldHMgLT4gU3BvdFxuICB2YXIgc3BvdCA9IGRhdGFzZXQuY29sbGVjdGlvbi5wYXJlbnQ7XG5cbiAgaWYgKHNwb3QuaXNMb2NrZWREb3duKSB7XG4gICAgLy8gc3BvdC1zZXJ2ZXIgd2lsbCBub3QgcmVzcG9uZCBzbyBubyB1c2UgcmVxdWVzdGluZyBhIHNjYW5cbiAgICByZXR1cm47XG4gIH1cblxuICBzcG90LnNvY2tldC5lbWl0KCdzY2FuRGF0YScsIHtcbiAgICBkYXRhc2V0OiBkYXRhc2V0LnRvSlNPTigpXG4gIH0pO1xufVxuXG4vKipcbiAqIHNldE1pbk1heCBzZXRzIHRoZSByYW5nZSBvZiBhIGNvbnRpbnVvdXMgb3IgdGltZSBmYWNldFxuICpcbiAqIEBwYXJhbSB7RGF0YXNldH0gZGF0YXNldFxuICogQHBhcmFtIHtGYWNldH0gZmFjZXRcbiAqL1xuZnVuY3Rpb24gc2V0TWluTWF4IChkYXRhc2V0LCBmYWNldCkge1xuICAvLyBEYXRhc2V0IC0+IERhdGFzZXRzIC0+IFNwb3RcbiAgdmFyIHNwb3QgPSBkYXRhc2V0LmNvbGxlY3Rpb24ucGFyZW50O1xuXG4gIGlmIChzcG90LmlzTG9ja2VkRG93bikge1xuICAgIHNwb3Quc29ja2V0LmVtaXQoJ3NldE1pbk1heCcsIHtcbiAgICAgIGRhdGFzZXRJZDogZGF0YXNldC5nZXRJZCgpLFxuICAgICAgZmFjZXRJZDogZmFjZXQuZ2V0SWQoKVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHNwb3Quc29ja2V0LmVtaXQoJ3NldE1pbk1heCcsIHtcbiAgICAgIGRhdGFzZXRJZDogZGF0YXNldC5nZXRJZCgpLFxuICAgICAgZGF0YXNldDogZGF0YXNldC50b0pTT04oKSxcbiAgICAgIGZhY2V0SWQ6IGZhY2V0LmdldElkKClcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIHNldENhdGVnb3JpZXMgZmluZHMgZmluZHMgYWxsIHZhbHVlcyBvbiBhbiBvcmRpbmFsIChjYXRlZ29yaWFsKSBheGlzXG4gKiBVcGRhdGVzIHRoZSBjYXRlZ29yaWFsVHJhbnNmb3JtIG9mIHRoZSBmYWNldFxuICpcbiAqIEBwYXJhbSB7RGF0YXNldH0gZGF0YXNldFxuICogQHBhcmFtIHtGYWNldH0gZmFjZXRcbiAqL1xuZnVuY3Rpb24gc2V0Q2F0ZWdvcmllcyAoZGF0YXNldCwgZmFjZXQpIHtcbiAgLy8gRGF0YXNldCAtPiBEYXRhc2V0cyAtPiBTcG90XG4gIHZhciBzcG90ID0gZGF0YXNldC5jb2xsZWN0aW9uLnBhcmVudDtcblxuICBmYWNldC5jYXRlZ29yaWFsVHJhbnNmb3JtLnJ1bGVzLnJlc2V0KCk7XG4gIGlmIChzcG90LmlzTG9ja2VkRG93bikge1xuICAgIHNwb3Quc29ja2V0LmVtaXQoJ3NldENhdGVnb3JpZXMnLCB7XG4gICAgICBkYXRhc2V0SWQ6IGRhdGFzZXQuZ2V0SWQoKSxcbiAgICAgIGZhY2V0SWQ6IGZhY2V0LmdldElkKClcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzcG90LnNvY2tldC5lbWl0KCdzZXRDYXRlZ29yaWVzJywge1xuICAgICAgZGF0YXNldElkOiBkYXRhc2V0LmdldElkKCksXG4gICAgICBkYXRhc2V0OiBkYXRhc2V0LnRvSlNPTigpLFxuICAgICAgZmFjZXRJZDogZmFjZXQuZ2V0SWQoKVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIDEwMCBwZXJjZW50aWxlcyAoaWUuIDEsMiwzLDQgZXRjLiksIGFuZCBpbml0aWFsaXplIHRoZSBgZmFjZXQuY29udGludW91c1RyYW5zZm9ybWBcbiAqXG4gKiBAcGFyYW0ge0RhdGFzZXR9IGRhdGFzZXRcbiAqIEBwYXJhbSB7RmFjZXR9IGZhY2V0XG4gKi9cbmZ1bmN0aW9uIHNldFBlcmNlbnRpbGVzIChkYXRhc2V0LCBmYWNldCkge1xuICAvLyBEYXRhc2V0IC0+IERhdGFzZXRzIC0+IFNwb3RcbiAgdmFyIHNwb3QgPSBkYXRhc2V0LmNvbGxlY3Rpb24ucGFyZW50O1xuXG4gIGlmIChzcG90LmlzTG9ja2VkRG93bikge1xuICAgIHNwb3Quc29ja2V0LmVtaXQoJ3NldFBlcmNlbnRpbGVzJywge1xuICAgICAgZGF0YXNldElkOiBkYXRhc2V0LmdldElkKCksXG4gICAgICBmYWNldElkOiBmYWNldC5nZXRJZCgpXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc3BvdC5zb2NrZXQuZW1pdCgnc2V0UGVyY2VudGlsZXMnLCB7XG4gICAgICBkYXRhc2V0SWQ6IGRhdGFzZXQuZ2V0SWQoKSxcbiAgICAgIGRhdGFzZXQ6IGRhdGFzZXQudG9KU09OKCksXG4gICAgICBmYWNldElkOiBmYWNldC5nZXRJZCgpXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBkYXRhIGZpbHRlciwgYW5kIGNvbnN0cnVjdCB0aGUgZ2V0RGF0YSBjYWxsYmFjayBmdW5jdGlvbiBvbiB0aGUgZmlsdGVyLlxuICogQHBhcmFtIHtEYXRhdmlld30gZGF0YXZpZXdcbiAqIEBwYXJhbSB7RmlsdGVyfSBmaWx0ZXJcbiAqL1xuZnVuY3Rpb24gaW5pdERhdGFGaWx0ZXIgKGRhdGF2aWV3LCBmaWx0ZXIpIHtcbiAgLy8gYXMgdGhlIFNRTCBzZXJ2ZXIgaW1wbGVtZW50YXRpb24gaXMgc3RhdGVsZXNzLCBub3RoaW5nIHRvIGRvIGhlcmVcbn1cblxuLyoqXG4gKiBUaGUgb3Bwb3NpdGUgb3IgaW5pdERhdGFGaWx0ZXIsIGl0IHNob3VsZCByZW1vdmUgdGhlIGZpbHRlciBhbmQgZGVhbGxvY2F0ZSBvdGhlciBjb25maWd1cmF0aW9uXG4gKiByZWxhdGVkIHRvIHRoZSBmaWx0ZXIuXG4gKiBAcGFyYW0ge0ZpbHRlcn0gZmlsdGVyXG4gKi9cbmZ1bmN0aW9uIHJlbGVhc2VEYXRhRmlsdGVyIChmaWx0ZXIpIHtcbiAgLy8gYXMgdGhlIFNRTCBzZXJ2ZXIgaW1wbGVtZW50YXRpb24gaXMgc3RhdGVsZXNzLCBub3RoaW5nIHRvIGRvIGhlcmVcbn1cblxuLyoqXG4gKiBDaGFuZ2UgdGhlIGZpbHRlciBwYXJhbWV0ZXJzIGZvciBhbiBpbml0aWFsaXplZCBmaWx0ZXJcbiAqIEBwYXJhbSB7RmlsdGVyfSBmaWx0ZXJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlRGF0YUZpbHRlciAoZmlsdGVyKSB7XG4gIC8vIGFzIHRoZSBTUUwgc2VydmVyIGltcGxlbWVudGF0aW9uIGlzIHN0YXRlbGVzcywgbm90aGluZyB0byBkbyBoZXJlXG59XG5cbi8qKlxuICogR2V0IGRhdGEgZm9yIGV2ZXJ5IGZpbHRlciwgYW5kIHRyaWdnZXIgYSAnbmV3RGF0YScgZXZlbnRcbiAqXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkYXRhdmlldyB3aGVuIGFsbCBkYXRhIGFuZCBtZXRhZGF0YSBoYXMgYmVlbiB1cGRhdGVkXG4gKlxuICogQHBhcmFtIHtEYXRhdmlld30gZGF0YXZpZXdcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhdmlldykge1xuICB2YXIgc3BvdCA9IGRhdGF2aWV3LnBhcmVudDtcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmIChzcG90LmlzTG9ja2VkRG93bikge1xuICAgICAgc3BvdC5zb2NrZXQuZW1pdCgnZ2V0RGF0YScsIHtcbiAgICAgICAgZGF0YXZpZXc6IGRhdGF2aWV3LnRvSlNPTigpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3BvdC5zb2NrZXQuZW1pdCgnZ2V0RGF0YScsIHtcbiAgICAgICAgZGF0YXNldHM6IHNwb3QuY2FjaGVkRGF0YXNldHMsXG4gICAgICAgIGRhdGF2aWV3OiBkYXRhdmlldy50b0pTT04oKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGF0YXZpZXcub25jZSgnbmV3TWV0YURhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXNvbHZlKGRhdGF2aWV3KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcml2ZXJUeXBlOiAnc2VydmVyJyxcbiAgc2Nhbjogc2NhbixcbiAgc2V0TWluTWF4OiBzZXRNaW5NYXgsXG4gIHNldENhdGVnb3JpZXM6IHNldENhdGVnb3JpZXMsXG4gIHNldFBlcmNlbnRpbGVzOiBzZXRQZXJjZW50aWxlcyxcbiAgaW5pdERhdGFGaWx0ZXI6IGluaXREYXRhRmlsdGVyLFxuICByZWxlYXNlRGF0YUZpbHRlcjogcmVsZWFzZURhdGFGaWx0ZXIsXG4gIHVwZGF0ZURhdGFGaWx0ZXI6IHVwZGF0ZURhdGFGaWx0ZXIsXG4gIGdldERhdGE6IGdldERhdGFcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///072d\n")},"09c5":function(module,exports,__webpack_require__){eval("/**\n * A single control point for a continuous transform\n *\n * @class ControlPoint\n */\nvar BaseModel = __webpack_require__(/*! ../util/base */ \"3902\");\n\n// Data structure for mapping categorial (and textual) data on groups\nmodule.exports = BaseModel.extend({\n  props: {\n    /**\n     * Value\n     * @type {number}\n     * @memberof! ContinuousRule\n     */\n    x: 'number',\n\n    /**\n     * Transformed value\n     * @type {number}\n     * @memberof! ContinuousRule\n     */\n    fx: 'number'\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMDljNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmFjZXQvY29udHJvbC1wb2ludC5qcz82OTJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBzaW5nbGUgY29udHJvbCBwb2ludCBmb3IgYSBjb250aW51b3VzIHRyYW5zZm9ybVxuICpcbiAqIEBjbGFzcyBDb250cm9sUG9pbnRcbiAqL1xudmFyIEJhc2VNb2RlbCA9IHJlcXVpcmUoJy4uL3V0aWwvYmFzZScpO1xuXG4vLyBEYXRhIHN0cnVjdHVyZSBmb3IgbWFwcGluZyBjYXRlZ29yaWFsIChhbmQgdGV4dHVhbCkgZGF0YSBvbiBncm91cHNcbm1vZHVsZS5leHBvcnRzID0gQmFzZU1vZGVsLmV4dGVuZCh7XG4gIHByb3BzOiB7XG4gICAgLyoqXG4gICAgICogVmFsdWVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiEgQ29udGludW91c1J1bGVcbiAgICAgKi9cbiAgICB4OiAnbnVtYmVyJyxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybWVkIHZhbHVlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YhIENvbnRpbnVvdXNSdWxlXG4gICAgICovXG4gICAgZng6ICdudW1iZXInXG4gIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///09c5\n")},"0b10":function(module,exports){eval("/**\n * Helpers.\n */\n\nvar s = 1000\nvar m = s * 60\nvar h = m * 60\nvar d = h * 24\nvar y = d * 365.25\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {}\n  var type = typeof val\n  if (type === 'string' && val.length > 0) {\n    return parse(val)\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ?\n\t\t\tfmtLong(val) :\n\t\t\tfmtShort(val)\n  }\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))\n}\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str)\n  if (str.length > 10000) {\n    return\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)\n  if (!match) {\n    return\n  }\n  var n = parseFloat(match[1])\n  var type = (match[2] || 'ms').toLowerCase()\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n\n    default:\n      return undefined\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd'\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h'\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm'\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's'\n  }\n  return ms + 'ms'\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms'\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMGIxMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/YjZlOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwXG52YXIgbSA9IHMgKiA2MFxudmFyIGggPSBtICogNjBcbnZhciBkID0gaCAqIDI0XG52YXIgeSA9IGQgKiAzNjUuMjVcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWxcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbClcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgP1xuXHRcdFx0Zm10TG9uZyh2YWwpIDpcblx0XHRcdGZtdFNob3J0KHZhbClcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArIEpTT04uc3RyaW5naWZ5KHZhbCkpXG59XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKVxuICBpZiAoc3RyLmxlbmd0aCA+IDEwMDAwKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pXG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKClcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZFxuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaFxuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbVxuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogc1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCdcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCdcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSdcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncydcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnXG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnXG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWVcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnXG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0b10\n")},"0d97":function(module,exports,__webpack_require__){eval("/**\n * Module dependencies.\n */\n\nvar parser = __webpack_require__(/*! engine.io-parser */ \"aa6c\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"ee5b\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = Transport;\n\n/**\n * Transport abstract constructor.\n *\n * @param {Object} options.\n * @api private\n */\n\nfunction Transport (opts) {\n  this.path = opts.path;\n  this.hostname = opts.hostname;\n  this.port = opts.port;\n  this.secure = opts.secure;\n  this.query = opts.query;\n  this.timestampParam = opts.timestampParam;\n  this.timestampRequests = opts.timestampRequests;\n  this.readyState = '';\n  this.agent = opts.agent || false;\n  this.socket = opts.socket;\n  this.enablesXDR = opts.enablesXDR;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n  this.forceNode = opts.forceNode;\n\n  // other options for Node.js client\n  this.extraHeaders = opts.extraHeaders;\n  this.localAddress = opts.localAddress;\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Transport.prototype);\n\n/**\n * Emits an error.\n *\n * @param {String} str\n * @return {Transport} for chaining\n * @api public\n */\n\nTransport.prototype.onError = function (msg, desc) {\n  var err = new Error(msg);\n  err.type = 'TransportError';\n  err.description = desc;\n  this.emit('error', err);\n  return this;\n};\n\n/**\n * Opens the transport.\n *\n * @api public\n */\n\nTransport.prototype.open = function () {\n  if ('closed' === this.readyState || '' === this.readyState) {\n    this.readyState = 'opening';\n    this.doOpen();\n  }\n\n  return this;\n};\n\n/**\n * Closes the transport.\n *\n * @api private\n */\n\nTransport.prototype.close = function () {\n  if ('opening' === this.readyState || 'open' === this.readyState) {\n    this.doClose();\n    this.onClose();\n  }\n\n  return this;\n};\n\n/**\n * Sends multiple packets.\n *\n * @param {Array} packets\n * @api private\n */\n\nTransport.prototype.send = function (packets) {\n  if ('open' === this.readyState) {\n    this.write(packets);\n  } else {\n    throw new Error('Transport not open');\n  }\n};\n\n/**\n * Called upon open\n *\n * @api private\n */\n\nTransport.prototype.onOpen = function () {\n  this.readyState = 'open';\n  this.writable = true;\n  this.emit('open');\n};\n\n/**\n * Called with data.\n *\n * @param {String} data\n * @api private\n */\n\nTransport.prototype.onData = function (data) {\n  var packet = parser.decodePacket(data, this.socket.binaryType);\n  this.onPacket(packet);\n};\n\n/**\n * Called with a decoded packet.\n */\n\nTransport.prototype.onPacket = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon close.\n *\n * @api private\n */\n\nTransport.prototype.onClose = function () {\n  this.readyState = 'closed';\n  this.emit('close');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMGQ5Ny5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzPzMxMmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnQ7XG5cbi8qKlxuICogVHJhbnNwb3J0IGFic3RyYWN0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gVHJhbnNwb3J0IChvcHRzKSB7XG4gIHRoaXMucGF0aCA9IG9wdHMucGF0aDtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydDtcbiAgdGhpcy5zZWN1cmUgPSBvcHRzLnNlY3VyZTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuICB0aGlzLmZvcmNlTm9kZSA9IG9wdHMuZm9yY2VOb2RlO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gIHRoaXMubG9jYWxBZGRyZXNzID0gb3B0cy5sb2NhbEFkZHJlc3M7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFRyYW5zcG9ydC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEVtaXRzIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChtc2csIGRlc2MpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG4gIGVyci5kZXNjcmlwdGlvbiA9IGRlc2M7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3BlbnMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgICB0aGlzLmRvT3BlbigpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgIHRoaXMub25DbG9zZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy53cml0ZShwYWNrZXRzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBub3Qgb3BlbicpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIG9wZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIHBhY2tldCA9IHBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSk7XG4gIHRoaXMub25QYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggYSBkZWNvZGVkIHBhY2tldC5cbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0d97\n")},"108d":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Module requirements.\n */\n\nvar XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ \"86e3\");\nvar Polling = __webpack_require__(/*! ./polling */ \"181d\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"ee5b\");\nvar inherit = __webpack_require__(/*! component-inherit */ \"42bf\");\nvar debug = __webpack_require__(/*! debug */ \"433b\")('engine.io-client:polling-xhr');\n\n/**\n * Module exports.\n */\n\nmodule.exports = XHR;\nmodule.exports.Request = Request;\n\n/**\n * Empty function\n */\n\nfunction empty () {}\n\n/**\n * XHR Polling constructor.\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction XHR (opts) {\n  Polling.call(this, opts);\n  this.requestTimeout = opts.requestTimeout;\n\n  if (global.location) {\n    var isSSL = 'https:' === location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    this.xd = opts.hostname !== global.location.hostname ||\n      port !== opts.port;\n    this.xs = opts.secure !== isSSL;\n  } else {\n    this.extraHeaders = opts.extraHeaders;\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(XHR, Polling);\n\n/**\n * XHR supports binary\n */\n\nXHR.prototype.supportsBinary = true;\n\n/**\n * Creates a request.\n *\n * @param {String} method\n * @api private\n */\n\nXHR.prototype.request = function (opts) {\n  opts = opts || {};\n  opts.uri = this.uri();\n  opts.xd = this.xd;\n  opts.xs = this.xs;\n  opts.agent = this.agent || false;\n  opts.supportsBinary = this.supportsBinary;\n  opts.enablesXDR = this.enablesXDR;\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n  opts.requestTimeout = this.requestTimeout;\n\n  // other options for Node.js client\n  opts.extraHeaders = this.extraHeaders;\n\n  return new Request(opts);\n};\n\n/**\n * Sends data.\n *\n * @param {String} data to send.\n * @param {Function} called upon flush.\n * @api private\n */\n\nXHR.prototype.doWrite = function (data, fn) {\n  var isBinary = typeof data !== 'string' && data !== undefined;\n  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });\n  var self = this;\n  req.on('success', fn);\n  req.on('error', function (err) {\n    self.onError('xhr post error', err);\n  });\n  this.sendXhr = req;\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nXHR.prototype.doPoll = function () {\n  debug('xhr poll');\n  var req = this.request();\n  var self = this;\n  req.on('data', function (data) {\n    self.onData(data);\n  });\n  req.on('error', function (err) {\n    self.onError('xhr poll error', err);\n  });\n  this.pollXhr = req;\n};\n\n/**\n * Request constructor\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Request (opts) {\n  this.method = opts.method || 'GET';\n  this.uri = opts.uri;\n  this.xd = !!opts.xd;\n  this.xs = !!opts.xs;\n  this.async = false !== opts.async;\n  this.data = undefined !== opts.data ? opts.data : null;\n  this.agent = opts.agent;\n  this.isBinary = opts.isBinary;\n  this.supportsBinary = opts.supportsBinary;\n  this.enablesXDR = opts.enablesXDR;\n  this.requestTimeout = opts.requestTimeout;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n\n  // other options for Node.js client\n  this.extraHeaders = opts.extraHeaders;\n\n  this.create();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Creates the XHR object and sends the request.\n *\n * @api private\n */\n\nRequest.prototype.create = function () {\n  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n\n  var xhr = this.xhr = new XMLHttpRequest(opts);\n  var self = this;\n\n  try {\n    debug('xhr open %s: %s', this.method, this.uri);\n    xhr.open(this.method, this.uri, this.async);\n    try {\n      if (this.extraHeaders) {\n        xhr.setDisableHeaderCheck(true);\n        for (var i in this.extraHeaders) {\n          if (this.extraHeaders.hasOwnProperty(i)) {\n            xhr.setRequestHeader(i, this.extraHeaders[i]);\n          }\n        }\n      }\n    } catch (e) {}\n    if (this.supportsBinary) {\n      // This has to be done after open because Firefox is stupid\n      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension\n      xhr.responseType = 'arraybuffer';\n    }\n\n    if ('POST' === this.method) {\n      try {\n        if (this.isBinary) {\n          xhr.setRequestHeader('Content-type', 'application/octet-stream');\n        } else {\n          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n        }\n      } catch (e) {}\n    }\n\n    try {\n      xhr.setRequestHeader('Accept', '*/*');\n    } catch (e) {}\n\n    // ie6 check\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = true;\n    }\n\n    if (this.requestTimeout) {\n      xhr.timeout = this.requestTimeout;\n    }\n\n    if (this.hasXDR()) {\n      xhr.onload = function () {\n        self.onLoad();\n      };\n      xhr.onerror = function () {\n        self.onError(xhr.responseText);\n      };\n    } else {\n      xhr.onreadystatechange = function () {\n        if (4 !== xhr.readyState) return;\n        if (200 === xhr.status || 1223 === xhr.status) {\n          self.onLoad();\n        } else {\n          // make sure the `error` event handler that's user-set\n          // does not throw in the same tick and gets caught here\n          setTimeout(function () {\n            self.onError(xhr.status);\n          }, 0);\n        }\n      };\n    }\n\n    debug('xhr data %s', this.data);\n    xhr.send(this.data);\n  } catch (e) {\n    // Need to defer since .create() is called directly fhrom the constructor\n    // and thus the 'error' event can only be only bound *after* this exception\n    // occurs.  Therefore, also, we cannot throw here at all.\n    setTimeout(function () {\n      self.onError(e);\n    }, 0);\n    return;\n  }\n\n  if (global.document) {\n    this.index = Request.requestsCount++;\n    Request.requests[this.index] = this;\n  }\n};\n\n/**\n * Called upon successful response.\n *\n * @api private\n */\n\nRequest.prototype.onSuccess = function () {\n  this.emit('success');\n  this.cleanup();\n};\n\n/**\n * Called if we have data.\n *\n * @api private\n */\n\nRequest.prototype.onData = function (data) {\n  this.emit('data', data);\n  this.onSuccess();\n};\n\n/**\n * Called upon error.\n *\n * @api private\n */\n\nRequest.prototype.onError = function (err) {\n  this.emit('error', err);\n  this.cleanup(true);\n};\n\n/**\n * Cleans up house.\n *\n * @api private\n */\n\nRequest.prototype.cleanup = function (fromError) {\n  if ('undefined' === typeof this.xhr || null === this.xhr) {\n    return;\n  }\n  // xmlhttprequest\n  if (this.hasXDR()) {\n    this.xhr.onload = this.xhr.onerror = empty;\n  } else {\n    this.xhr.onreadystatechange = empty;\n  }\n\n  if (fromError) {\n    try {\n      this.xhr.abort();\n    } catch (e) {}\n  }\n\n  if (global.document) {\n    delete Request.requests[this.index];\n  }\n\n  this.xhr = null;\n};\n\n/**\n * Called upon load.\n *\n * @api private\n */\n\nRequest.prototype.onLoad = function () {\n  var data;\n  try {\n    var contentType;\n    try {\n      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];\n    } catch (e) {}\n    if (contentType === 'application/octet-stream') {\n      data = this.xhr.response || this.xhr.responseText;\n    } else {\n      if (!this.supportsBinary) {\n        data = this.xhr.responseText;\n      } else {\n        try {\n          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));\n        } catch (e) {\n          var ui8Arr = new Uint8Array(this.xhr.response);\n          var dataArray = [];\n          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {\n            dataArray.push(ui8Arr[idx]);\n          }\n\n          data = String.fromCharCode.apply(null, dataArray);\n        }\n      }\n    }\n  } catch (e) {\n    this.onError(e);\n  }\n  if (null != data) {\n    this.onData(data);\n  }\n};\n\n/**\n * Check if it has XDomainRequest.\n *\n * @api private\n */\n\nRequest.prototype.hasXDR = function () {\n  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;\n};\n\n/**\n * Aborts the request.\n *\n * @api public\n */\n\nRequest.prototype.abort = function () {\n  this.cleanup();\n};\n\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\n\nRequest.requestsCount = 0;\nRequest.requests = {};\n\nif (global.document) {\n  if (global.attachEvent) {\n    global.attachEvent('onunload', unloadHandler);\n  } else if (global.addEventListener) {\n    global.addEventListener('beforeunload', unloadHandler, false);\n  }\n}\n\nfunction unloadHandler () {\n  for (var i in Request.requests) {\n    if (Request.requests.hasOwnProperty(i)) {\n      Request.requests[i].abort();\n    }\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"698d\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA4ZC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qcz9mYmY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcteGhyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBYSFI7XG5tb2R1bGUuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBFbXB0eSBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHt9XG5cbi8qKlxuICogWEhSIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gWEhSIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcbiAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IG9wdHMucmVxdWVzdFRpbWVvdXQ7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB0aGlzLnhkID0gb3B0cy5ob3N0bmFtZSAhPT0gZ2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lIHx8XG4gICAgICBwb3J0ICE9PSBvcHRzLnBvcnQ7XG4gICAgdGhpcy54cyA9IG9wdHMuc2VjdXJlICE9PSBpc1NTTDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoWEhSLCBQb2xsaW5nKTtcblxuLyoqXG4gKiBYSFIgc3VwcG9ydHMgYmluYXJ5XG4gKi9cblxuWEhSLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMudXJpID0gdGhpcy51cmkoKTtcbiAgb3B0cy54ZCA9IHRoaXMueGQ7XG4gIG9wdHMueHMgPSB0aGlzLnhzO1xuICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudCB8fCBmYWxzZTtcbiAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG4gIG9wdHMuZW5hYmxlc1hEUiA9IHRoaXMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIG9wdHMucmVxdWVzdFRpbWVvdXQgPSB0aGlzLnJlcXVlc3RUaW1lb3V0O1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMuZXh0cmFIZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG5cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KG9wdHMpO1xufTtcblxuLyoqXG4gKiBTZW5kcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgZGF0YSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnUE9TVCcsIGRhdGE6IGRhdGEsIGlzQmluYXJ5OiBpc0JpbmFyeSB9KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ3N1Y2Nlc3MnLCBmbik7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9zdCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnNlbmRYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCd4aHIgcG9sbCcpO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgfSk7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnBvbGxYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0IChvcHRzKSB7XG4gIHRoaXMubWV0aG9kID0gb3B0cy5tZXRob2QgfHwgJ0dFVCc7XG4gIHRoaXMudXJpID0gb3B0cy51cmk7XG4gIHRoaXMueGQgPSAhIW9wdHMueGQ7XG4gIHRoaXMueHMgPSAhIW9wdHMueHM7XG4gIHRoaXMuYXN5bmMgPSBmYWxzZSAhPT0gb3B0cy5hc3luYztcbiAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9PSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudDtcbiAgdGhpcy5pc0JpbmFyeSA9IG9wdHMuaXNCaW5hcnk7XG4gIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBvcHRzLnN1cHBvcnRzQmluYXJ5O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIHRoaXMuY3JlYXRlKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRzID0geyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogdGhpcy54ZCwgeHNjaGVtZTogdGhpcy54cywgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgZGVidWcoJ3hociBvcGVuICVzOiAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVyaSk7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIHRoaXMuZXh0cmFIZWFkZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmICh0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAvLyBUaGlzIGhhcyB0byBiZSBkb25lIGFmdGVyIG9wZW4gYmVjYXVzZSBGaXJlZm94IGlzIHN0dXBpZFxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzIxNjkwMy9nZXQtYmluYXJ5LWRhdGEtd2l0aC14bWxodHRwcmVxdWVzdC1pbi1hLWZpcmVmb3gtZXh0ZW5zaW9uXG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICB9XG5cbiAgICBpZiAoJ1BPU1QnID09PSB0aGlzLm1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnKi8qJyk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIC8vIGllNiBjaGVja1xuICAgIGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlcXVlc3RUaW1lb3V0KSB7XG4gICAgICB4aHIudGltZW91dCA9IHRoaXMucmVxdWVzdFRpbWVvdXQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYub25FcnJvcih4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICg0ICE9PSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICBpZiAoMjAwID09PSB4aHIuc3RhdHVzIHx8IDEyMjMgPT09IHhoci5zdGF0dXMpIHtcbiAgICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBkZWJ1ZygneGhyIGRhdGEgJXMnLCB0aGlzLmRhdGEpO1xuICAgIHhoci5zZW5kKHRoaXMuZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBOZWVkIHRvIGRlZmVyIHNpbmNlIC5jcmVhdGUoKSBpcyBjYWxsZWQgZGlyZWN0bHkgZmhyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgLy8gYW5kIHRodXMgdGhlICdlcnJvcicgZXZlbnQgY2FuIG9ubHkgYmUgb25seSBib3VuZCAqYWZ0ZXIqIHRoaXMgZXhjZXB0aW9uXG4gICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdzdWNjZXNzJyk7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgd2UgaGF2ZSBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpO1xuICB0aGlzLm9uU3VjY2VzcygpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5jbGVhbnVwKHRydWUpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgaG91c2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uIChmcm9tRXJyb3IpIHtcbiAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgdGhpcy54aHIgfHwgbnVsbCA9PT0gdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8geG1saHR0cHJlcXVlc3RcbiAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG4gIH1cblxuICBpZiAoZnJvbUVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuXG4gIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICBkZWxldGUgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XTtcbiAgfVxuXG4gIHRoaXMueGhyID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gbG9hZC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkYXRhO1xuICB0cnkge1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB0cnkge1xuICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykuc3BsaXQoJzsnKVswXTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZSB8fCB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSh0aGlzLnhoci5yZXNwb25zZSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdmFyIHVpOEFyciA9IG5ldyBVaW50OEFycmF5KHRoaXMueGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICB2YXIgZGF0YUFycmF5ID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaWR4ID0gMCwgbGVuZ3RoID0gdWk4QXJyLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgZGF0YUFycmF5LnB1c2godWk4QXJyW2lkeF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGRhdGFBcnJheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLm9uRXJyb3IoZSk7XG4gIH1cbiAgaWYgKG51bGwgIT0gZGF0YSkge1xuICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGl0IGhhcyBYRG9tYWluUmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5oYXNYRFIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiAhdGhpcy54cyAmJiB0aGlzLmVuYWJsZXNYRFI7XG59O1xuXG4vKipcbiAqIEFib3J0cyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQWJvcnRzIHBlbmRpbmcgcmVxdWVzdHMgd2hlbiB1bmxvYWRpbmcgdGhlIHdpbmRvdy4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudFxuICogbWVtb3J5IGxlYWtzIChlLmcuIHdoZW4gdXNpbmcgSUUpIGFuZCB0byBlbnN1cmUgdGhhdCBubyBzcHVyaW91cyBlcnJvciBpc1xuICogZW1pdHRlZC5cbiAqL1xuXG5SZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuUmVxdWVzdC5yZXF1ZXN0cyA9IHt9O1xuXG5pZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gIGlmIChnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29udW5sb2FkJywgdW5sb2FkSGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVubG9hZEhhbmRsZXIgKCkge1xuICBmb3IgKHZhciBpIGluIFJlcXVlc3QucmVxdWVzdHMpIHtcbiAgICBpZiAoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuICAgIH1cbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///108d\n")},1278:function(module,exports,__webpack_require__){eval("/**\n * Selection\n * @module client/util-selection\n */\nvar misval = __webpack_require__(/*! ./misval */ \"bff6\");\nvar moment = __webpack_require__(/*! moment-timezone */ \"6c9d\");\n\n/*\n * Set a categorial 1D filter function\n * @param {Partition} partition\n */\nfunction filterFunctionCategorial1D (partition) {\n  var haystack = {};\n\n  if (!partition.selected || !partition.selected.length) {\n    partition.groups.forEach(function (group) {\n      haystack[group.value] = true;\n    });\n  } else {\n    partition.selected.forEach(function (h) {\n      haystack[h] = true;\n    });\n  }\n\n  return function (d) {\n    var needle = d;\n    if (!(needle instanceof Array)) {\n      needle = [d];\n    }\n\n    var selected = false;\n    needle.forEach(function (s) {\n      selected = selected | haystack[s];\n    });\n    return !!selected;\n  };\n}\n\n/*\n * Set a text filter function\n * @param {Partition} partition\n */\nfunction filterFunctionText (partition) {\n  var haystack = {};\n\n  // nothing selected, so all selected\n  if (partition.selected.length === 0) {\n    return function () {\n      return true;\n    };\n  }\n\n  partition.selected.forEach(function (h) {\n    haystack[h] = true;\n  });\n\n  return function (d) {\n    var needle = d;\n    if (!(needle instanceof Array)) {\n      needle = [d];\n    }\n\n    var selected = false;\n    needle.forEach(function (s) {\n      selected = selected | haystack[s];\n    });\n    return !!selected;\n  };\n}\n\n/*\n * Set a continuous 1D filter function\n * @param {Partition} partition\n */\nfunction filterFunctionContinuous1D (partition) {\n  var edge = partition.maxval;\n  var min;\n  var max;\n\n  if (!partition.selected || !partition.selected.length) {\n    min = partition.minval;\n    max = partition.maxval;\n    return function (d) {\n      return ((d >= min && d <= max) && (d !== misval));\n    };\n  } else {\n    min = partition.selected[0];\n    max = partition.selected[1];\n    return function (d) {\n      return ((d >= min && d < max) || ((d === edge) && (max === edge))) && (d !== misval);\n    };\n  }\n}\n\n/*\n * Set a continuous 1D filter function on a datetime dimension\n * @param {Partition} partition\n */\nfunction filterFunctionDatetime1D (partition) {\n  var edge = moment(partition.maxval);\n  var min;\n  var max;\n\n  if (!partition.selected || !partition.selected.length) {\n    min = moment(partition.minval);\n    max = moment(partition.maxval);\n\n    return function (d) {\n      var m = moment(d);\n      return (m !== misval) && !m.isBefore(min) && !m.isAfter(max);\n    };\n  } else {\n    min = moment(partition.selected[0]);\n    max = moment(partition.selected[1]);\n    return function (d) {\n      var m = moment(d);\n      return (m !== misval) && !min.isAfter(m) && (m.isBefore(max) || (max.isSame(edge) && max.isSame(m)));\n    };\n  }\n}\n\n/*\n * Set a continuous 1D filter function on a duration dimension\n * @param {Partition} partition\n */\nfunction filterFunctionDuration1D (partition) {\n  var edge = partition.maxval;\n  var min;\n  var max;\n\n  if (!partition.selected || !partition.selected.length) {\n    min = partition.minval;\n    max = partition.maxval;\n\n    return function (d) {\n      if (d === misval) {\n        return false;\n      }\n      var m = moment.duration(d);\n      return moment.isDuration(m) && m >= min && m <= max;\n    };\n  } else {\n    min = moment.duration(partition.selected[0]);\n    max = moment.duration(partition.selected[1]);\n    return function (d) {\n      if (d === misval) {\n        return false;\n      }\n      var m = moment.duration(d);\n      return moment.isDuration(m) && m >= min && (m < max || (m <= max && max >= edge));\n    };\n  }\n}\n\n/**\n * A filter function based for a single partition\n * @function\n * @returns {boolean} selected True if the datapoint is currently selected\n * @param {Partition} partition\n * @param {Object} datapoint\n * @memberof! Selection\n */\nfunction filterFunction (partition) {\n  if (partition.isCategorial || partition.isConstant) {\n    return filterFunctionCategorial1D(partition);\n  } else if (partition.isContinuous) {\n    return filterFunctionContinuous1D(partition);\n  } else if (partition.isDatetime) {\n    return filterFunctionDatetime1D(partition);\n  } else if (partition.isDuration) {\n    return filterFunctionDuration1D(partition);\n  } else if (partition.isText) {\n    return filterFunctionText(partition);\n  } else {\n    console.error('Cannot make filterfunction for partition', partition);\n  }\n}\n\n/*\n * @param {Group} group - The group to add or remove from the filter\n */\nfunction updateCategorial1D (partition, group) {\n  var selected = partition.selected;\n\n  if (selected.length === 0) {\n    // 1. none selected:\n    selected.push(group.value);\n  } else if (selected.length === 1) {\n    if (selected[0] === group.value) {\n      // 2. one selected and the group is the same:\n      selected.splice(0, selected.length);\n      partition.groups.forEach(function (g) {\n        if (g.value !== group.value) {\n          selected.push(g.value);\n        }\n      });\n    } else {\n      // 3. one selected and the group is different:\n      selected.push(group.value);\n    }\n  } else {\n    var i;\n    i = selected.indexOf(group.value);\n    if (i > -1) {\n      // 4. more than one selected and the group is in the selection:\n      selected.splice(i, 1);\n    } else {\n      // 5. more than one selected and the group is not in the selection:\n      selected.push(group.value);\n    }\n  }\n\n  // after add: if filters == groups, reset and dont filter\n  if (selected.length === partition.groups.length) {\n    selected.splice(0, selected.length);\n  }\n}\n\n/*\n * @param {Group} group - The group to add or remove from the filter\n */\nfunction updateText (partition, group) {\n  var selected = partition.selected;\n\n  var i;\n  i = selected.indexOf(group.value);\n  if (i > -1) {\n    // 1. in the selection, remove it\n    selected.splice(i, 1);\n  } else {\n    // 2. not in the selection, add it\n    selected.push(group.value);\n  }\n}\n\n/*\n * @param {Group} group - The group to add or remove from the filter\n */\nfunction updateContinuous1D (partition, group) {\n  var selected = partition.selected;\n\n  if (selected.length === 0) {\n    // nothing selected, start a range\n    selected[0] = group.min;\n    selected[1] = group.max;\n  } else if (group.min >= selected[1]) {\n    // clicked outside to the rigth of selection\n    selected[1] = group.max;\n  } else if (group.max <= selected[0]) {\n    // clicked outside to the left of selection\n    selected[0] = group.min;\n  } else {\n    // clicked inside selection\n    var d1, d2;\n    if (partition.groupLog) {\n      d1 = Math.abs(Math.log(selected[0]) - Math.log(group.min));\n      d2 = Math.abs(Math.log(selected[1]) - Math.log(group.max));\n    } else {\n      d1 = Math.abs(selected[0] - group.min);\n      d2 = Math.abs(selected[1] - group.max);\n    }\n    if (d1 < d2) {\n      selected[0] = group.min;\n    } else {\n      selected[1] = group.max;\n    }\n  }\n}\n\n/*\n * @param {Group} group - The group to add or remove from the filter\n */\nfunction updateDatetime1D (partition, group) {\n  var selected = partition.selected;\n\n  if (!selected || selected.length === 0) {\n    // nothing selected, start a range\n    selected[0] = group.min.toISOString();\n    selected[1] = group.max.toISOString();\n    return;\n  }\n\n  var selectionStart = moment(selected[0]);\n  var selectionEnd = moment(selected[1]);\n\n  if (!group.min.isBefore(selectionEnd)) {\n    // clicked outside to the rigth of selection\n    selected[1] = group.max.toISOString();\n  } else if (!group.max.isAfter(selectionStart)) {\n    // clicked outside to the left of selection\n    selected[0] = group.min.toISOString();\n  } else {\n    // clicked inside selection\n    var d1, d2;\n    d1 = Math.abs(selectionStart.diff(group.min));\n    d2 = Math.abs(selectionEnd.diff(group.max));\n\n    if (d1 < d2) {\n      selected[0] = group.max.toISOString();\n    } else {\n      selected[1] = group.min.toISOString();\n    }\n  }\n}\n\n/*\n * @param {Group} group - The group to add or remove from the filter\n */\nfunction updateDuration1D (partition, group) {\n  var selected = partition.selected;\n\n  if (selected.length === 0) {\n    // nothing selected, start a range\n    selected[0] = group.min.toISOString();\n    selected[1] = group.max.toISOString();\n    return;\n  }\n\n  var selectionStart = moment.duration(selected[0]);\n  var selectionEnd = moment.duration(selected[1]);\n\n  if (group.min >= selectionEnd) {\n    // clicked outside to the rigth of selection\n    selected[1] = group.max.toISOString();\n  } else if (group.max <= selectionStart) {\n    // clicked outside to the left of selection\n    selected[0] = group.min.toISOString();\n  } else {\n    // clicked inside selection\n    var d1, d2;\n    d1 = Math.abs(selectionStart - group.min);\n    d2 = Math.abs(selectionEnd - group.max);\n\n    if (d1 < d2) {\n      selected[0] = group.max.toISOString();\n    } else {\n      selected[1] = group.min.toISOString();\n    }\n  }\n}\n\n/**\n * Update the selection with a given group or interval\n * or, if no group is given, clear the selection.\n *\n * For categorial selections the following rules are used:\n * 1. none selected:\n *    add the group to the selection\n * 2. one selected and the group is the same:\n *    invert the selection\n * 3. one selected and the group is different:\n *    add the group to the selection\n * 4. more than one selected and the group is in the selection:\n *    remove the group from the selection\n * 5. more than one selected and the group is not in the selection:\n *    add the group to the selection\n *\n * For continuous selections the following rules are used:\n * 1. no range selected\n *    set the range equal to that of the group\n * 2. a range selected and the group is outside the selection:\n *    extend the selection to include the group\n * 3. a range selected and the group is inside the selection:\n *    set the endpoint closest to the group to that of the group\n *\n * @function\n * @param {Partition} Partition to update\n * @param {(string|number[])} Group or interval\n */\nfunction updateSelection (partition, group) {\n  if (!group) {\n    // Clear the selection (ie. all points are selected)\n    partition.selected.splice(0, partition.selected.length);\n  } else {\n    // Update the selection\n    if (partition.type === 'categorial' || partition.type === 'constant') {\n      updateCategorial1D(partition, group);\n    } else if (partition.type === 'continuous') {\n      updateContinuous1D(partition, group);\n    } else if (partition.type === 'datetime') {\n      updateDatetime1D(partition, group);\n    } else if (partition.type === 'duration') {\n      updateDuration1D(partition, group);\n    } else if (partition.type === 'text') {\n      updateText(partition, group);\n    } else {\n      console.error('Cannot update selection', partition.type);\n    }\n  }\n}\n\nmodule.exports = {\n  filterFunction: filterFunction,\n  updateSelection: updateSelection\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI3OC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvdXRpbC9zZWxlY3Rpb24uanM/NGY5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNlbGVjdGlvblxuICogQG1vZHVsZSBjbGllbnQvdXRpbC1zZWxlY3Rpb25cbiAqL1xudmFyIG1pc3ZhbCA9IHJlcXVpcmUoJy4vbWlzdmFsJyk7XG52YXIgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50LXRpbWV6b25lJyk7XG5cbi8qXG4gKiBTZXQgYSBjYXRlZ29yaWFsIDFEIGZpbHRlciBmdW5jdGlvblxuICogQHBhcmFtIHtQYXJ0aXRpb259IHBhcnRpdGlvblxuICovXG5mdW5jdGlvbiBmaWx0ZXJGdW5jdGlvbkNhdGVnb3JpYWwxRCAocGFydGl0aW9uKSB7XG4gIHZhciBoYXlzdGFjayA9IHt9O1xuXG4gIGlmICghcGFydGl0aW9uLnNlbGVjdGVkIHx8ICFwYXJ0aXRpb24uc2VsZWN0ZWQubGVuZ3RoKSB7XG4gICAgcGFydGl0aW9uLmdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgaGF5c3RhY2tbZ3JvdXAudmFsdWVdID0gdHJ1ZTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0aXRpb24uc2VsZWN0ZWQuZm9yRWFjaChmdW5jdGlvbiAoaCkge1xuICAgICAgaGF5c3RhY2tbaF0gPSB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgdmFyIG5lZWRsZSA9IGQ7XG4gICAgaWYgKCEobmVlZGxlIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICBuZWVkbGUgPSBbZF07XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgbmVlZGxlLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgIHNlbGVjdGVkID0gc2VsZWN0ZWQgfCBoYXlzdGFja1tzXTtcbiAgICB9KTtcbiAgICByZXR1cm4gISFzZWxlY3RlZDtcbiAgfTtcbn1cblxuLypcbiAqIFNldCBhIHRleHQgZmlsdGVyIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1BhcnRpdGlvbn0gcGFydGl0aW9uXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckZ1bmN0aW9uVGV4dCAocGFydGl0aW9uKSB7XG4gIHZhciBoYXlzdGFjayA9IHt9O1xuXG4gIC8vIG5vdGhpbmcgc2VsZWN0ZWQsIHNvIGFsbCBzZWxlY3RlZFxuICBpZiAocGFydGl0aW9uLnNlbGVjdGVkLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgcGFydGl0aW9uLnNlbGVjdGVkLmZvckVhY2goZnVuY3Rpb24gKGgpIHtcbiAgICBoYXlzdGFja1toXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgIHZhciBuZWVkbGUgPSBkO1xuICAgIGlmICghKG5lZWRsZSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgbmVlZGxlID0gW2RdO1xuICAgIH1cblxuICAgIHZhciBzZWxlY3RlZCA9IGZhbHNlO1xuICAgIG5lZWRsZS5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICBzZWxlY3RlZCA9IHNlbGVjdGVkIHwgaGF5c3RhY2tbc107XG4gICAgfSk7XG4gICAgcmV0dXJuICEhc2VsZWN0ZWQ7XG4gIH07XG59XG5cbi8qXG4gKiBTZXQgYSBjb250aW51b3VzIDFEIGZpbHRlciBmdW5jdGlvblxuICogQHBhcmFtIHtQYXJ0aXRpb259IHBhcnRpdGlvblxuICovXG5mdW5jdGlvbiBmaWx0ZXJGdW5jdGlvbkNvbnRpbnVvdXMxRCAocGFydGl0aW9uKSB7XG4gIHZhciBlZGdlID0gcGFydGl0aW9uLm1heHZhbDtcbiAgdmFyIG1pbjtcbiAgdmFyIG1heDtcblxuICBpZiAoIXBhcnRpdGlvbi5zZWxlY3RlZCB8fCAhcGFydGl0aW9uLnNlbGVjdGVkLmxlbmd0aCkge1xuICAgIG1pbiA9IHBhcnRpdGlvbi5taW52YWw7XG4gICAgbWF4ID0gcGFydGl0aW9uLm1heHZhbDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiAoKGQgPj0gbWluICYmIGQgPD0gbWF4KSAmJiAoZCAhPT0gbWlzdmFsKSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtaW4gPSBwYXJ0aXRpb24uc2VsZWN0ZWRbMF07XG4gICAgbWF4ID0gcGFydGl0aW9uLnNlbGVjdGVkWzFdO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuICgoZCA+PSBtaW4gJiYgZCA8IG1heCkgfHwgKChkID09PSBlZGdlKSAmJiAobWF4ID09PSBlZGdlKSkpICYmIChkICE9PSBtaXN2YWwpO1xuICAgIH07XG4gIH1cbn1cblxuLypcbiAqIFNldCBhIGNvbnRpbnVvdXMgMUQgZmlsdGVyIGZ1bmN0aW9uIG9uIGEgZGF0ZXRpbWUgZGltZW5zaW9uXG4gKiBAcGFyYW0ge1BhcnRpdGlvbn0gcGFydGl0aW9uXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckZ1bmN0aW9uRGF0ZXRpbWUxRCAocGFydGl0aW9uKSB7XG4gIHZhciBlZGdlID0gbW9tZW50KHBhcnRpdGlvbi5tYXh2YWwpO1xuICB2YXIgbWluO1xuICB2YXIgbWF4O1xuXG4gIGlmICghcGFydGl0aW9uLnNlbGVjdGVkIHx8ICFwYXJ0aXRpb24uc2VsZWN0ZWQubGVuZ3RoKSB7XG4gICAgbWluID0gbW9tZW50KHBhcnRpdGlvbi5taW52YWwpO1xuICAgIG1heCA9IG1vbWVudChwYXJ0aXRpb24ubWF4dmFsKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIG0gPSBtb21lbnQoZCk7XG4gICAgICByZXR1cm4gKG0gIT09IG1pc3ZhbCkgJiYgIW0uaXNCZWZvcmUobWluKSAmJiAhbS5pc0FmdGVyKG1heCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtaW4gPSBtb21lbnQocGFydGl0aW9uLnNlbGVjdGVkWzBdKTtcbiAgICBtYXggPSBtb21lbnQocGFydGl0aW9uLnNlbGVjdGVkWzFdKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciBtID0gbW9tZW50KGQpO1xuICAgICAgcmV0dXJuIChtICE9PSBtaXN2YWwpICYmICFtaW4uaXNBZnRlcihtKSAmJiAobS5pc0JlZm9yZShtYXgpIHx8IChtYXguaXNTYW1lKGVkZ2UpICYmIG1heC5pc1NhbWUobSkpKTtcbiAgICB9O1xuICB9XG59XG5cbi8qXG4gKiBTZXQgYSBjb250aW51b3VzIDFEIGZpbHRlciBmdW5jdGlvbiBvbiBhIGR1cmF0aW9uIGRpbWVuc2lvblxuICogQHBhcmFtIHtQYXJ0aXRpb259IHBhcnRpdGlvblxuICovXG5mdW5jdGlvbiBmaWx0ZXJGdW5jdGlvbkR1cmF0aW9uMUQgKHBhcnRpdGlvbikge1xuICB2YXIgZWRnZSA9IHBhcnRpdGlvbi5tYXh2YWw7XG4gIHZhciBtaW47XG4gIHZhciBtYXg7XG5cbiAgaWYgKCFwYXJ0aXRpb24uc2VsZWN0ZWQgfHwgIXBhcnRpdGlvbi5zZWxlY3RlZC5sZW5ndGgpIHtcbiAgICBtaW4gPSBwYXJ0aXRpb24ubWludmFsO1xuICAgIG1heCA9IHBhcnRpdGlvbi5tYXh2YWw7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIGlmIChkID09PSBtaXN2YWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG0gPSBtb21lbnQuZHVyYXRpb24oZCk7XG4gICAgICByZXR1cm4gbW9tZW50LmlzRHVyYXRpb24obSkgJiYgbSA+PSBtaW4gJiYgbSA8PSBtYXg7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtaW4gPSBtb21lbnQuZHVyYXRpb24ocGFydGl0aW9uLnNlbGVjdGVkWzBdKTtcbiAgICBtYXggPSBtb21lbnQuZHVyYXRpb24ocGFydGl0aW9uLnNlbGVjdGVkWzFdKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIGlmIChkID09PSBtaXN2YWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG0gPSBtb21lbnQuZHVyYXRpb24oZCk7XG4gICAgICByZXR1cm4gbW9tZW50LmlzRHVyYXRpb24obSkgJiYgbSA+PSBtaW4gJiYgKG0gPCBtYXggfHwgKG0gPD0gbWF4ICYmIG1heCA+PSBlZGdlKSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEEgZmlsdGVyIGZ1bmN0aW9uIGJhc2VkIGZvciBhIHNpbmdsZSBwYXJ0aXRpb25cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge2Jvb2xlYW59IHNlbGVjdGVkIFRydWUgaWYgdGhlIGRhdGFwb2ludCBpcyBjdXJyZW50bHkgc2VsZWN0ZWRcbiAqIEBwYXJhbSB7UGFydGl0aW9ufSBwYXJ0aXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhcG9pbnRcbiAqIEBtZW1iZXJvZiEgU2VsZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckZ1bmN0aW9uIChwYXJ0aXRpb24pIHtcbiAgaWYgKHBhcnRpdGlvbi5pc0NhdGVnb3JpYWwgfHwgcGFydGl0aW9uLmlzQ29uc3RhbnQpIHtcbiAgICByZXR1cm4gZmlsdGVyRnVuY3Rpb25DYXRlZ29yaWFsMUQocGFydGl0aW9uKTtcbiAgfSBlbHNlIGlmIChwYXJ0aXRpb24uaXNDb250aW51b3VzKSB7XG4gICAgcmV0dXJuIGZpbHRlckZ1bmN0aW9uQ29udGludW91czFEKHBhcnRpdGlvbik7XG4gIH0gZWxzZSBpZiAocGFydGl0aW9uLmlzRGF0ZXRpbWUpIHtcbiAgICByZXR1cm4gZmlsdGVyRnVuY3Rpb25EYXRldGltZTFEKHBhcnRpdGlvbik7XG4gIH0gZWxzZSBpZiAocGFydGl0aW9uLmlzRHVyYXRpb24pIHtcbiAgICByZXR1cm4gZmlsdGVyRnVuY3Rpb25EdXJhdGlvbjFEKHBhcnRpdGlvbik7XG4gIH0gZWxzZSBpZiAocGFydGl0aW9uLmlzVGV4dCkge1xuICAgIHJldHVybiBmaWx0ZXJGdW5jdGlvblRleHQocGFydGl0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgbWFrZSBmaWx0ZXJmdW5jdGlvbiBmb3IgcGFydGl0aW9uJywgcGFydGl0aW9uKTtcbiAgfVxufVxuXG4vKlxuICogQHBhcmFtIHtHcm91cH0gZ3JvdXAgLSBUaGUgZ3JvdXAgdG8gYWRkIG9yIHJlbW92ZSBmcm9tIHRoZSBmaWx0ZXJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlQ2F0ZWdvcmlhbDFEIChwYXJ0aXRpb24sIGdyb3VwKSB7XG4gIHZhciBzZWxlY3RlZCA9IHBhcnRpdGlvbi5zZWxlY3RlZDtcblxuICBpZiAoc2VsZWN0ZWQubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gMS4gbm9uZSBzZWxlY3RlZDpcbiAgICBzZWxlY3RlZC5wdXNoKGdyb3VwLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChzZWxlY3RlZC5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoc2VsZWN0ZWRbMF0gPT09IGdyb3VwLnZhbHVlKSB7XG4gICAgICAvLyAyLiBvbmUgc2VsZWN0ZWQgYW5kIHRoZSBncm91cCBpcyB0aGUgc2FtZTpcbiAgICAgIHNlbGVjdGVkLnNwbGljZSgwLCBzZWxlY3RlZC5sZW5ndGgpO1xuICAgICAgcGFydGl0aW9uLmdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIGlmIChnLnZhbHVlICE9PSBncm91cC52YWx1ZSkge1xuICAgICAgICAgIHNlbGVjdGVkLnB1c2goZy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAzLiBvbmUgc2VsZWN0ZWQgYW5kIHRoZSBncm91cCBpcyBkaWZmZXJlbnQ6XG4gICAgICBzZWxlY3RlZC5wdXNoKGdyb3VwLnZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGk7XG4gICAgaSA9IHNlbGVjdGVkLmluZGV4T2YoZ3JvdXAudmFsdWUpO1xuICAgIGlmIChpID4gLTEpIHtcbiAgICAgIC8vIDQuIG1vcmUgdGhhbiBvbmUgc2VsZWN0ZWQgYW5kIHRoZSBncm91cCBpcyBpbiB0aGUgc2VsZWN0aW9uOlxuICAgICAgc2VsZWN0ZWQuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyA1LiBtb3JlIHRoYW4gb25lIHNlbGVjdGVkIGFuZCB0aGUgZ3JvdXAgaXMgbm90IGluIHRoZSBzZWxlY3Rpb246XG4gICAgICBzZWxlY3RlZC5wdXNoKGdyb3VwLnZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvLyBhZnRlciBhZGQ6IGlmIGZpbHRlcnMgPT0gZ3JvdXBzLCByZXNldCBhbmQgZG9udCBmaWx0ZXJcbiAgaWYgKHNlbGVjdGVkLmxlbmd0aCA9PT0gcGFydGl0aW9uLmdyb3Vwcy5sZW5ndGgpIHtcbiAgICBzZWxlY3RlZC5zcGxpY2UoMCwgc2VsZWN0ZWQubGVuZ3RoKTtcbiAgfVxufVxuXG4vKlxuICogQHBhcmFtIHtHcm91cH0gZ3JvdXAgLSBUaGUgZ3JvdXAgdG8gYWRkIG9yIHJlbW92ZSBmcm9tIHRoZSBmaWx0ZXJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlVGV4dCAocGFydGl0aW9uLCBncm91cCkge1xuICB2YXIgc2VsZWN0ZWQgPSBwYXJ0aXRpb24uc2VsZWN0ZWQ7XG5cbiAgdmFyIGk7XG4gIGkgPSBzZWxlY3RlZC5pbmRleE9mKGdyb3VwLnZhbHVlKTtcbiAgaWYgKGkgPiAtMSkge1xuICAgIC8vIDEuIGluIHRoZSBzZWxlY3Rpb24sIHJlbW92ZSBpdFxuICAgIHNlbGVjdGVkLnNwbGljZShpLCAxKTtcbiAgfSBlbHNlIHtcbiAgICAvLyAyLiBub3QgaW4gdGhlIHNlbGVjdGlvbiwgYWRkIGl0XG4gICAgc2VsZWN0ZWQucHVzaChncm91cC52YWx1ZSk7XG4gIH1cbn1cblxuLypcbiAqIEBwYXJhbSB7R3JvdXB9IGdyb3VwIC0gVGhlIGdyb3VwIHRvIGFkZCBvciByZW1vdmUgZnJvbSB0aGUgZmlsdGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRpbnVvdXMxRCAocGFydGl0aW9uLCBncm91cCkge1xuICB2YXIgc2VsZWN0ZWQgPSBwYXJ0aXRpb24uc2VsZWN0ZWQ7XG5cbiAgaWYgKHNlbGVjdGVkLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIG5vdGhpbmcgc2VsZWN0ZWQsIHN0YXJ0IGEgcmFuZ2VcbiAgICBzZWxlY3RlZFswXSA9IGdyb3VwLm1pbjtcbiAgICBzZWxlY3RlZFsxXSA9IGdyb3VwLm1heDtcbiAgfSBlbHNlIGlmIChncm91cC5taW4gPj0gc2VsZWN0ZWRbMV0pIHtcbiAgICAvLyBjbGlja2VkIG91dHNpZGUgdG8gdGhlIHJpZ3RoIG9mIHNlbGVjdGlvblxuICAgIHNlbGVjdGVkWzFdID0gZ3JvdXAubWF4O1xuICB9IGVsc2UgaWYgKGdyb3VwLm1heCA8PSBzZWxlY3RlZFswXSkge1xuICAgIC8vIGNsaWNrZWQgb3V0c2lkZSB0byB0aGUgbGVmdCBvZiBzZWxlY3Rpb25cbiAgICBzZWxlY3RlZFswXSA9IGdyb3VwLm1pbjtcbiAgfSBlbHNlIHtcbiAgICAvLyBjbGlja2VkIGluc2lkZSBzZWxlY3Rpb25cbiAgICB2YXIgZDEsIGQyO1xuICAgIGlmIChwYXJ0aXRpb24uZ3JvdXBMb2cpIHtcbiAgICAgIGQxID0gTWF0aC5hYnMoTWF0aC5sb2coc2VsZWN0ZWRbMF0pIC0gTWF0aC5sb2coZ3JvdXAubWluKSk7XG4gICAgICBkMiA9IE1hdGguYWJzKE1hdGgubG9nKHNlbGVjdGVkWzFdKSAtIE1hdGgubG9nKGdyb3VwLm1heCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkMSA9IE1hdGguYWJzKHNlbGVjdGVkWzBdIC0gZ3JvdXAubWluKTtcbiAgICAgIGQyID0gTWF0aC5hYnMoc2VsZWN0ZWRbMV0gLSBncm91cC5tYXgpO1xuICAgIH1cbiAgICBpZiAoZDEgPCBkMikge1xuICAgICAgc2VsZWN0ZWRbMF0gPSBncm91cC5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGVkWzFdID0gZ3JvdXAubWF4O1xuICAgIH1cbiAgfVxufVxuXG4vKlxuICogQHBhcmFtIHtHcm91cH0gZ3JvdXAgLSBUaGUgZ3JvdXAgdG8gYWRkIG9yIHJlbW92ZSBmcm9tIHRoZSBmaWx0ZXJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlRGF0ZXRpbWUxRCAocGFydGl0aW9uLCBncm91cCkge1xuICB2YXIgc2VsZWN0ZWQgPSBwYXJ0aXRpb24uc2VsZWN0ZWQ7XG5cbiAgaWYgKCFzZWxlY3RlZCB8fCBzZWxlY3RlZC5sZW5ndGggPT09IDApIHtcbiAgICAvLyBub3RoaW5nIHNlbGVjdGVkLCBzdGFydCBhIHJhbmdlXG4gICAgc2VsZWN0ZWRbMF0gPSBncm91cC5taW4udG9JU09TdHJpbmcoKTtcbiAgICBzZWxlY3RlZFsxXSA9IGdyb3VwLm1heC50b0lTT1N0cmluZygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb25TdGFydCA9IG1vbWVudChzZWxlY3RlZFswXSk7XG4gIHZhciBzZWxlY3Rpb25FbmQgPSBtb21lbnQoc2VsZWN0ZWRbMV0pO1xuXG4gIGlmICghZ3JvdXAubWluLmlzQmVmb3JlKHNlbGVjdGlvbkVuZCkpIHtcbiAgICAvLyBjbGlja2VkIG91dHNpZGUgdG8gdGhlIHJpZ3RoIG9mIHNlbGVjdGlvblxuICAgIHNlbGVjdGVkWzFdID0gZ3JvdXAubWF4LnRvSVNPU3RyaW5nKCk7XG4gIH0gZWxzZSBpZiAoIWdyb3VwLm1heC5pc0FmdGVyKHNlbGVjdGlvblN0YXJ0KSkge1xuICAgIC8vIGNsaWNrZWQgb3V0c2lkZSB0byB0aGUgbGVmdCBvZiBzZWxlY3Rpb25cbiAgICBzZWxlY3RlZFswXSA9IGdyb3VwLm1pbi50b0lTT1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIC8vIGNsaWNrZWQgaW5zaWRlIHNlbGVjdGlvblxuICAgIHZhciBkMSwgZDI7XG4gICAgZDEgPSBNYXRoLmFicyhzZWxlY3Rpb25TdGFydC5kaWZmKGdyb3VwLm1pbikpO1xuICAgIGQyID0gTWF0aC5hYnMoc2VsZWN0aW9uRW5kLmRpZmYoZ3JvdXAubWF4KSk7XG5cbiAgICBpZiAoZDEgPCBkMikge1xuICAgICAgc2VsZWN0ZWRbMF0gPSBncm91cC5tYXgudG9JU09TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0ZWRbMV0gPSBncm91cC5taW4udG9JU09TdHJpbmcoKTtcbiAgICB9XG4gIH1cbn1cblxuLypcbiAqIEBwYXJhbSB7R3JvdXB9IGdyb3VwIC0gVGhlIGdyb3VwIHRvIGFkZCBvciByZW1vdmUgZnJvbSB0aGUgZmlsdGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUR1cmF0aW9uMUQgKHBhcnRpdGlvbiwgZ3JvdXApIHtcbiAgdmFyIHNlbGVjdGVkID0gcGFydGl0aW9uLnNlbGVjdGVkO1xuXG4gIGlmIChzZWxlY3RlZC5sZW5ndGggPT09IDApIHtcbiAgICAvLyBub3RoaW5nIHNlbGVjdGVkLCBzdGFydCBhIHJhbmdlXG4gICAgc2VsZWN0ZWRbMF0gPSBncm91cC5taW4udG9JU09TdHJpbmcoKTtcbiAgICBzZWxlY3RlZFsxXSA9IGdyb3VwLm1heC50b0lTT1N0cmluZygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb25TdGFydCA9IG1vbWVudC5kdXJhdGlvbihzZWxlY3RlZFswXSk7XG4gIHZhciBzZWxlY3Rpb25FbmQgPSBtb21lbnQuZHVyYXRpb24oc2VsZWN0ZWRbMV0pO1xuXG4gIGlmIChncm91cC5taW4gPj0gc2VsZWN0aW9uRW5kKSB7XG4gICAgLy8gY2xpY2tlZCBvdXRzaWRlIHRvIHRoZSByaWd0aCBvZiBzZWxlY3Rpb25cbiAgICBzZWxlY3RlZFsxXSA9IGdyb3VwLm1heC50b0lTT1N0cmluZygpO1xuICB9IGVsc2UgaWYgKGdyb3VwLm1heCA8PSBzZWxlY3Rpb25TdGFydCkge1xuICAgIC8vIGNsaWNrZWQgb3V0c2lkZSB0byB0aGUgbGVmdCBvZiBzZWxlY3Rpb25cbiAgICBzZWxlY3RlZFswXSA9IGdyb3VwLm1pbi50b0lTT1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIC8vIGNsaWNrZWQgaW5zaWRlIHNlbGVjdGlvblxuICAgIHZhciBkMSwgZDI7XG4gICAgZDEgPSBNYXRoLmFicyhzZWxlY3Rpb25TdGFydCAtIGdyb3VwLm1pbik7XG4gICAgZDIgPSBNYXRoLmFicyhzZWxlY3Rpb25FbmQgLSBncm91cC5tYXgpO1xuXG4gICAgaWYgKGQxIDwgZDIpIHtcbiAgICAgIHNlbGVjdGVkWzBdID0gZ3JvdXAubWF4LnRvSVNPU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGVkWzFdID0gZ3JvdXAubWluLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIGdpdmVuIGdyb3VwIG9yIGludGVydmFsXG4gKiBvciwgaWYgbm8gZ3JvdXAgaXMgZ2l2ZW4sIGNsZWFyIHRoZSBzZWxlY3Rpb24uXG4gKlxuICogRm9yIGNhdGVnb3JpYWwgc2VsZWN0aW9ucyB0aGUgZm9sbG93aW5nIHJ1bGVzIGFyZSB1c2VkOlxuICogMS4gbm9uZSBzZWxlY3RlZDpcbiAqICAgIGFkZCB0aGUgZ3JvdXAgdG8gdGhlIHNlbGVjdGlvblxuICogMi4gb25lIHNlbGVjdGVkIGFuZCB0aGUgZ3JvdXAgaXMgdGhlIHNhbWU6XG4gKiAgICBpbnZlcnQgdGhlIHNlbGVjdGlvblxuICogMy4gb25lIHNlbGVjdGVkIGFuZCB0aGUgZ3JvdXAgaXMgZGlmZmVyZW50OlxuICogICAgYWRkIHRoZSBncm91cCB0byB0aGUgc2VsZWN0aW9uXG4gKiA0LiBtb3JlIHRoYW4gb25lIHNlbGVjdGVkIGFuZCB0aGUgZ3JvdXAgaXMgaW4gdGhlIHNlbGVjdGlvbjpcbiAqICAgIHJlbW92ZSB0aGUgZ3JvdXAgZnJvbSB0aGUgc2VsZWN0aW9uXG4gKiA1LiBtb3JlIHRoYW4gb25lIHNlbGVjdGVkIGFuZCB0aGUgZ3JvdXAgaXMgbm90IGluIHRoZSBzZWxlY3Rpb246XG4gKiAgICBhZGQgdGhlIGdyb3VwIHRvIHRoZSBzZWxlY3Rpb25cbiAqXG4gKiBGb3IgY29udGludW91cyBzZWxlY3Rpb25zIHRoZSBmb2xsb3dpbmcgcnVsZXMgYXJlIHVzZWQ6XG4gKiAxLiBubyByYW5nZSBzZWxlY3RlZFxuICogICAgc2V0IHRoZSByYW5nZSBlcXVhbCB0byB0aGF0IG9mIHRoZSBncm91cFxuICogMi4gYSByYW5nZSBzZWxlY3RlZCBhbmQgdGhlIGdyb3VwIGlzIG91dHNpZGUgdGhlIHNlbGVjdGlvbjpcbiAqICAgIGV4dGVuZCB0aGUgc2VsZWN0aW9uIHRvIGluY2x1ZGUgdGhlIGdyb3VwXG4gKiAzLiBhIHJhbmdlIHNlbGVjdGVkIGFuZCB0aGUgZ3JvdXAgaXMgaW5zaWRlIHRoZSBzZWxlY3Rpb246XG4gKiAgICBzZXQgdGhlIGVuZHBvaW50IGNsb3Nlc3QgdG8gdGhlIGdyb3VwIHRvIHRoYXQgb2YgdGhlIGdyb3VwXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1BhcnRpdGlvbn0gUGFydGl0aW9uIHRvIHVwZGF0ZVxuICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcltdKX0gR3JvdXAgb3IgaW50ZXJ2YWxcbiAqL1xuZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW9uIChwYXJ0aXRpb24sIGdyb3VwKSB7XG4gIGlmICghZ3JvdXApIHtcbiAgICAvLyBDbGVhciB0aGUgc2VsZWN0aW9uIChpZS4gYWxsIHBvaW50cyBhcmUgc2VsZWN0ZWQpXG4gICAgcGFydGl0aW9uLnNlbGVjdGVkLnNwbGljZSgwLCBwYXJ0aXRpb24uc2VsZWN0ZWQubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBVcGRhdGUgdGhlIHNlbGVjdGlvblxuICAgIGlmIChwYXJ0aXRpb24udHlwZSA9PT0gJ2NhdGVnb3JpYWwnIHx8IHBhcnRpdGlvbi50eXBlID09PSAnY29uc3RhbnQnKSB7XG4gICAgICB1cGRhdGVDYXRlZ29yaWFsMUQocGFydGl0aW9uLCBncm91cCk7XG4gICAgfSBlbHNlIGlmIChwYXJ0aXRpb24udHlwZSA9PT0gJ2NvbnRpbnVvdXMnKSB7XG4gICAgICB1cGRhdGVDb250aW51b3VzMUQocGFydGl0aW9uLCBncm91cCk7XG4gICAgfSBlbHNlIGlmIChwYXJ0aXRpb24udHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgdXBkYXRlRGF0ZXRpbWUxRChwYXJ0aXRpb24sIGdyb3VwKTtcbiAgICB9IGVsc2UgaWYgKHBhcnRpdGlvbi50eXBlID09PSAnZHVyYXRpb24nKSB7XG4gICAgICB1cGRhdGVEdXJhdGlvbjFEKHBhcnRpdGlvbiwgZ3JvdXApO1xuICAgIH0gZWxzZSBpZiAocGFydGl0aW9uLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgdXBkYXRlVGV4dChwYXJ0aXRpb24sIGdyb3VwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IHVwZGF0ZSBzZWxlY3Rpb24nLCBwYXJ0aXRpb24udHlwZSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmaWx0ZXJGdW5jdGlvbjogZmlsdGVyRnVuY3Rpb24sXG4gIHVwZGF0ZVNlbGVjdGlvbjogdXBkYXRlU2VsZWN0aW9uXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1278\n")},"181d":function(module,exports,__webpack_require__){eval("/**\n * Module dependencies.\n */\n\nvar Transport = __webpack_require__(/*! ../transport */ \"0d97\");\nvar parseqs = __webpack_require__(/*! parseqs */ \"914f\");\nvar parser = __webpack_require__(/*! engine.io-parser */ \"aa6c\");\nvar inherit = __webpack_require__(/*! component-inherit */ \"42bf\");\nvar yeast = __webpack_require__(/*! yeast */ \"c16d\");\nvar debug = __webpack_require__(/*! debug */ \"433b\")('engine.io-client:polling');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Polling;\n\n/**\n * Is XHR2 supported?\n */\n\nvar hasXHR2 = (function () {\n  var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ \"86e3\");\n  var xhr = new XMLHttpRequest({ xdomain: false });\n  return null != xhr.responseType;\n})();\n\n/**\n * Polling interface.\n *\n * @param {Object} opts\n * @api private\n */\n\nfunction Polling (opts) {\n  var forceBase64 = (opts && opts.forceBase64);\n  if (!hasXHR2 || forceBase64) {\n    this.supportsBinary = false;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(Polling, Transport);\n\n/**\n * Transport name.\n */\n\nPolling.prototype.name = 'polling';\n\n/**\n * Opens the socket (triggers polling). We write a PING message to determine\n * when the transport is open.\n *\n * @api private\n */\n\nPolling.prototype.doOpen = function () {\n  this.poll();\n};\n\n/**\n * Pauses polling.\n *\n * @param {Function} callback upon buffers are flushed and transport is paused\n * @api private\n */\n\nPolling.prototype.pause = function (onPause) {\n  var self = this;\n\n  this.readyState = 'pausing';\n\n  function pause () {\n    debug('paused');\n    self.readyState = 'paused';\n    onPause();\n  }\n\n  if (this.polling || !this.writable) {\n    var total = 0;\n\n    if (this.polling) {\n      debug('we are currently polling - waiting to pause');\n      total++;\n      this.once('pollComplete', function () {\n        debug('pre-pause polling complete');\n        --total || pause();\n      });\n    }\n\n    if (!this.writable) {\n      debug('we are currently writing - waiting to pause');\n      total++;\n      this.once('drain', function () {\n        debug('pre-pause writing complete');\n        --total || pause();\n      });\n    }\n  } else {\n    pause();\n  }\n};\n\n/**\n * Starts polling cycle.\n *\n * @api public\n */\n\nPolling.prototype.poll = function () {\n  debug('polling');\n  this.polling = true;\n  this.doPoll();\n  this.emit('poll');\n};\n\n/**\n * Overloads onData to detect payloads.\n *\n * @api private\n */\n\nPolling.prototype.onData = function (data) {\n  var self = this;\n  debug('polling got data %s', data);\n  var callback = function (packet, index, total) {\n    // if its the first message we consider the transport open\n    if ('opening' === self.readyState) {\n      self.onOpen();\n    }\n\n    // if its a close packet, we close the ongoing requests\n    if ('close' === packet.type) {\n      self.onClose();\n      return false;\n    }\n\n    // otherwise bypass onData and handle the message\n    self.onPacket(packet);\n  };\n\n  // decode payload\n  parser.decodePayload(data, this.socket.binaryType, callback);\n\n  // if an event did not trigger closing\n  if ('closed' !== this.readyState) {\n    // if we got data we're not polling\n    this.polling = false;\n    this.emit('pollComplete');\n\n    if ('open' === this.readyState) {\n      this.poll();\n    } else {\n      debug('ignoring poll - transport state \"%s\"', this.readyState);\n    }\n  }\n};\n\n/**\n * For polling, send a close packet.\n *\n * @api private\n */\n\nPolling.prototype.doClose = function () {\n  var self = this;\n\n  function close () {\n    debug('writing close packet');\n    self.write([{ type: 'close' }]);\n  }\n\n  if ('open' === this.readyState) {\n    debug('transport open - closing');\n    close();\n  } else {\n    // in case we're trying to close while\n    // handshaking is in progress (GH-164)\n    debug('transport not open - deferring close');\n    this.once('open', close);\n  }\n};\n\n/**\n * Writes a packets payload.\n *\n * @param {Array} data packets\n * @param {Function} drain callback\n * @api private\n */\n\nPolling.prototype.write = function (packets) {\n  var self = this;\n  this.writable = false;\n  var callbackfn = function () {\n    self.writable = true;\n    self.emit('drain');\n  };\n\n  parser.encodePayload(packets, this.supportsBinary, function (data) {\n    self.doWrite(data, callbackfn);\n  });\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nPolling.prototype.uri = function () {\n  var query = this.query || {};\n  var schema = this.secure ? 'https' : 'http';\n  var port = '';\n\n  // cache busting is forced\n  if (false !== this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  if (!this.supportsBinary && !query.sid) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // avoid port if default for schema\n  if (this.port && (('https' === schema && Number(this.port) !== 443) ||\n     ('http' === schema && Number(this.port) !== 80))) {\n    port = ':' + this.port;\n  }\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgxZC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLmpzP2U1ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciB5ZWFzdCA9IHJlcXVpcmUoJ3llYXN0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG5cbi8qKlxuICogSXMgWEhSMiBzdXBwb3J0ZWQ/XG4gKi9cblxudmFyIGhhc1hIUjIgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbiAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCh7IHhkb21haW46IGZhbHNlIH0pO1xuICByZXR1cm4gbnVsbCAhPSB4aHIucmVzcG9uc2VUeXBlO1xufSkoKTtcblxuLyoqXG4gKiBQb2xsaW5nIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUG9sbGluZyAob3B0cykge1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXG4vKipcbiAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wb2xsKCk7XG59O1xuXG4vKipcbiAqIFBhdXNlcyBwb2xsaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHVwb24gYnVmZmVycyBhcmUgZmx1c2hlZCBhbmQgdHJhbnNwb3J0IGlzIHBhdXNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAob25QYXVzZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ3BhdXNpbmcnO1xuXG4gIGZ1bmN0aW9uIHBhdXNlICgpIHtcbiAgICBkZWJ1ZygncGF1c2VkJyk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ3BhdXNlZCc7XG4gICAgb25QYXVzZSgpO1xuICB9XG5cbiAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSBwb2xsaW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgncG9sbENvbXBsZXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2Ugd3JpdGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGF1c2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydHMgcG9sbGluZyBjeWNsZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdwb2xsaW5nJyk7XG4gIHRoaXMucG9sbGluZyA9IHRydWU7XG4gIHRoaXMuZG9Qb2xsKCk7XG4gIHRoaXMuZW1pdCgncG9sbCcpO1xufTtcblxuLyoqXG4gKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGRlYnVnKCdwb2xsaW5nIGdvdCBkYXRhICVzJywgZGF0YSk7XG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChwYWNrZXQsIGluZGV4LCB0b3RhbCkge1xuICAgIC8vIGlmIGl0cyB0aGUgZmlyc3QgbWVzc2FnZSB3ZSBjb25zaWRlciB0aGUgdHJhbnNwb3J0IG9wZW5cbiAgICBpZiAoJ29wZW5pbmcnID09PSBzZWxmLnJlYWR5U3RhdGUpIHtcbiAgICAgIHNlbGYub25PcGVuKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgaXRzIGEgY2xvc2UgcGFja2V0LCB3ZSBjbG9zZSB0aGUgb25nb2luZyByZXF1ZXN0c1xuICAgIGlmICgnY2xvc2UnID09PSBwYWNrZXQudHlwZSkge1xuICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfTtcblxuICAvLyBkZWNvZGUgcGF5bG9hZFxuICBwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlLCBjYWxsYmFjayk7XG5cbiAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3NpbmdcbiAgaWYgKCdjbG9zZWQnICE9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuICAgIHRoaXMucG9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncG9sbENvbXBsZXRlJyk7XG5cbiAgICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgIHRoaXMucG9sbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnaWdub3JpbmcgcG9sbCAtIHRyYW5zcG9ydCBzdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gY2xvc2UgKCkge1xuICAgIGRlYnVnKCd3cml0aW5nIGNsb3NlIHBhY2tldCcpO1xuICAgIHNlbGYud3JpdGUoW3sgdHlwZTogJ2Nsb3NlJyB9XSk7XG4gIH1cblxuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG9wZW4gLSBjbG9zaW5nJyk7XG4gICAgY2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG4gICAgZGVidWcoJ3RyYW5zcG9ydCBub3Qgb3BlbiAtIGRlZmVycmluZyBjbG9zZScpO1xuICAgIHRoaXMub25jZSgnb3BlbicsIGNsb3NlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBwYWNrZXRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdmFyIGNhbGxiYWNrZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICB9O1xuXG4gIHBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIHRoaXMuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgc2VsZi5kb1dyaXRlKGRhdGEsIGNhbGxiYWNrZm4pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICdodHRwcycgOiAnaHR0cCc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gY2FjaGUgYnVzdGluZyBpcyBmb3JjZWRcbiAgaWYgKGZhbHNlICE9PSB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmICFxdWVyeS5zaWQpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCdodHRwcycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gNDQzKSB8fFxuICAgICAoJ2h0dHAnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///181d\n")},"1e1f":function(module,exports,__webpack_require__){eval("\n/**\n * Module dependencies.\n */\n\nvar eio = __webpack_require__(/*! engine.io-client */ \"c59b\");\nvar Socket = __webpack_require__(/*! ./socket */ \"4c13\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"ee5b\");\nvar parser = __webpack_require__(/*! socket.io-parser */ \"6fba\");\nvar on = __webpack_require__(/*! ./on */ \"faaa\");\nvar bind = __webpack_require__(/*! component-bind */ \"b6f6\");\nvar debug = __webpack_require__(/*! debug */ \"433b\")('socket.io-client:manager');\nvar indexOf = __webpack_require__(/*! indexof */ \"3294\");\nvar Backoff = __webpack_require__(/*! backo2 */ \"f942\");\n\n/**\n * IE6+ hasOwnProperty\n */\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Module exports\n */\n\nmodule.exports = Manager;\n\n/**\n * `Manager` constructor.\n *\n * @param {String} engine instance or engine uri/opts\n * @param {Object} options\n * @api public\n */\n\nfunction Manager (uri, opts) {\n  if (!(this instanceof Manager)) return new Manager(uri, opts);\n  if (uri && ('object' === typeof uri)) {\n    opts = uri;\n    uri = undefined;\n  }\n  opts = opts || {};\n\n  opts.path = opts.path || '/socket.io';\n  this.nsps = {};\n  this.subs = [];\n  this.opts = opts;\n  this.reconnection(opts.reconnection !== false);\n  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n  this.reconnectionDelay(opts.reconnectionDelay || 1000);\n  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n  this.randomizationFactor(opts.randomizationFactor || 0.5);\n  this.backoff = new Backoff({\n    min: this.reconnectionDelay(),\n    max: this.reconnectionDelayMax(),\n    jitter: this.randomizationFactor()\n  });\n  this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n  this.readyState = 'closed';\n  this.uri = uri;\n  this.connecting = [];\n  this.lastPing = null;\n  this.encoding = false;\n  this.packetBuffer = [];\n  this.encoder = new parser.Encoder();\n  this.decoder = new parser.Decoder();\n  this.autoConnect = opts.autoConnect !== false;\n  if (this.autoConnect) this.open();\n}\n\n/**\n * Propagate given event to sockets and emit on `this`\n *\n * @api private\n */\n\nManager.prototype.emitAll = function () {\n  this.emit.apply(this, arguments);\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\n    }\n  }\n};\n\n/**\n * Update `socket.id` of all sockets\n *\n * @api private\n */\n\nManager.prototype.updateSocketIds = function () {\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].id = this.engine.id;\n    }\n  }\n};\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Manager.prototype);\n\n/**\n * Sets the `reconnection` config.\n *\n * @param {Boolean} true/false if it should automatically reconnect\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnection = function (v) {\n  if (!arguments.length) return this._reconnection;\n  this._reconnection = !!v;\n  return this;\n};\n\n/**\n * Sets the reconnection attempts config.\n *\n * @param {Number} max reconnection attempts before giving up\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionAttempts = function (v) {\n  if (!arguments.length) return this._reconnectionAttempts;\n  this._reconnectionAttempts = v;\n  return this;\n};\n\n/**\n * Sets the delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelay = function (v) {\n  if (!arguments.length) return this._reconnectionDelay;\n  this._reconnectionDelay = v;\n  this.backoff && this.backoff.setMin(v);\n  return this;\n};\n\nManager.prototype.randomizationFactor = function (v) {\n  if (!arguments.length) return this._randomizationFactor;\n  this._randomizationFactor = v;\n  this.backoff && this.backoff.setJitter(v);\n  return this;\n};\n\n/**\n * Sets the maximum delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelayMax = function (v) {\n  if (!arguments.length) return this._reconnectionDelayMax;\n  this._reconnectionDelayMax = v;\n  this.backoff && this.backoff.setMax(v);\n  return this;\n};\n\n/**\n * Sets the connection timeout. `false` to disable\n *\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.timeout = function (v) {\n  if (!arguments.length) return this._timeout;\n  this._timeout = v;\n  return this;\n};\n\n/**\n * Starts trying to reconnect if reconnection is enabled and we have not\n * started reconnecting yet\n *\n * @api private\n */\n\nManager.prototype.maybeReconnectOnOpen = function () {\n  // Only try to reconnect if it's the first time we're connecting\n  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {\n    // keeps reconnection from firing twice for the same reconnection loop\n    this.reconnect();\n  }\n};\n\n/**\n * Sets the current transport `socket`.\n *\n * @param {Function} optional, callback\n * @return {Manager} self\n * @api public\n */\n\nManager.prototype.open =\nManager.prototype.connect = function (fn, opts) {\n  debug('readyState %s', this.readyState);\n  if (~this.readyState.indexOf('open')) return this;\n\n  debug('opening %s', this.uri);\n  this.engine = eio(this.uri, this.opts);\n  var socket = this.engine;\n  var self = this;\n  this.readyState = 'opening';\n  this.skipReconnect = false;\n\n  // emit `open`\n  var openSub = on(socket, 'open', function () {\n    self.onopen();\n    fn && fn();\n  });\n\n  // emit `connect_error`\n  var errorSub = on(socket, 'error', function (data) {\n    debug('connect_error');\n    self.cleanup();\n    self.readyState = 'closed';\n    self.emitAll('connect_error', data);\n    if (fn) {\n      var err = new Error('Connection error');\n      err.data = data;\n      fn(err);\n    } else {\n      // Only do this if there is no fn to handle the error\n      self.maybeReconnectOnOpen();\n    }\n  });\n\n  // emit `connect_timeout`\n  if (false !== this._timeout) {\n    var timeout = this._timeout;\n    debug('connect attempt will timeout after %d', timeout);\n\n    // set timer\n    var timer = setTimeout(function () {\n      debug('connect attempt timed out after %d', timeout);\n      openSub.destroy();\n      socket.close();\n      socket.emit('error', 'timeout');\n      self.emitAll('connect_timeout', timeout);\n    }, timeout);\n\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n\n  this.subs.push(openSub);\n  this.subs.push(errorSub);\n\n  return this;\n};\n\n/**\n * Called upon transport open.\n *\n * @api private\n */\n\nManager.prototype.onopen = function () {\n  debug('open');\n\n  // clear old subs\n  this.cleanup();\n\n  // mark as open\n  this.readyState = 'open';\n  this.emit('open');\n\n  // add new subs\n  var socket = this.engine;\n  this.subs.push(on(socket, 'data', bind(this, 'ondata')));\n  this.subs.push(on(socket, 'ping', bind(this, 'onping')));\n  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));\n  this.subs.push(on(socket, 'error', bind(this, 'onerror')));\n  this.subs.push(on(socket, 'close', bind(this, 'onclose')));\n  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));\n};\n\n/**\n * Called upon a ping.\n *\n * @api private\n */\n\nManager.prototype.onping = function () {\n  this.lastPing = new Date();\n  this.emitAll('ping');\n};\n\n/**\n * Called upon a packet.\n *\n * @api private\n */\n\nManager.prototype.onpong = function () {\n  this.emitAll('pong', new Date() - this.lastPing);\n};\n\n/**\n * Called with data.\n *\n * @api private\n */\n\nManager.prototype.ondata = function (data) {\n  this.decoder.add(data);\n};\n\n/**\n * Called when parser fully decodes a packet.\n *\n * @api private\n */\n\nManager.prototype.ondecoded = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon socket error.\n *\n * @api private\n */\n\nManager.prototype.onerror = function (err) {\n  debug('error', err);\n  this.emitAll('error', err);\n};\n\n/**\n * Creates a new socket for the given `nsp`.\n *\n * @return {Socket}\n * @api public\n */\n\nManager.prototype.socket = function (nsp, opts) {\n  var socket = this.nsps[nsp];\n  if (!socket) {\n    socket = new Socket(this, nsp, opts);\n    this.nsps[nsp] = socket;\n    var self = this;\n    socket.on('connecting', onConnecting);\n    socket.on('connect', function () {\n      socket.id = self.engine.id;\n    });\n\n    if (this.autoConnect) {\n      // manually call here since connecting evnet is fired before listening\n      onConnecting();\n    }\n  }\n\n  function onConnecting () {\n    if (!~indexOf(self.connecting, socket)) {\n      self.connecting.push(socket);\n    }\n  }\n\n  return socket;\n};\n\n/**\n * Called upon a socket close.\n *\n * @param {Socket} socket\n */\n\nManager.prototype.destroy = function (socket) {\n  var index = indexOf(this.connecting, socket);\n  if (~index) this.connecting.splice(index, 1);\n  if (this.connecting.length) return;\n\n  this.close();\n};\n\n/**\n * Writes a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nManager.prototype.packet = function (packet) {\n  debug('writing packet %j', packet);\n  var self = this;\n  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;\n\n  if (!self.encoding) {\n    // encode, then write to engine with result\n    self.encoding = true;\n    this.encoder.encode(packet, function (encodedPackets) {\n      for (var i = 0; i < encodedPackets.length; i++) {\n        self.engine.write(encodedPackets[i], packet.options);\n      }\n      self.encoding = false;\n      self.processPacketQueue();\n    });\n  } else { // add packet to the queue\n    self.packetBuffer.push(packet);\n  }\n};\n\n/**\n * If packet buffer is non-empty, begins encoding the\n * next packet in line.\n *\n * @api private\n */\n\nManager.prototype.processPacketQueue = function () {\n  if (this.packetBuffer.length > 0 && !this.encoding) {\n    var pack = this.packetBuffer.shift();\n    this.packet(pack);\n  }\n};\n\n/**\n * Clean up transport subscriptions and packet buffer.\n *\n * @api private\n */\n\nManager.prototype.cleanup = function () {\n  debug('cleanup');\n\n  var subsLength = this.subs.length;\n  for (var i = 0; i < subsLength; i++) {\n    var sub = this.subs.shift();\n    sub.destroy();\n  }\n\n  this.packetBuffer = [];\n  this.encoding = false;\n  this.lastPing = null;\n\n  this.decoder.destroy();\n};\n\n/**\n * Close the current socket.\n *\n * @api private\n */\n\nManager.prototype.close =\nManager.prototype.disconnect = function () {\n  debug('disconnect');\n  this.skipReconnect = true;\n  this.reconnecting = false;\n  if ('opening' === this.readyState) {\n    // `onclose` will not fire because\n    // an open event never happened\n    this.cleanup();\n  }\n  this.backoff.reset();\n  this.readyState = 'closed';\n  if (this.engine) this.engine.close();\n};\n\n/**\n * Called upon engine close.\n *\n * @api private\n */\n\nManager.prototype.onclose = function (reason) {\n  debug('onclose');\n\n  this.cleanup();\n  this.backoff.reset();\n  this.readyState = 'closed';\n  this.emit('close', reason);\n\n  if (this._reconnection && !this.skipReconnect) {\n    this.reconnect();\n  }\n};\n\n/**\n * Attempt a reconnection.\n *\n * @api private\n */\n\nManager.prototype.reconnect = function () {\n  if (this.reconnecting || this.skipReconnect) return this;\n\n  var self = this;\n\n  if (this.backoff.attempts >= this._reconnectionAttempts) {\n    debug('reconnect failed');\n    this.backoff.reset();\n    this.emitAll('reconnect_failed');\n    this.reconnecting = false;\n  } else {\n    var delay = this.backoff.duration();\n    debug('will wait %dms before reconnect attempt', delay);\n\n    this.reconnecting = true;\n    var timer = setTimeout(function () {\n      if (self.skipReconnect) return;\n\n      debug('attempting reconnect');\n      self.emitAll('reconnect_attempt', self.backoff.attempts);\n      self.emitAll('reconnecting', self.backoff.attempts);\n\n      // check again for the case socket closed in above events\n      if (self.skipReconnect) return;\n\n      self.open(function (err) {\n        if (err) {\n          debug('reconnect attempt error');\n          self.reconnecting = false;\n          self.reconnect();\n          self.emitAll('reconnect_error', err.data);\n        } else {\n          debug('reconnect success');\n          self.onreconnect();\n        }\n      });\n    }, delay);\n\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n};\n\n/**\n * Called upon successful reconnect.\n *\n * @api private\n */\n\nManager.prototype.onreconnect = function () {\n  var attempt = this.backoff.attempts;\n  this.reconnecting = false;\n  this.backoff.reset();\n  this.updateSocketIds();\n  this.emitAll('reconnect', attempt);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMWUxZi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvbWFuYWdlci5qcz9mMDk3Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBlaW8gPSByZXF1aXJlKCdlbmdpbmUuaW8tY2xpZW50Jyk7XG52YXIgU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcbnZhciBpbmRleE9mID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIEJhY2tvZmYgPSByZXF1aXJlKCdiYWNrbzInKTtcblxuLyoqXG4gKiBJRTYrIGhhc093blByb3BlcnR5XG4gKi9cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hbmFnZXI7XG5cbi8qKlxuICogYE1hbmFnZXJgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmdpbmUgaW5zdGFuY2Ugb3IgZW5naW5lIHVyaS9vcHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBNYW5hZ2VyICh1cmksIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcbiAgaWYgKHVyaSAmJiAoJ29iamVjdCcgPT09IHR5cGVvZiB1cmkpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8ICcvc29ja2V0LmlvJztcbiAgdGhpcy5uc3BzID0ge307XG4gIHRoaXMuc3VicyA9IFtdO1xuICB0aGlzLm9wdHMgPSBvcHRzO1xuICB0aGlzLnJlY29ubmVjdGlvbihvcHRzLnJlY29ubmVjdGlvbiAhPT0gZmFsc2UpO1xuICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KG9wdHMucmVjb25uZWN0aW9uRGVsYXkgfHwgMTAwMCk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgob3B0cy5yZWNvbm5lY3Rpb25EZWxheU1heCB8fCA1MDAwKTtcbiAgdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKG9wdHMucmFuZG9taXphdGlvbkZhY3RvciB8fCAwLjUpO1xuICB0aGlzLmJhY2tvZmYgPSBuZXcgQmFja29mZih7XG4gICAgbWluOiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KCksXG4gICAgbWF4OiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KCksXG4gICAgaml0dGVyOiB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3IoKVxuICB9KTtcbiAgdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy51cmkgPSB1cmk7XG4gIHRoaXMuY29ubmVjdGluZyA9IFtdO1xuICB0aGlzLmxhc3RQaW5nID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kZXIgPSBuZXcgcGFyc2VyLkVuY29kZXIoKTtcbiAgdGhpcy5kZWNvZGVyID0gbmV3IHBhcnNlci5EZWNvZGVyKCk7XG4gIHRoaXMuYXV0b0Nvbm5lY3QgPSBvcHRzLmF1dG9Db25uZWN0ICE9PSBmYWxzZTtcbiAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIFByb3BhZ2F0ZSBnaXZlbiBldmVudCB0byBzb2NrZXRzIGFuZCBlbWl0IG9uIGB0aGlzYFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmVtaXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uZW1pdC5hcHBseSh0aGlzLm5zcHNbbnNwXSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIGBzb2NrZXQuaWRgIG9mIGFsbCBzb2NrZXRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudXBkYXRlU29ja2V0SWRzID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uaWQgPSB0aGlzLmVuZ2luZS5pZDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKE1hbmFnZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgcmVjb25uZWN0aW9uYCBjb25maWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB0cnVlL2ZhbHNlIGlmIGl0IHNob3VsZCBhdXRvbWF0aWNhbGx5IHJlY29ubmVjdFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb24gPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb247XG4gIHRoaXMuX3JlY29ubmVjdGlvbiA9ICEhdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBjb25maWcuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgYmVmb3JlIGdpdmluZyB1cFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuICB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXk7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNaW4odik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuTWFuYWdlci5wcm90b3R5cGUucmFuZG9taXphdGlvbkZhY3RvciA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I7XG4gIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3IgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldEppdHRlcih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheU1heCA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWF4KHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29ubmVjdGlvbiB0aW1lb3V0LiBgZmFsc2VgIHRvIGRpc2FibGVcbiAqXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aW1lb3V0O1xuICB0aGlzLl90aW1lb3V0ID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyB0cnlpbmcgdG8gcmVjb25uZWN0IGlmIHJlY29ubmVjdGlvbiBpcyBlbmFibGVkIGFuZCB3ZSBoYXZlIG5vdFxuICogc3RhcnRlZCByZWNvbm5lY3RpbmcgeWV0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUubWF5YmVSZWNvbm5lY3RPbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgaWYgKCF0aGlzLnJlY29ubmVjdGluZyAmJiB0aGlzLl9yZWNvbm5lY3Rpb24gJiYgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG4gICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQgYHNvY2tldGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9uYWwsIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9wZW4gPVxuTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChmbiwgb3B0cykge1xuICBkZWJ1ZygncmVhZHlTdGF0ZSAlcycsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cbiAgZGVidWcoJ29wZW5pbmcgJXMnLCB0aGlzLnVyaSk7XG4gIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTtcblxuICAvLyBlbWl0IGBvcGVuYFxuICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbm9wZW4oKTtcbiAgICBmbiAmJiBmbigpO1xuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X2Vycm9yYFxuICB2YXIgZXJyb3JTdWIgPSBvbihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGVidWcoJ2Nvbm5lY3RfZXJyb3InKTtcbiAgICBzZWxmLmNsZWFudXAoKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIGZuKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X3RpbWVvdXRgXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuXG4gICAgLy8gc2V0IHRpbWVyXG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuICAgICAgb3BlblN1Yi5kZXN0cm95KCk7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsICd0aW1lb3V0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfdGltZW91dCcsIHRpbWVvdXQpO1xuICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5zdWJzLnB1c2gob3BlblN1Yik7XG4gIHRoaXMuc3Vicy5wdXNoKGVycm9yU3ViKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnb3BlbicpO1xuXG4gIC8vIGNsZWFyIG9sZCBzdWJzXG4gIHRoaXMuY2xlYW51cCgpO1xuXG4gIC8vIG1hcmsgYXMgb3BlblxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIGFkZCBuZXcgc3Vic1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncG9uZycsIGJpbmQodGhpcywgJ29ucG9uZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Vycm9yJywgYmluZCh0aGlzLCAnb25lcnJvcicpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBpbmcuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25waW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxhc3RQaW5nID0gbmV3IERhdGUoKTtcbiAgdGhpcy5lbWl0QWxsKCdwaW5nJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0QWxsKCdwb25nJywgbmV3IERhdGUoKSAtIHRoaXMubGFzdFBpbmcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGVjb2RlZCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5lbWl0QWxsKCdlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG4gKlxuICogQHJldHVybiB7U29ja2V0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5zb2NrZXQgPSBmdW5jdGlvbiAobnNwLCBvcHRzKSB7XG4gIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcbiAgaWYgKCFzb2NrZXQpIHtcbiAgICBzb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMsIG5zcCwgb3B0cyk7XG4gICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNvY2tldC5vbignY29ubmVjdGluZycsIG9uQ29ubmVjdGluZyk7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgc29ja2V0LmlkID0gc2VsZi5lbmdpbmUuaWQ7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5hdXRvQ29ubmVjdCkge1xuICAgICAgLy8gbWFudWFsbHkgY2FsbCBoZXJlIHNpbmNlIGNvbm5lY3RpbmcgZXZuZXQgaXMgZmlyZWQgYmVmb3JlIGxpc3RlbmluZ1xuICAgICAgb25Db25uZWN0aW5nKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0aW5nICgpIHtcbiAgICBpZiAoIX5pbmRleE9mKHNlbGYuY29ubmVjdGluZywgc29ja2V0KSkge1xuICAgICAgc2VsZi5jb25uZWN0aW5nLnB1c2goc29ja2V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc29ja2V0O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNvY2tldCBjbG9zZS5cbiAqXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLmNvbm5lY3RpbmcsIHNvY2tldCk7XG4gIGlmICh+aW5kZXgpIHRoaXMuY29ubmVjdGluZy5zcGxpY2UoaW5kZXgsIDEpO1xuICBpZiAodGhpcy5jb25uZWN0aW5nLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHRoaXMuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgZGVidWcoJ3dyaXRpbmcgcGFja2V0ICVqJywgcGFja2V0KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAocGFja2V0LnF1ZXJ5ICYmIHBhY2tldC50eXBlID09PSAwKSBwYWNrZXQubnNwICs9ICc/JyArIHBhY2tldC5xdWVyeTtcblxuICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcbiAgICAvLyBlbmNvZGUsIHRoZW4gd3JpdGUgdG8gZW5naW5lIHdpdGggcmVzdWx0XG4gICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG4gICAgdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uIChlbmNvZGVkUGFja2V0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgc2VsZi5lbmNvZGluZyA9IGZhbHNlO1xuICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHsgLy8gYWRkIHBhY2tldCB0byB0aGUgcXVldWVcbiAgICBzZWxmLnBhY2tldEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cbn07XG5cbi8qKlxuICogSWYgcGFja2V0IGJ1ZmZlciBpcyBub24tZW1wdHksIGJlZ2lucyBlbmNvZGluZyB0aGVcbiAqIG5leHQgcGFja2V0IGluIGxpbmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1BhY2tldFF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcbiAgICB0aGlzLnBhY2tldChwYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuXG4gIHZhciBzdWJzTGVuZ3RoID0gdGhpcy5zdWJzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCk7XG4gICAgc3ViLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cbiAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlID1cbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdkaXNjb25uZWN0Jyk7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGBvbmNsb3NlYCB3aWxsIG5vdCBmaXJlIGJlY2F1c2VcbiAgICAvLyBhbiBvcGVuIGV2ZW50IG5ldmVyIGhhcHBlbmVkXG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICBpZiAodGhpcy5lbmdpbmUpIHRoaXMuZW5naW5lLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBkZWJ1Zygnb25jbG9zZScpO1xuXG4gIHRoaXMuY2xlYW51cCgpO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24pO1xuXG4gIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnJlY29ubmVjdGluZyB8fCB0aGlzLnNraXBSZWNvbm5lY3QpIHJldHVybiB0aGlzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgZGVidWcoJ3JlY29ubmVjdCBmYWlsZWQnKTtcbiAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdF9mYWlsZWQnKTtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBkZWxheSA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuICAgIGRlYnVnKCd3aWxsIHdhaXQgJWRtcyBiZWZvcmUgcmVjb25uZWN0IGF0dGVtcHQnLCBkZWxheSk7XG5cbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIGRlYnVnKCdhdHRlbXB0aW5nIHJlY29ubmVjdCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfYXR0ZW1wdCcsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdGluZycsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG5cbiAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBzZWxmLm9wZW4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBhdHRlbXB0IGVycm9yJyk7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3Qgc3VjY2VzcycpO1xuICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZGVsYXkpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXR0ZW1wdCA9IHRoaXMuYmFja29mZi5hdHRlbXB0cztcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMudXBkYXRlU29ja2V0SWRzKCk7XG4gIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0JywgYXR0ZW1wdCk7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1e1f\n")},"1ed2":function(module,exports){eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = '' + str;\n  if (str.length > 10000) return;\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMWVkMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/NDg1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKXtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdmFsKSByZXR1cm4gcGFyc2UodmFsKTtcbiAgcmV0dXJuIG9wdGlvbnMubG9uZ1xuICAgID8gbG9uZyh2YWwpXG4gICAgOiBzaG9ydCh2YWwpO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9ICcnICsgc3RyO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMDAwKSByZXR1cm47XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgaWYgKG1zID49IGgpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIGlmIChtcyA+PSBtKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICBpZiAobXMgPj0gcykgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpXG4gICAgfHwgcGx1cmFsKG1zLCBoLCAnaG91cicpXG4gICAgfHwgcGx1cmFsKG1zLCBtLCAnbWludXRlJylcbiAgICB8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKVxuICAgIHx8IG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHJldHVybjtcbiAgaWYgKG1zIDwgbiAqIDEuNSkgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1ed2\n")},"23b1":function(module,exports,__webpack_require__){eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug.debug = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"0b10\");\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting\n    args = exports.formatArgs.apply(self, args);\n\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/[\\\\^$+?.()|[\\]{}]/g, '\\\\$&').replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjNiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZGVidWcvZGVidWcuanM/NjMxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWcuZGVidWcgPSBkZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXJjYXNlZCBsZXR0ZXIsIGkuZS4gXCJuXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXNseSBhc3NpZ25lZCBjb2xvci5cbiAqL1xuXG52YXIgcHJldkNvbG9yID0gMDtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcigpIHtcbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW3ByZXZDb2xvcisrICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVidWcobmFtZXNwYWNlKSB7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZGlzYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZGlzYWJsZWQoKSB7XG4gIH1cbiAgZGlzYWJsZWQuZW5hYmxlZCA9IGZhbHNlO1xuXG4gIC8vIGRlZmluZSB0aGUgYGVuYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZW5hYmxlZCgpIHtcblxuICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gYWRkIHRoZSBgY29sb3JgIGlmIG5vdCBzZXRcbiAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgIGlmIChudWxsID09IHNlbGYuY29sb3IgJiYgc2VsZi51c2VDb2xvcnMpIHNlbGYuY29sb3IgPSBzZWxlY3RDb2xvcigpO1xuXG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVvXG4gICAgICBhcmdzID0gWyclbyddLmNvbmNhdChhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16JV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmdcbiAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZW5hYmxlZC5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuICBlbmFibGVkLmVuYWJsZWQgPSB0cnVlO1xuXG4gIHZhciBmbiA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpID8gZW5hYmxlZCA6IGRpc2FibGVkO1xuXG4gIGZuLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgdmFyIHNwbGl0ID0gKG5hbWVzcGFjZXMgfHwgJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9bXFxcXF4kKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJykucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///23b1\n")},"2dce":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * Module requirements.\n */\n\nvar Polling = __webpack_require__(/*! ./polling */ \"181d\");\nvar inherit = __webpack_require__(/*! component-inherit */ \"42bf\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = JSONPPolling;\n\n/**\n * Cached regular expressions.\n */\n\nvar rNewline = /\\n/g;\nvar rEscapedNewline = /\\\\n/g;\n\n/**\n * Global JSONP callbacks.\n */\n\nvar callbacks;\n\n/**\n * Noop.\n */\n\nfunction empty () { }\n\n/**\n * JSONP Polling constructor.\n *\n * @param {Object} opts.\n * @api public\n */\n\nfunction JSONPPolling (opts) {\n  Polling.call(this, opts);\n\n  this.query = this.query || {};\n\n  // define global callbacks array if not present\n  // we do this here (lazily) to avoid unneeded global pollution\n  if (!callbacks) {\n    // we need to consider multiple engines in the same page\n    if (!global.___eio) global.___eio = [];\n    callbacks = global.___eio;\n  }\n\n  // callback identifier\n  this.index = callbacks.length;\n\n  // add callback to jsonp global\n  var self = this;\n  callbacks.push(function (msg) {\n    self.onData(msg);\n  });\n\n  // append to query string\n  this.query.j = this.index;\n\n  // prevent spurious errors from being emitted when the window is unloaded\n  if (global.document && global.addEventListener) {\n    global.addEventListener('beforeunload', function () {\n      if (self.script) self.script.onerror = empty;\n    }, false);\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(JSONPPolling, Polling);\n\n/*\n * JSONP only supports binary as base64 encoded strings\n */\n\nJSONPPolling.prototype.supportsBinary = false;\n\n/**\n * Closes the socket.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doClose = function () {\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  if (this.form) {\n    this.form.parentNode.removeChild(this.form);\n    this.form = null;\n    this.iframe = null;\n  }\n\n  Polling.prototype.doClose.call(this);\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doPoll = function () {\n  var self = this;\n  var script = document.createElement('script');\n\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  script.async = true;\n  script.src = this.uri();\n  script.onerror = function (e) {\n    self.onError('jsonp poll error', e);\n  };\n\n  var insertAt = document.getElementsByTagName('script')[0];\n  if (insertAt) {\n    insertAt.parentNode.insertBefore(script, insertAt);\n  } else {\n    (document.head || document.body).appendChild(script);\n  }\n  this.script = script;\n\n  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);\n\n  if (isUAgecko) {\n    setTimeout(function () {\n      var iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n      document.body.removeChild(iframe);\n    }, 100);\n  }\n};\n\n/**\n * Writes with a hidden iframe.\n *\n * @param {String} data to send\n * @param {Function} called upon flush.\n * @api private\n */\n\nJSONPPolling.prototype.doWrite = function (data, fn) {\n  var self = this;\n\n  if (!this.form) {\n    var form = document.createElement('form');\n    var area = document.createElement('textarea');\n    var id = this.iframeId = 'eio_iframe_' + this.index;\n    var iframe;\n\n    form.className = 'socketio';\n    form.style.position = 'absolute';\n    form.style.top = '-1000px';\n    form.style.left = '-1000px';\n    form.target = id;\n    form.method = 'POST';\n    form.setAttribute('accept-charset', 'utf-8');\n    area.name = 'd';\n    form.appendChild(area);\n    document.body.appendChild(form);\n\n    this.form = form;\n    this.area = area;\n  }\n\n  this.form.action = this.uri();\n\n  function complete () {\n    initIframe();\n    fn();\n  }\n\n  function initIframe () {\n    if (self.iframe) {\n      try {\n        self.form.removeChild(self.iframe);\n      } catch (e) {\n        self.onError('jsonp polling iframe removal error', e);\n      }\n    }\n\n    try {\n      // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n      var html = '<iframe src=\"javascript:0\" name=\"' + self.iframeId + '\">';\n      iframe = document.createElement(html);\n    } catch (e) {\n      iframe = document.createElement('iframe');\n      iframe.name = self.iframeId;\n      iframe.src = 'javascript:0';\n    }\n\n    iframe.id = self.iframeId;\n\n    self.form.appendChild(iframe);\n    self.iframe = iframe;\n  }\n\n  initIframe();\n\n  // escape \\n to prevent it from being converted into \\r\\n by some UAs\n  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side\n  data = data.replace(rEscapedNewline, '\\\\\\n');\n  this.area.value = data.replace(rNewline, '\\\\n');\n\n  try {\n    this.form.submit();\n  } catch (e) {}\n\n  if (this.iframe.attachEvent) {\n    this.iframe.onreadystatechange = function () {\n      if (self.iframe.readyState === 'complete') {\n        complete();\n      }\n    };\n  } else {\n    this.iframe.onload = complete;\n  }\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"698d\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMmRjZS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLWpzb25wLmpzP2RmZDYiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblxuLyoqXG4gKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAqL1xuXG52YXIgck5ld2xpbmUgPSAvXFxuL2c7XG52YXIgckVzY2FwZWROZXdsaW5lID0gL1xcXFxuL2c7XG5cbi8qKlxuICogR2xvYmFsIEpTT05QIGNhbGxiYWNrcy5cbiAqL1xuXG52YXIgY2FsbGJhY2tzO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkgeyB9XG5cbi8qKlxuICogSlNPTlAgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gSlNPTlBQb2xsaW5nIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblxuICAvLyBkZWZpbmUgZ2xvYmFsIGNhbGxiYWNrcyBhcnJheSBpZiBub3QgcHJlc2VudFxuICAvLyB3ZSBkbyB0aGlzIGhlcmUgKGxhemlseSkgdG8gYXZvaWQgdW5uZWVkZWQgZ2xvYmFsIHBvbGx1dGlvblxuICBpZiAoIWNhbGxiYWNrcykge1xuICAgIC8vIHdlIG5lZWQgdG8gY29uc2lkZXIgbXVsdGlwbGUgZW5naW5lcyBpbiB0aGUgc2FtZSBwYWdlXG4gICAgaWYgKCFnbG9iYWwuX19fZWlvKSBnbG9iYWwuX19fZWlvID0gW107XG4gICAgY2FsbGJhY2tzID0gZ2xvYmFsLl9fX2VpbztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGlkZW50aWZpZXJcbiAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgLy8gYWRkIGNhbGxiYWNrIHRvIGpzb25wIGdsb2JhbFxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcbiAgICBzZWxmLm9uRGF0YShtc2cpO1xuICB9KTtcblxuICAvLyBhcHBlbmQgdG8gcXVlcnkgc3RyaW5nXG4gIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cbiAgLy8gcHJldmVudCBzcHVyaW91cyBlcnJvcnMgZnJvbSBiZWluZyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBpcyB1bmxvYWRlZFxuICBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLnNjcmlwdCkgc2VsZi5zY3JpcHQub25lcnJvciA9IGVtcHR5O1xuICAgIH0sIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KEpTT05QUG9sbGluZywgUG9sbGluZyk7XG5cbi8qXG4gKiBKU09OUCBvbmx5IHN1cHBvcnRzIGJpbmFyeSBhcyBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXG4vKipcbiAqIENsb3NlcyB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMuZm9ybSkge1xuICAgIHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7XG4gICAgdGhpcy5mb3JtID0gbnVsbDtcbiAgICB0aGlzLmlmcmFtZSA9IG51bGw7XG4gIH1cblxuICBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIHNjcmlwdC5zcmMgPSB0aGlzLnVyaSgpO1xuICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsIGVycm9yJywgZSk7XG4gIH07XG5cbiAgdmFyIGluc2VydEF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICBpZiAoaW5zZXJ0QXQpIHtcbiAgICBpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIGluc2VydEF0KTtcbiAgfSBlbHNlIHtcbiAgICAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9XG4gIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuXG4gIHZhciBpc1VBZ2Vja28gPSAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG5hdmlnYXRvciAmJiAvZ2Vja28vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4gIGlmIChpc1VBZ2Vja28pIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICB9LCAxMDApO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyB3aXRoIGEgaGlkZGVuIGlmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgICB2YXIgYXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdmFyIGlkID0gdGhpcy5pZnJhbWVJZCA9ICdlaW9faWZyYW1lXycgKyB0aGlzLmluZGV4O1xuICAgIHZhciBpZnJhbWU7XG5cbiAgICBmb3JtLmNsYXNzTmFtZSA9ICdzb2NrZXRpbyc7XG4gICAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZm9ybS5zdHlsZS50b3AgPSAnLTEwMDBweCc7XG4gICAgZm9ybS5zdHlsZS5sZWZ0ID0gJy0xMDAwcHgnO1xuICAgIGZvcm0udGFyZ2V0ID0gaWQ7XG4gICAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2FjY2VwdC1jaGFyc2V0JywgJ3V0Zi04Jyk7XG4gICAgYXJlYS5uYW1lID0gJ2QnO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgIHRoaXMuZm9ybSA9IGZvcm07XG4gICAgdGhpcy5hcmVhID0gYXJlYTtcbiAgfVxuXG4gIHRoaXMuZm9ybS5hY3Rpb24gPSB0aGlzLnVyaSgpO1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlICgpIHtcbiAgICBpbml0SWZyYW1lKCk7XG4gICAgZm4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJZnJhbWUgKCkge1xuICAgIGlmIChzZWxmLmlmcmFtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi5mb3JtLnJlbW92ZUNoaWxkKHNlbGYuaWZyYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsaW5nIGlmcmFtZSByZW1vdmFsIGVycm9yJywgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgICAgdmFyIGh0bWwgPSAnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiBuYW1lPVwiJyArIHNlbGYuaWZyYW1lSWQgKyAnXCI+JztcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaHRtbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBpZnJhbWUubmFtZSA9IHNlbGYuaWZyYW1lSWQ7XG4gICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6MCc7XG4gICAgfVxuXG4gICAgaWZyYW1lLmlkID0gc2VsZi5pZnJhbWVJZDtcblxuICAgIHNlbGYuZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHNlbGYuaWZyYW1lID0gaWZyYW1lO1xuICB9XG5cbiAgaW5pdElmcmFtZSgpO1xuXG4gIC8vIGVzY2FwZSBcXG4gdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGNvbnZlcnRlZCBpbnRvIFxcclxcbiBieSBzb21lIFVBc1xuICAvLyBkb3VibGUgZXNjYXBpbmcgaXMgcmVxdWlyZWQgZm9yIGVzY2FwZWQgbmV3IGxpbmVzIGJlY2F1c2UgdW5lc2NhcGluZyBvZiBuZXcgbGluZXMgY2FuIGJlIGRvbmUgc2FmZWx5IG9uIHNlcnZlci1zaWRlXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UockVzY2FwZWROZXdsaW5lLCAnXFxcXFxcbicpO1xuICB0aGlzLmFyZWEudmFsdWUgPSBkYXRhLnJlcGxhY2Uock5ld2xpbmUsICdcXFxcbicpO1xuXG4gIHRyeSB7XG4gICAgdGhpcy5mb3JtLnN1Ym1pdCgpO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIGlmICh0aGlzLmlmcmFtZS5hdHRhY2hFdmVudCkge1xuICAgIHRoaXMuaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmlmcmFtZS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZTtcbiAgfVxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2dce\n")},3902:function(module,exports,__webpack_require__){eval("/**\n * Base class\n *\n * Implements unique ID per instance. It is set once, and can not be updated.\n * An ID is generated during initialization; however it is included in the (de-)serializing of the object.\n * @class Base\n */\nvar AmpersandModel = __webpack_require__(/*! ampersand-model */ \"3bfc\");\n\n// see discussion here: https://gist.github.com/gordonbrander/2230317\nfunction uniqueID () {\n  function chr4 () {\n    return Math.random().toString(16).slice(-4);\n  }\n  return chr4() + chr4() +\n    '-' + chr4() +\n    '-' + chr4() +\n    '-' + chr4() +\n    '-' + chr4() + chr4() + chr4();\n}\n\nmodule.exports = AmpersandModel.extend({\n  props: {\n    /**\n     * Unique ID for this class\n     * @memberof! Base\n     * @readonly\n     * @type {ID}\n     */\n    id: {\n      type: 'string',\n      default: function () {\n        return uniqueID();\n      },\n      setonce: true\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkwMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvdXRpbC9iYXNlLmpzP2NlYTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBCYXNlIGNsYXNzXG4gKlxuICogSW1wbGVtZW50cyB1bmlxdWUgSUQgcGVyIGluc3RhbmNlLiBJdCBpcyBzZXQgb25jZSwgYW5kIGNhbiBub3QgYmUgdXBkYXRlZC5cbiAqIEFuIElEIGlzIGdlbmVyYXRlZCBkdXJpbmcgaW5pdGlhbGl6YXRpb247IGhvd2V2ZXIgaXQgaXMgaW5jbHVkZWQgaW4gdGhlIChkZS0pc2VyaWFsaXppbmcgb2YgdGhlIG9iamVjdC5cbiAqIEBjbGFzcyBCYXNlXG4gKi9cbnZhciBBbXBlcnNhbmRNb2RlbCA9IHJlcXVpcmUoJ2FtcGVyc2FuZC1tb2RlbCcpO1xuXG4vLyBzZWUgZGlzY3Vzc2lvbiBoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9nb3Jkb25icmFuZGVyLzIyMzAzMTdcbmZ1bmN0aW9uIHVuaXF1ZUlEICgpIHtcbiAgZnVuY3Rpb24gY2hyNCAoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpLnNsaWNlKC00KTtcbiAgfVxuICByZXR1cm4gY2hyNCgpICsgY2hyNCgpICtcbiAgICAnLScgKyBjaHI0KCkgK1xuICAgICctJyArIGNocjQoKSArXG4gICAgJy0nICsgY2hyNCgpICtcbiAgICAnLScgKyBjaHI0KCkgKyBjaHI0KCkgKyBjaHI0KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQW1wZXJzYW5kTW9kZWwuZXh0ZW5kKHtcbiAgcHJvcHM6IHtcbiAgICAvKipcbiAgICAgKiBVbmlxdWUgSUQgZm9yIHRoaXMgY2xhc3NcbiAgICAgKiBAbWVtYmVyb2YhIEJhc2VcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7SUR9XG4gICAgICovXG4gICAgaWQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdW5pcXVlSUQoKTtcbiAgICAgIH0sXG4gICAgICBzZXRvbmNlOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3902\n")},"3b07":function(module,exports,__webpack_require__){eval("/**\n * Main spot object.\n *\n * @class Spot\n */\nvar BaseModel = __webpack_require__(/*! ./util/base */ \"3902\");\nvar Dataview = __webpack_require__(/*! ./dataview */ \"5066\");\nvar Datasets = __webpack_require__(/*! ./dataset/collection */ \"544d\");\nvar driverClient = __webpack_require__(/*! ./driver/client */ \"720c\");\nvar driverServer = __webpack_require__(/*! ./driver/server */ \"072d\");\nvar utildx = __webpack_require__(/*! ./util/crossfilter */ \"adfa\");\nvar timeUtil = __webpack_require__(/*! ./util/time */ \"d45b\");\nvar io = __webpack_require__(/*! socket.io-client */ \"b452\");\n\n/**\n * Connect to the spot-server using a websocket and setup callbacks\n *\n * @function\n * @param {address} Optional. IP address and port number to connect to. fi.  'http://localhost:3000'\n *\n * @memberof! Spot\n */\nfunction connectToServer (address) {\n  var me = this;\n  var socket;\n\n  if (address) {\n    // connect to specified address\n    // necessary for when window.location is not availble (node.js)\n    socket = io.connect(address);\n  } else {\n    // Use socket.io fallback to autodetect address\n    // ie. when a website wants to connect, use the window.location\n    socket = io.connect();\n  }\n\n  socket.on('connect', function () {\n    me.isConnected = true;\n    console.log('Connected to server');\n  });\n\n  socket.on('disconnect', function () {\n    me.isConnected = false;\n  });\n\n  socket.on('syncDatasets', function (req) {\n    // do an incremental update, as we typically start without datasets\n    me.datasets.add(req.data, { merge: true });\n  });\n\n  socket.on('syncDataview', function (req) {\n    me.dataview.reset(req.data);\n  });\n\n  socket.on('syncFacets', function (req) {\n    // do an incremental update, as we typically update only a few properties of a facet\n    // Also, a full reset will orphan the view.model objects in spot-app (ie. crashes)\n    var dataset = me.datasets.get(req.datasetId);\n    dataset.facets.add(req.data, { merge: true });\n\n    me.resetDataview(); // NOTE: the cached (serialized) datasets need to be updated, too\n\n    dataset.trigger('syncFacets');\n  });\n\n  socket.on('newData', function (req) {\n    var filter = me.dataview.filters.get(req.filterId);\n    if (req.data) {\n      filter.data = req.data;\n\n      // for text filters, rebuild partition and count\n      filter.partitions.forEach(function (partition, p) {\n        var columnToName = {1: 'a', 2: 'b', 3: 'c', 4: 'd'};\n\n        if (partition.isText) {\n          partition.groups.reset(null, {silent: true});\n          filter.data.forEach(function (d) {\n            var count = (parseFloat(d.aa) || parseInt(d.count)) || 0;\n\n            if (count) {\n              partition.groups.add({\n                min: 0,\n                max: 100,\n                count: count,\n                label: d[columnToName[(p + 1)]],\n                value: d[columnToName[(p + 1)]]\n              }, {silent: true});\n            }\n          });\n          partition.groups.sort();\n        }\n      });\n      filter.trigger('newData');\n    }\n  });\n\n  socket.on('newMetaData', function (req) {\n    me.dataview.dataTotal = parseInt(req.dataTotal);\n    me.dataview.dataSelected = parseInt(req.dataSelected);\n    console.timeEnd('Get data');\n    me.dataview.trigger('newMetaData');\n  });\n\n  socket.connect();\n  me.socket = socket;\n}\n\n/**\n * Disconnect from the spot-server\n *\n * @function\n * @memberof! Spot\n */\nfunction disconnectFromServer () {\n  this.socket.disconnect();\n}\n\n/**\n * Request a list of available datasets from the server\n *\n * Depending on the driver, this can be an asyncrhonous function.\n * It returns a Promise that resolves to the dataset collection\n *\n * @function\n * @returns {Promise}\n *\n * @memberof! Spot\n */\nfunction getDatasets () {\n  var me = this;\n\n  return new Promise(function (resolve, reject) {\n    me.socket.emit('getDatasets');\n\n    me.datasets.once('reset', function () {\n      resolve(me.datasets);\n    });\n  });\n}\n\n/**\n * Reset min, max, and categories for all facets in the dataview\n *\n * @param {Spot} me Main spot instance\n *\n * @memberof! Spot\n */\nfunction resetDataview () {\n  var toSerialize = [];\n\n  // Update list of active datasets, and serialize the datasets parts we need to send on getData requests\n  this.dataview.datasetIds = [];\n  this.datasets.forEach(function (dataset) {\n    if (dataset.isActive) {\n      // BUGFIX: the list of datasetIds can get out of sync when using spot-server. Just recreate it always.\n      this.dataview.datasetIds.push(dataset.getId());\n      toSerialize.push(dataset.toJSON()); // TODO: only serialize used facets?\n    }\n  }, this);\n  this.cachedDatasets = JSON.stringify(toSerialize);\n\n  // rescan min/max values and categories for the newly added facets\n  this.dataview.facets.forEach(function (facet) {\n    var newFacet = this.dataview.facets.get(facet.name, 'name');\n\n    if (newFacet.isContinuous || newFacet.isDatetime || newFacet.isDuration) {\n      this.setFacetMinMax(facet);\n    } else if (newFacet.isCategorial) {\n      this.setFacetCategories(facet);\n    }\n  }, this);\n}\n\n/*\n * Add or remove facets from a dataset to the global (merged) dataset\n *\n * @memberof! Spot\n * @param {Spot} me Main spot instance\n * @param {Dataset} dataset Dataset set add or remove\n */\nfunction toggleDatasetFacets (me, dataset) {\n  if (dataset.isActive) {\n    // remove active facets in dataset from the global dataset...\n    dataset.facets.forEach(function (facet) {\n      if (!facet.isActive) {\n        return;\n      }\n\n      // ...but only when no other active dataset contains it\n      var facetIsUnique = true;\n      me.datasets.forEach(function (otherDataset) {\n        if (!otherDataset.isActive || otherDataset === dataset) {\n          return;\n        }\n        if (otherDataset.facets.get(facet.name, 'name')) {\n          facetIsUnique = false;\n        }\n      });\n      if (facetIsUnique) {\n        var toRemove = me.dataview.facets.get(facet.name, 'name');\n        me.dataview.facets.remove(toRemove);\n      }\n    });\n  } else if (!dataset.isActive) {\n    // copy facets\n    dataset.facets.forEach(function (facet) {\n      // do nothing if facet is not active\n      if (!facet.isActive) {\n        return;\n      }\n\n      // default options for all facet types\n      var options = {\n        name: facet.name,\n        accessor: facet.name,\n        description: facet.description,\n        type: facet.transform.transformedType,\n        units: facet.units, // TODO: transformed units?\n        isActive: true\n      };\n\n      // do not add if a similar facet already exists\n      if (!me.dataview.facets.get(facet.name, 'name')) {\n        me.dataview.facets.add(options);\n      }\n    });\n  }\n}\n\n/*\n * Add or remove data from a dataset to the global (merged) dataset\n *\n * @memberof! Spot\n * @param {Spot} me Main spot instance\n * @param {Dataset} dataset Dataset set add or remove\n */\nfunction toggleDatasetData (me, dataset) {\n  if (dataset.isActive) {\n    // if dataset is active, remove it:\n    // ...clear all crossfilter filters\n    me.dataview.filters.forEach(function (filter) {\n      // BUGFIX: when loading sessions, the dataset is not initialized properly\n      // so check for it to be sure\n      if (filter.dimension) {\n        filter.dimension.filterAll();\n      }\n    });\n\n    // ...filter all data, originating from the dataset from the dataset\n    var dimension = me.dataview.crossfilter.dimension(function (d) {\n      return d._OriginalDatasetId;\n    });\n    dimension.filter(dataset.getId());\n\n    // ...remove matching data\n    me.dataview.crossfilter.remove();\n\n    // ...restore original filters\n    dimension.filterAll();\n    dimension.dispose();\n    me.dataview.filters.forEach(function (filter) {\n      filter.updateDataFilter();\n    });\n  } else if (!dataset.isActive) {\n    // if dataset is not active, add it\n    // ...find facets to copy\n    var dataTransforms = [];\n    dataset.facets.forEach(function (facet) {\n      // do nothing if facet is not active\n      if (!facet.isActive) {\n        return;\n      }\n      dataTransforms.push({\n        key: facet.name,\n        fn: utildx.valueFn(facet)\n      });\n    });\n\n    // ...transform data\n    var data = dataset.data;\n    var transformedData = [];\n\n    data.forEach(function (datum) {\n      var transformedDatum = {};\n      dataTransforms.forEach(function (transform) {\n        transformedDatum[transform.key] = transform.fn(datum);\n      });\n      transformedDatum._OriginalDatasetId = dataset.getId();\n      transformedData.push(transformedDatum);\n    });\n\n    // ...add to merged dataset\n    me.dataview.crossfilter.add(transformedData);\n  }\n\n  // update counts\n  me.dataview.dataTotal = me.dataview.crossfilter.size();\n  me.dataview.dataSelected = me.dataview.countGroup.value();\n}\n\n/**\n * Add or remove a dataset from the dataview\n * @param {Dataset} dataset Dataset set add or remove\n *\n * @function\n * @memberof! Spot\n */\nfunction toggleDataset (dataset) {\n  if (this.sessionType === 'server') {\n    toggleDatasetFacets(this, dataset);\n  } else if (this.sessionType === 'client') {\n    // release all filters\n    this.dataview.filters.forEach(function (filter) {\n      filter.releaseDataFilter();\n    });\n\n    // manually merge the datasets\n    toggleDatasetFacets(this, dataset);\n    toggleDatasetData(this, dataset);\n  }\n\n  dataset.isActive = !dataset.isActive;\n\n  this.resetDataview();\n}\n\nfunction setFacetMinMax (facet) {\n  // This should work for all kinds of facets:\n  // numbers, durations, and datatimes all implement the relevant operations\n  var datasets = this.datasets;\n\n  var first = true;\n  datasets.forEach(function (dataset) {\n    if (dataset.isActive) {\n      var subFacet = dataset.facets.get(facet.name, 'name');\n      if (first) {\n        facet.minvalAsText = subFacet.transform.transformedMinAsText;\n        facet.maxvalAsText = subFacet.transform.transformedMaxAsText;\n        first = false;\n      } else {\n        if (subFacet.minval < facet.minval) {\n          facet.minvalAsText = subFacet.transform.transformedMinAsText;\n        }\n        if (subFacet.maxval > facet.maxval) {\n          facet.maxvalAsText = subFacet.transform.transformedMaxAsText;\n        }\n      }\n    }\n  });\n}\n\nfunction setFacetCategories (facet) {\n  var datasets = this.datasets;\n\n  facet.categorialTransform.reset();\n\n  // get categories by combining the sets for the separate datasets\n  datasets.forEach(function (dataset) {\n    if (dataset.isActive) {\n      var subFacet = dataset.facets.get(facet.name, 'name');\n\n      if (subFacet.isCategorial) {\n        // merge rules from subFacet into those of Facet\n        subFacet.categorialTransform.rules.forEach(function (rule) {\n          var newRule = facet.categorialTransform.rules.get(rule.expression, 'expression');\n          if (newRule) {\n            newRule.count += rule.count;\n          } else {\n            facet.categorialTransform.rules.add(rule.toJSON());\n          }\n        });\n      } else if (subFacet.isDatetime) {\n        var expressions = timeUtil.timeParts.get(subFacet.datetimeTransform.transformedFormat, 'description').groups;\n        expressions.forEach(function (expression) {\n          var newRule = facet.categorialTransform.rules.get(expression, 'expression');\n          if (newRule) {\n            // no-op: category exist and we don't have a proper count\n          } else {\n            facet.categorialTransform.rules.add({\n              expression: expression,\n              count: 0,\n              group: expression\n            });\n          }\n        });\n      }\n    }\n  });\n}\n\nmodule.exports = BaseModel.extend({\n  type: 'user',\n  props: {\n    /**\n     * Is there a connection with a spot sever?\n     * @memberof! Spot\n     * @type {boolean}\n     */\n    isConnected: ['boolean', true, false],\n    /**\n     * When the app in locked down, facets and datasets cannot be edited\n     * @memberof! Spot\n     * @type {boolean}\n     */\n    isLockedDown: ['boolean', true, false],\n    /**\n     * Type of spot session. Must be 'client' or 'server'\n     * @memberof! Spot\n     * @type {string}\n     */\n    sessionType: {\n      type: 'string',\n      required: true,\n      default: 'client',\n      values: ['client', 'server'],\n      setOnce: true\n    }\n  },\n  children: {\n    /**\n     * A union of all active datasets\n     * @memberof! Spot\n     * @type {Dataview}\n     */\n    dataview: Dataview\n  },\n  collections: {\n    /**\n     * Collection of all datasets\n     * @memberof! Spot\n     * @type {Dataset[]}\n     */\n    datasets: Datasets\n  },\n  initialize: function () {\n    // first do parent class initialization\n    BaseModel.prototype.initialize.apply(this, arguments);\n\n    // default to client side (crossfilter) sessions\n    this.driver = driverClient;\n\n    // assign backend driver\n    if (arguments && arguments[0] && arguments[0].sessionType) {\n      if (arguments[0].sessionType === 'client') {\n        this.driver = driverClient;\n      } else if (arguments[0].sessionType === 'server') {\n        this.driver = driverServer;\n      } else {\n        console.error('No driver for type', arguments[0].sessionType);\n      }\n    }\n  },\n  resetDataview: resetDataview,\n  connectToServer: connectToServer,\n  disconnectFromServer: disconnectFromServer,\n  getDatasets: getDatasets,\n  setFacetMinMax: setFacetMinMax,\n  setFacetCategories: setFacetCategories,\n  toggleDataset: toggleDataset\n});\n\nmodule.exports.util = {\n  dx: utildx,\n  misval: __webpack_require__(/*! ./util/misval */ \"bff6\"),\n  time: timeUtil\n};\n\nmodule.exports.transforms = {\n  categorial: __webpack_require__(/*! ./facet/categorial-transform */ \"9b75\"),\n  continuous: __webpack_require__(/*! ./facet/continuous-transform */ \"5a80\"),\n  datetime: __webpack_require__(/*! ./facet/datetime-transform */ \"a0ca\"),\n  duration: __webpack_require__(/*! ./facet/duration-transform */ \"b123\")\n};\n\nmodule.exports.constructors = {\n  Dataview: Dataview,\n  Dataset: __webpack_require__(/*! ./dataset */ \"545a\"),\n  Datasets: Datasets\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiM2IwNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvbWUuanM/Y2NmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1haW4gc3BvdCBvYmplY3QuXG4gKlxuICogQGNsYXNzIFNwb3RcbiAqL1xudmFyIEJhc2VNb2RlbCA9IHJlcXVpcmUoJy4vdXRpbC9iYXNlJyk7XG52YXIgRGF0YXZpZXcgPSByZXF1aXJlKCcuL2RhdGF2aWV3Jyk7XG52YXIgRGF0YXNldHMgPSByZXF1aXJlKCcuL2RhdGFzZXQvY29sbGVjdGlvbicpO1xudmFyIGRyaXZlckNsaWVudCA9IHJlcXVpcmUoJy4vZHJpdmVyL2NsaWVudCcpO1xudmFyIGRyaXZlclNlcnZlciA9IHJlcXVpcmUoJy4vZHJpdmVyL3NlcnZlcicpO1xudmFyIHV0aWxkeCA9IHJlcXVpcmUoJy4vdXRpbC9jcm9zc2ZpbHRlcicpO1xudmFyIHRpbWVVdGlsID0gcmVxdWlyZSgnLi91dGlsL3RpbWUnKTtcbnZhciBpbyA9IHJlcXVpcmUoJ3NvY2tldC5pby1jbGllbnQnKTtcblxuLyoqXG4gKiBDb25uZWN0IHRvIHRoZSBzcG90LXNlcnZlciB1c2luZyBhIHdlYnNvY2tldCBhbmQgc2V0dXAgY2FsbGJhY2tzXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge2FkZHJlc3N9IE9wdGlvbmFsLiBJUCBhZGRyZXNzIGFuZCBwb3J0IG51bWJlciB0byBjb25uZWN0IHRvLiBmaS4gICdodHRwOi8vbG9jYWxob3N0OjMwMDAnXG4gKlxuICogQG1lbWJlcm9mISBTcG90XG4gKi9cbmZ1bmN0aW9uIGNvbm5lY3RUb1NlcnZlciAoYWRkcmVzcykge1xuICB2YXIgbWUgPSB0aGlzO1xuICB2YXIgc29ja2V0O1xuXG4gIGlmIChhZGRyZXNzKSB7XG4gICAgLy8gY29ubmVjdCB0byBzcGVjaWZpZWQgYWRkcmVzc1xuICAgIC8vIG5lY2Vzc2FyeSBmb3Igd2hlbiB3aW5kb3cubG9jYXRpb24gaXMgbm90IGF2YWlsYmxlIChub2RlLmpzKVxuICAgIHNvY2tldCA9IGlvLmNvbm5lY3QoYWRkcmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVXNlIHNvY2tldC5pbyBmYWxsYmFjayB0byBhdXRvZGV0ZWN0IGFkZHJlc3NcbiAgICAvLyBpZS4gd2hlbiBhIHdlYnNpdGUgd2FudHMgdG8gY29ubmVjdCwgdXNlIHRoZSB3aW5kb3cubG9jYXRpb25cbiAgICBzb2NrZXQgPSBpby5jb25uZWN0KCk7XG4gIH1cblxuICBzb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgbWUuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgdG8gc2VydmVyJyk7XG4gIH0pO1xuXG4gIHNvY2tldC5vbignZGlzY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICBtZS5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICB9KTtcblxuICBzb2NrZXQub24oJ3N5bmNEYXRhc2V0cycsIGZ1bmN0aW9uIChyZXEpIHtcbiAgICAvLyBkbyBhbiBpbmNyZW1lbnRhbCB1cGRhdGUsIGFzIHdlIHR5cGljYWxseSBzdGFydCB3aXRob3V0IGRhdGFzZXRzXG4gICAgbWUuZGF0YXNldHMuYWRkKHJlcS5kYXRhLCB7IG1lcmdlOiB0cnVlIH0pO1xuICB9KTtcblxuICBzb2NrZXQub24oJ3N5bmNEYXRhdmlldycsIGZ1bmN0aW9uIChyZXEpIHtcbiAgICBtZS5kYXRhdmlldy5yZXNldChyZXEuZGF0YSk7XG4gIH0pO1xuXG4gIHNvY2tldC5vbignc3luY0ZhY2V0cycsIGZ1bmN0aW9uIChyZXEpIHtcbiAgICAvLyBkbyBhbiBpbmNyZW1lbnRhbCB1cGRhdGUsIGFzIHdlIHR5cGljYWxseSB1cGRhdGUgb25seSBhIGZldyBwcm9wZXJ0aWVzIG9mIGEgZmFjZXRcbiAgICAvLyBBbHNvLCBhIGZ1bGwgcmVzZXQgd2lsbCBvcnBoYW4gdGhlIHZpZXcubW9kZWwgb2JqZWN0cyBpbiBzcG90LWFwcCAoaWUuIGNyYXNoZXMpXG4gICAgdmFyIGRhdGFzZXQgPSBtZS5kYXRhc2V0cy5nZXQocmVxLmRhdGFzZXRJZCk7XG4gICAgZGF0YXNldC5mYWNldHMuYWRkKHJlcS5kYXRhLCB7IG1lcmdlOiB0cnVlIH0pO1xuXG4gICAgbWUucmVzZXREYXRhdmlldygpOyAvLyBOT1RFOiB0aGUgY2FjaGVkIChzZXJpYWxpemVkKSBkYXRhc2V0cyBuZWVkIHRvIGJlIHVwZGF0ZWQsIHRvb1xuXG4gICAgZGF0YXNldC50cmlnZ2VyKCdzeW5jRmFjZXRzJyk7XG4gIH0pO1xuXG4gIHNvY2tldC5vbignbmV3RGF0YScsIGZ1bmN0aW9uIChyZXEpIHtcbiAgICB2YXIgZmlsdGVyID0gbWUuZGF0YXZpZXcuZmlsdGVycy5nZXQocmVxLmZpbHRlcklkKTtcbiAgICBpZiAocmVxLmRhdGEpIHtcbiAgICAgIGZpbHRlci5kYXRhID0gcmVxLmRhdGE7XG5cbiAgICAgIC8vIGZvciB0ZXh0IGZpbHRlcnMsIHJlYnVpbGQgcGFydGl0aW9uIGFuZCBjb3VudFxuICAgICAgZmlsdGVyLnBhcnRpdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocGFydGl0aW9uLCBwKSB7XG4gICAgICAgIHZhciBjb2x1bW5Ub05hbWUgPSB7MTogJ2EnLCAyOiAnYicsIDM6ICdjJywgNDogJ2QnfTtcblxuICAgICAgICBpZiAocGFydGl0aW9uLmlzVGV4dCkge1xuICAgICAgICAgIHBhcnRpdGlvbi5ncm91cHMucmVzZXQobnVsbCwge3NpbGVudDogdHJ1ZX0pO1xuICAgICAgICAgIGZpbHRlci5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IChwYXJzZUZsb2F0KGQuYWEpIHx8IHBhcnNlSW50KGQuY291bnQpKSB8fCAwO1xuXG4gICAgICAgICAgICBpZiAoY291bnQpIHtcbiAgICAgICAgICAgICAgcGFydGl0aW9uLmdyb3Vwcy5hZGQoe1xuICAgICAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgICAgICBtYXg6IDEwMCxcbiAgICAgICAgICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGRbY29sdW1uVG9OYW1lWyhwICsgMSldXSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZFtjb2x1bW5Ub05hbWVbKHAgKyAxKV1dXG4gICAgICAgICAgICAgIH0sIHtzaWxlbnQ6IHRydWV9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwYXJ0aXRpb24uZ3JvdXBzLnNvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBmaWx0ZXIudHJpZ2dlcignbmV3RGF0YScpO1xuICAgIH1cbiAgfSk7XG5cbiAgc29ja2V0Lm9uKCduZXdNZXRhRGF0YScsIGZ1bmN0aW9uIChyZXEpIHtcbiAgICBtZS5kYXRhdmlldy5kYXRhVG90YWwgPSBwYXJzZUludChyZXEuZGF0YVRvdGFsKTtcbiAgICBtZS5kYXRhdmlldy5kYXRhU2VsZWN0ZWQgPSBwYXJzZUludChyZXEuZGF0YVNlbGVjdGVkKTtcbiAgICBjb25zb2xlLnRpbWVFbmQoJ0dldCBkYXRhJyk7XG4gICAgbWUuZGF0YXZpZXcudHJpZ2dlcignbmV3TWV0YURhdGEnKTtcbiAgfSk7XG5cbiAgc29ja2V0LmNvbm5lY3QoKTtcbiAgbWUuc29ja2V0ID0gc29ja2V0O1xufVxuXG4vKipcbiAqIERpc2Nvbm5lY3QgZnJvbSB0aGUgc3BvdC1zZXJ2ZXJcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiEgU3BvdFxuICovXG5mdW5jdGlvbiBkaXNjb25uZWN0RnJvbVNlcnZlciAoKSB7XG4gIHRoaXMuc29ja2V0LmRpc2Nvbm5lY3QoKTtcbn1cblxuLyoqXG4gKiBSZXF1ZXN0IGEgbGlzdCBvZiBhdmFpbGFibGUgZGF0YXNldHMgZnJvbSB0aGUgc2VydmVyXG4gKlxuICogRGVwZW5kaW5nIG9uIHRoZSBkcml2ZXIsIHRoaXMgY2FuIGJlIGFuIGFzeW5jcmhvbm91cyBmdW5jdGlvbi5cbiAqIEl0IHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRhdGFzZXQgY29sbGVjdGlvblxuICpcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2V9XG4gKlxuICogQG1lbWJlcm9mISBTcG90XG4gKi9cbmZ1bmN0aW9uIGdldERhdGFzZXRzICgpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIG1lLnNvY2tldC5lbWl0KCdnZXREYXRhc2V0cycpO1xuXG4gICAgbWUuZGF0YXNldHMub25jZSgncmVzZXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXNvbHZlKG1lLmRhdGFzZXRzKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmVzZXQgbWluLCBtYXgsIGFuZCBjYXRlZ29yaWVzIGZvciBhbGwgZmFjZXRzIGluIHRoZSBkYXRhdmlld1xuICpcbiAqIEBwYXJhbSB7U3BvdH0gbWUgTWFpbiBzcG90IGluc3RhbmNlXG4gKlxuICogQG1lbWJlcm9mISBTcG90XG4gKi9cbmZ1bmN0aW9uIHJlc2V0RGF0YXZpZXcgKCkge1xuICB2YXIgdG9TZXJpYWxpemUgPSBbXTtcblxuICAvLyBVcGRhdGUgbGlzdCBvZiBhY3RpdmUgZGF0YXNldHMsIGFuZCBzZXJpYWxpemUgdGhlIGRhdGFzZXRzIHBhcnRzIHdlIG5lZWQgdG8gc2VuZCBvbiBnZXREYXRhIHJlcXVlc3RzXG4gIHRoaXMuZGF0YXZpZXcuZGF0YXNldElkcyA9IFtdO1xuICB0aGlzLmRhdGFzZXRzLmZvckVhY2goZnVuY3Rpb24gKGRhdGFzZXQpIHtcbiAgICBpZiAoZGF0YXNldC5pc0FjdGl2ZSkge1xuICAgICAgLy8gQlVHRklYOiB0aGUgbGlzdCBvZiBkYXRhc2V0SWRzIGNhbiBnZXQgb3V0IG9mIHN5bmMgd2hlbiB1c2luZyBzcG90LXNlcnZlci4gSnVzdCByZWNyZWF0ZSBpdCBhbHdheXMuXG4gICAgICB0aGlzLmRhdGF2aWV3LmRhdGFzZXRJZHMucHVzaChkYXRhc2V0LmdldElkKCkpO1xuICAgICAgdG9TZXJpYWxpemUucHVzaChkYXRhc2V0LnRvSlNPTigpKTsgLy8gVE9ETzogb25seSBzZXJpYWxpemUgdXNlZCBmYWNldHM/XG4gICAgfVxuICB9LCB0aGlzKTtcbiAgdGhpcy5jYWNoZWREYXRhc2V0cyA9IEpTT04uc3RyaW5naWZ5KHRvU2VyaWFsaXplKTtcblxuICAvLyByZXNjYW4gbWluL21heCB2YWx1ZXMgYW5kIGNhdGVnb3JpZXMgZm9yIHRoZSBuZXdseSBhZGRlZCBmYWNldHNcbiAgdGhpcy5kYXRhdmlldy5mYWNldHMuZm9yRWFjaChmdW5jdGlvbiAoZmFjZXQpIHtcbiAgICB2YXIgbmV3RmFjZXQgPSB0aGlzLmRhdGF2aWV3LmZhY2V0cy5nZXQoZmFjZXQubmFtZSwgJ25hbWUnKTtcblxuICAgIGlmIChuZXdGYWNldC5pc0NvbnRpbnVvdXMgfHwgbmV3RmFjZXQuaXNEYXRldGltZSB8fCBuZXdGYWNldC5pc0R1cmF0aW9uKSB7XG4gICAgICB0aGlzLnNldEZhY2V0TWluTWF4KGZhY2V0KTtcbiAgICB9IGVsc2UgaWYgKG5ld0ZhY2V0LmlzQ2F0ZWdvcmlhbCkge1xuICAgICAgdGhpcy5zZXRGYWNldENhdGVnb3JpZXMoZmFjZXQpO1xuICAgIH1cbiAgfSwgdGhpcyk7XG59XG5cbi8qXG4gKiBBZGQgb3IgcmVtb3ZlIGZhY2V0cyBmcm9tIGEgZGF0YXNldCB0byB0aGUgZ2xvYmFsIChtZXJnZWQpIGRhdGFzZXRcbiAqXG4gKiBAbWVtYmVyb2YhIFNwb3RcbiAqIEBwYXJhbSB7U3BvdH0gbWUgTWFpbiBzcG90IGluc3RhbmNlXG4gKiBAcGFyYW0ge0RhdGFzZXR9IGRhdGFzZXQgRGF0YXNldCBzZXQgYWRkIG9yIHJlbW92ZVxuICovXG5mdW5jdGlvbiB0b2dnbGVEYXRhc2V0RmFjZXRzIChtZSwgZGF0YXNldCkge1xuICBpZiAoZGF0YXNldC5pc0FjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBhY3RpdmUgZmFjZXRzIGluIGRhdGFzZXQgZnJvbSB0aGUgZ2xvYmFsIGRhdGFzZXQuLi5cbiAgICBkYXRhc2V0LmZhY2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChmYWNldCkge1xuICAgICAgaWYgKCFmYWNldC5pc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIC4uLmJ1dCBvbmx5IHdoZW4gbm8gb3RoZXIgYWN0aXZlIGRhdGFzZXQgY29udGFpbnMgaXRcbiAgICAgIHZhciBmYWNldElzVW5pcXVlID0gdHJ1ZTtcbiAgICAgIG1lLmRhdGFzZXRzLmZvckVhY2goZnVuY3Rpb24gKG90aGVyRGF0YXNldCkge1xuICAgICAgICBpZiAoIW90aGVyRGF0YXNldC5pc0FjdGl2ZSB8fCBvdGhlckRhdGFzZXQgPT09IGRhdGFzZXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyRGF0YXNldC5mYWNldHMuZ2V0KGZhY2V0Lm5hbWUsICduYW1lJykpIHtcbiAgICAgICAgICBmYWNldElzVW5pcXVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGZhY2V0SXNVbmlxdWUpIHtcbiAgICAgICAgdmFyIHRvUmVtb3ZlID0gbWUuZGF0YXZpZXcuZmFjZXRzLmdldChmYWNldC5uYW1lLCAnbmFtZScpO1xuICAgICAgICBtZS5kYXRhdmlldy5mYWNldHMucmVtb3ZlKHRvUmVtb3ZlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmICghZGF0YXNldC5pc0FjdGl2ZSkge1xuICAgIC8vIGNvcHkgZmFjZXRzXG4gICAgZGF0YXNldC5mYWNldHMuZm9yRWFjaChmdW5jdGlvbiAoZmFjZXQpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmcgaWYgZmFjZXQgaXMgbm90IGFjdGl2ZVxuICAgICAgaWYgKCFmYWNldC5pc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGRlZmF1bHQgb3B0aW9ucyBmb3IgYWxsIGZhY2V0IHR5cGVzXG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgbmFtZTogZmFjZXQubmFtZSxcbiAgICAgICAgYWNjZXNzb3I6IGZhY2V0Lm5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBmYWNldC5kZXNjcmlwdGlvbixcbiAgICAgICAgdHlwZTogZmFjZXQudHJhbnNmb3JtLnRyYW5zZm9ybWVkVHlwZSxcbiAgICAgICAgdW5pdHM6IGZhY2V0LnVuaXRzLCAvLyBUT0RPOiB0cmFuc2Zvcm1lZCB1bml0cz9cbiAgICAgICAgaXNBY3RpdmU6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIC8vIGRvIG5vdCBhZGQgaWYgYSBzaW1pbGFyIGZhY2V0IGFscmVhZHkgZXhpc3RzXG4gICAgICBpZiAoIW1lLmRhdGF2aWV3LmZhY2V0cy5nZXQoZmFjZXQubmFtZSwgJ25hbWUnKSkge1xuICAgICAgICBtZS5kYXRhdmlldy5mYWNldHMuYWRkKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qXG4gKiBBZGQgb3IgcmVtb3ZlIGRhdGEgZnJvbSBhIGRhdGFzZXQgdG8gdGhlIGdsb2JhbCAobWVyZ2VkKSBkYXRhc2V0XG4gKlxuICogQG1lbWJlcm9mISBTcG90XG4gKiBAcGFyYW0ge1Nwb3R9IG1lIE1haW4gc3BvdCBpbnN0YW5jZVxuICogQHBhcmFtIHtEYXRhc2V0fSBkYXRhc2V0IERhdGFzZXQgc2V0IGFkZCBvciByZW1vdmVcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlRGF0YXNldERhdGEgKG1lLCBkYXRhc2V0KSB7XG4gIGlmIChkYXRhc2V0LmlzQWN0aXZlKSB7XG4gICAgLy8gaWYgZGF0YXNldCBpcyBhY3RpdmUsIHJlbW92ZSBpdDpcbiAgICAvLyAuLi5jbGVhciBhbGwgY3Jvc3NmaWx0ZXIgZmlsdGVyc1xuICAgIG1lLmRhdGF2aWV3LmZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAvLyBCVUdGSVg6IHdoZW4gbG9hZGluZyBzZXNzaW9ucywgdGhlIGRhdGFzZXQgaXMgbm90IGluaXRpYWxpemVkIHByb3Blcmx5XG4gICAgICAvLyBzbyBjaGVjayBmb3IgaXQgdG8gYmUgc3VyZVxuICAgICAgaWYgKGZpbHRlci5kaW1lbnNpb24pIHtcbiAgICAgICAgZmlsdGVyLmRpbWVuc2lvbi5maWx0ZXJBbGwoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIC4uLmZpbHRlciBhbGwgZGF0YSwgb3JpZ2luYXRpbmcgZnJvbSB0aGUgZGF0YXNldCBmcm9tIHRoZSBkYXRhc2V0XG4gICAgdmFyIGRpbWVuc2lvbiA9IG1lLmRhdGF2aWV3LmNyb3NzZmlsdGVyLmRpbWVuc2lvbihmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQuX09yaWdpbmFsRGF0YXNldElkO1xuICAgIH0pO1xuICAgIGRpbWVuc2lvbi5maWx0ZXIoZGF0YXNldC5nZXRJZCgpKTtcblxuICAgIC8vIC4uLnJlbW92ZSBtYXRjaGluZyBkYXRhXG4gICAgbWUuZGF0YXZpZXcuY3Jvc3NmaWx0ZXIucmVtb3ZlKCk7XG5cbiAgICAvLyAuLi5yZXN0b3JlIG9yaWdpbmFsIGZpbHRlcnNcbiAgICBkaW1lbnNpb24uZmlsdGVyQWxsKCk7XG4gICAgZGltZW5zaW9uLmRpc3Bvc2UoKTtcbiAgICBtZS5kYXRhdmlldy5maWx0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgZmlsdGVyLnVwZGF0ZURhdGFGaWx0ZXIoKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICghZGF0YXNldC5pc0FjdGl2ZSkge1xuICAgIC8vIGlmIGRhdGFzZXQgaXMgbm90IGFjdGl2ZSwgYWRkIGl0XG4gICAgLy8gLi4uZmluZCBmYWNldHMgdG8gY29weVxuICAgIHZhciBkYXRhVHJhbnNmb3JtcyA9IFtdO1xuICAgIGRhdGFzZXQuZmFjZXRzLmZvckVhY2goZnVuY3Rpb24gKGZhY2V0KSB7XG4gICAgICAvLyBkbyBub3RoaW5nIGlmIGZhY2V0IGlzIG5vdCBhY3RpdmVcbiAgICAgIGlmICghZmFjZXQuaXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGF0YVRyYW5zZm9ybXMucHVzaCh7XG4gICAgICAgIGtleTogZmFjZXQubmFtZSxcbiAgICAgICAgZm46IHV0aWxkeC52YWx1ZUZuKGZhY2V0KVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyAuLi50cmFuc2Zvcm0gZGF0YVxuICAgIHZhciBkYXRhID0gZGF0YXNldC5kYXRhO1xuICAgIHZhciB0cmFuc2Zvcm1lZERhdGEgPSBbXTtcblxuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZGF0dW0pIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1lZERhdHVtID0ge307XG4gICAgICBkYXRhVHJhbnNmb3Jtcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdHJhbnNmb3JtZWREYXR1bVt0cmFuc2Zvcm0ua2V5XSA9IHRyYW5zZm9ybS5mbihkYXR1bSk7XG4gICAgICB9KTtcbiAgICAgIHRyYW5zZm9ybWVkRGF0dW0uX09yaWdpbmFsRGF0YXNldElkID0gZGF0YXNldC5nZXRJZCgpO1xuICAgICAgdHJhbnNmb3JtZWREYXRhLnB1c2godHJhbnNmb3JtZWREYXR1bSk7XG4gICAgfSk7XG5cbiAgICAvLyAuLi5hZGQgdG8gbWVyZ2VkIGRhdGFzZXRcbiAgICBtZS5kYXRhdmlldy5jcm9zc2ZpbHRlci5hZGQodHJhbnNmb3JtZWREYXRhKTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBjb3VudHNcbiAgbWUuZGF0YXZpZXcuZGF0YVRvdGFsID0gbWUuZGF0YXZpZXcuY3Jvc3NmaWx0ZXIuc2l6ZSgpO1xuICBtZS5kYXRhdmlldy5kYXRhU2VsZWN0ZWQgPSBtZS5kYXRhdmlldy5jb3VudEdyb3VwLnZhbHVlKCk7XG59XG5cbi8qKlxuICogQWRkIG9yIHJlbW92ZSBhIGRhdGFzZXQgZnJvbSB0aGUgZGF0YXZpZXdcbiAqIEBwYXJhbSB7RGF0YXNldH0gZGF0YXNldCBEYXRhc2V0IHNldCBhZGQgb3IgcmVtb3ZlXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YhIFNwb3RcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlRGF0YXNldCAoZGF0YXNldCkge1xuICBpZiAodGhpcy5zZXNzaW9uVHlwZSA9PT0gJ3NlcnZlcicpIHtcbiAgICB0b2dnbGVEYXRhc2V0RmFjZXRzKHRoaXMsIGRhdGFzZXQpO1xuICB9IGVsc2UgaWYgKHRoaXMuc2Vzc2lvblR5cGUgPT09ICdjbGllbnQnKSB7XG4gICAgLy8gcmVsZWFzZSBhbGwgZmlsdGVyc1xuICAgIHRoaXMuZGF0YXZpZXcuZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgIGZpbHRlci5yZWxlYXNlRGF0YUZpbHRlcigpO1xuICAgIH0pO1xuXG4gICAgLy8gbWFudWFsbHkgbWVyZ2UgdGhlIGRhdGFzZXRzXG4gICAgdG9nZ2xlRGF0YXNldEZhY2V0cyh0aGlzLCBkYXRhc2V0KTtcbiAgICB0b2dnbGVEYXRhc2V0RGF0YSh0aGlzLCBkYXRhc2V0KTtcbiAgfVxuXG4gIGRhdGFzZXQuaXNBY3RpdmUgPSAhZGF0YXNldC5pc0FjdGl2ZTtcblxuICB0aGlzLnJlc2V0RGF0YXZpZXcoKTtcbn1cblxuZnVuY3Rpb24gc2V0RmFjZXRNaW5NYXggKGZhY2V0KSB7XG4gIC8vIFRoaXMgc2hvdWxkIHdvcmsgZm9yIGFsbCBraW5kcyBvZiBmYWNldHM6XG4gIC8vIG51bWJlcnMsIGR1cmF0aW9ucywgYW5kIGRhdGF0aW1lcyBhbGwgaW1wbGVtZW50IHRoZSByZWxldmFudCBvcGVyYXRpb25zXG4gIHZhciBkYXRhc2V0cyA9IHRoaXMuZGF0YXNldHM7XG5cbiAgdmFyIGZpcnN0ID0gdHJ1ZTtcbiAgZGF0YXNldHMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YXNldCkge1xuICAgIGlmIChkYXRhc2V0LmlzQWN0aXZlKSB7XG4gICAgICB2YXIgc3ViRmFjZXQgPSBkYXRhc2V0LmZhY2V0cy5nZXQoZmFjZXQubmFtZSwgJ25hbWUnKTtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmYWNldC5taW52YWxBc1RleHQgPSBzdWJGYWNldC50cmFuc2Zvcm0udHJhbnNmb3JtZWRNaW5Bc1RleHQ7XG4gICAgICAgIGZhY2V0Lm1heHZhbEFzVGV4dCA9IHN1YkZhY2V0LnRyYW5zZm9ybS50cmFuc2Zvcm1lZE1heEFzVGV4dDtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdWJGYWNldC5taW52YWwgPCBmYWNldC5taW52YWwpIHtcbiAgICAgICAgICBmYWNldC5taW52YWxBc1RleHQgPSBzdWJGYWNldC50cmFuc2Zvcm0udHJhbnNmb3JtZWRNaW5Bc1RleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YkZhY2V0Lm1heHZhbCA+IGZhY2V0Lm1heHZhbCkge1xuICAgICAgICAgIGZhY2V0Lm1heHZhbEFzVGV4dCA9IHN1YkZhY2V0LnRyYW5zZm9ybS50cmFuc2Zvcm1lZE1heEFzVGV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldEZhY2V0Q2F0ZWdvcmllcyAoZmFjZXQpIHtcbiAgdmFyIGRhdGFzZXRzID0gdGhpcy5kYXRhc2V0cztcblxuICBmYWNldC5jYXRlZ29yaWFsVHJhbnNmb3JtLnJlc2V0KCk7XG5cbiAgLy8gZ2V0IGNhdGVnb3JpZXMgYnkgY29tYmluaW5nIHRoZSBzZXRzIGZvciB0aGUgc2VwYXJhdGUgZGF0YXNldHNcbiAgZGF0YXNldHMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YXNldCkge1xuICAgIGlmIChkYXRhc2V0LmlzQWN0aXZlKSB7XG4gICAgICB2YXIgc3ViRmFjZXQgPSBkYXRhc2V0LmZhY2V0cy5nZXQoZmFjZXQubmFtZSwgJ25hbWUnKTtcblxuICAgICAgaWYgKHN1YkZhY2V0LmlzQ2F0ZWdvcmlhbCkge1xuICAgICAgICAvLyBtZXJnZSBydWxlcyBmcm9tIHN1YkZhY2V0IGludG8gdGhvc2Ugb2YgRmFjZXRcbiAgICAgICAgc3ViRmFjZXQuY2F0ZWdvcmlhbFRyYW5zZm9ybS5ydWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgICAgdmFyIG5ld1J1bGUgPSBmYWNldC5jYXRlZ29yaWFsVHJhbnNmb3JtLnJ1bGVzLmdldChydWxlLmV4cHJlc3Npb24sICdleHByZXNzaW9uJyk7XG4gICAgICAgICAgaWYgKG5ld1J1bGUpIHtcbiAgICAgICAgICAgIG5ld1J1bGUuY291bnQgKz0gcnVsZS5jb3VudDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmFjZXQuY2F0ZWdvcmlhbFRyYW5zZm9ybS5ydWxlcy5hZGQocnVsZS50b0pTT04oKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoc3ViRmFjZXQuaXNEYXRldGltZSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSB0aW1lVXRpbC50aW1lUGFydHMuZ2V0KHN1YkZhY2V0LmRhdGV0aW1lVHJhbnNmb3JtLnRyYW5zZm9ybWVkRm9ybWF0LCAnZGVzY3JpcHRpb24nKS5ncm91cHM7XG4gICAgICAgIGV4cHJlc3Npb25zLmZvckVhY2goZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB2YXIgbmV3UnVsZSA9IGZhY2V0LmNhdGVnb3JpYWxUcmFuc2Zvcm0ucnVsZXMuZ2V0KGV4cHJlc3Npb24sICdleHByZXNzaW9uJyk7XG4gICAgICAgICAgaWYgKG5ld1J1bGUpIHtcbiAgICAgICAgICAgIC8vIG5vLW9wOiBjYXRlZ29yeSBleGlzdCBhbmQgd2UgZG9uJ3QgaGF2ZSBhIHByb3BlciBjb3VudFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmYWNldC5jYXRlZ29yaWFsVHJhbnNmb3JtLnJ1bGVzLmFkZCh7XG4gICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICBncm91cDogZXhwcmVzc2lvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VNb2RlbC5leHRlbmQoe1xuICB0eXBlOiAndXNlcicsXG4gIHByb3BzOiB7XG4gICAgLyoqXG4gICAgICogSXMgdGhlcmUgYSBjb25uZWN0aW9uIHdpdGggYSBzcG90IHNldmVyP1xuICAgICAqIEBtZW1iZXJvZiEgU3BvdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQ29ubmVjdGVkOiBbJ2Jvb2xlYW4nLCB0cnVlLCBmYWxzZV0sXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgYXBwIGluIGxvY2tlZCBkb3duLCBmYWNldHMgYW5kIGRhdGFzZXRzIGNhbm5vdCBiZSBlZGl0ZWRcbiAgICAgKiBAbWVtYmVyb2YhIFNwb3RcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0xvY2tlZERvd246IFsnYm9vbGVhbicsIHRydWUsIGZhbHNlXSxcbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIHNwb3Qgc2Vzc2lvbi4gTXVzdCBiZSAnY2xpZW50JyBvciAnc2VydmVyJ1xuICAgICAqIEBtZW1iZXJvZiEgU3BvdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgc2Vzc2lvblR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiAnY2xpZW50JyxcbiAgICAgIHZhbHVlczogWydjbGllbnQnLCAnc2VydmVyJ10sXG4gICAgICBzZXRPbmNlOiB0cnVlXG4gICAgfVxuICB9LFxuICBjaGlsZHJlbjoge1xuICAgIC8qKlxuICAgICAqIEEgdW5pb24gb2YgYWxsIGFjdGl2ZSBkYXRhc2V0c1xuICAgICAqIEBtZW1iZXJvZiEgU3BvdFxuICAgICAqIEB0eXBlIHtEYXRhdmlld31cbiAgICAgKi9cbiAgICBkYXRhdmlldzogRGF0YXZpZXdcbiAgfSxcbiAgY29sbGVjdGlvbnM6IHtcbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIG9mIGFsbCBkYXRhc2V0c1xuICAgICAqIEBtZW1iZXJvZiEgU3BvdFxuICAgICAqIEB0eXBlIHtEYXRhc2V0W119XG4gICAgICovXG4gICAgZGF0YXNldHM6IERhdGFzZXRzXG4gIH0sXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBmaXJzdCBkbyBwYXJlbnQgY2xhc3MgaW5pdGlhbGl6YXRpb25cbiAgICBCYXNlTW9kZWwucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIGRlZmF1bHQgdG8gY2xpZW50IHNpZGUgKGNyb3NzZmlsdGVyKSBzZXNzaW9uc1xuICAgIHRoaXMuZHJpdmVyID0gZHJpdmVyQ2xpZW50O1xuXG4gICAgLy8gYXNzaWduIGJhY2tlbmQgZHJpdmVyXG4gICAgaWYgKGFyZ3VtZW50cyAmJiBhcmd1bWVudHNbMF0gJiYgYXJndW1lbnRzWzBdLnNlc3Npb25UeXBlKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzBdLnNlc3Npb25UeXBlID09PSAnY2xpZW50Jykge1xuICAgICAgICB0aGlzLmRyaXZlciA9IGRyaXZlckNsaWVudDtcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdLnNlc3Npb25UeXBlID09PSAnc2VydmVyJykge1xuICAgICAgICB0aGlzLmRyaXZlciA9IGRyaXZlclNlcnZlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIGRyaXZlciBmb3IgdHlwZScsIGFyZ3VtZW50c1swXS5zZXNzaW9uVHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZXNldERhdGF2aWV3OiByZXNldERhdGF2aWV3LFxuICBjb25uZWN0VG9TZXJ2ZXI6IGNvbm5lY3RUb1NlcnZlcixcbiAgZGlzY29ubmVjdEZyb21TZXJ2ZXI6IGRpc2Nvbm5lY3RGcm9tU2VydmVyLFxuICBnZXREYXRhc2V0czogZ2V0RGF0YXNldHMsXG4gIHNldEZhY2V0TWluTWF4OiBzZXRGYWNldE1pbk1heCxcbiAgc2V0RmFjZXRDYXRlZ29yaWVzOiBzZXRGYWNldENhdGVnb3JpZXMsXG4gIHRvZ2dsZURhdGFzZXQ6IHRvZ2dsZURhdGFzZXRcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cy51dGlsID0ge1xuICBkeDogdXRpbGR4LFxuICBtaXN2YWw6IHJlcXVpcmUoJy4vdXRpbC9taXN2YWwnKSxcbiAgdGltZTogdGltZVV0aWxcbn07XG5cbm1vZHVsZS5leHBvcnRzLnRyYW5zZm9ybXMgPSB7XG4gIGNhdGVnb3JpYWw6IHJlcXVpcmUoJy4vZmFjZXQvY2F0ZWdvcmlhbC10cmFuc2Zvcm0nKSxcbiAgY29udGludW91czogcmVxdWlyZSgnLi9mYWNldC9jb250aW51b3VzLXRyYW5zZm9ybScpLFxuICBkYXRldGltZTogcmVxdWlyZSgnLi9mYWNldC9kYXRldGltZS10cmFuc2Zvcm0nKSxcbiAgZHVyYXRpb246IHJlcXVpcmUoJy4vZmFjZXQvZHVyYXRpb24tdHJhbnNmb3JtJylcbn07XG5cbm1vZHVsZS5leHBvcnRzLmNvbnN0cnVjdG9ycyA9IHtcbiAgRGF0YXZpZXc6IERhdGF2aWV3LFxuICBEYXRhc2V0OiByZXF1aXJlKCcuL2RhdGFzZXQnKSxcbiAgRGF0YXNldHM6IERhdGFzZXRzXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3b07\n")},"419b":function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {\nmodule.exports = isBuf;\n\n/**\n * Returns true if obj is a buffer or an arraybuffer.\n *\n * @api private\n */\n\nfunction isBuf(obj) {\n  return (global.Buffer && global.Buffer.isBuffer(obj)) ||\n         (global.ArrayBuffer && obj instanceof ArrayBuffer);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "698d")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE5Yi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanM/MGJlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbm1vZHVsZS5leHBvcnRzID0gaXNCdWY7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIGJ1ZmZlciBvciBhbiBhcnJheWJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZihvYmopIHtcbiAgcmV0dXJuIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///419b\n')},"433b":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"23b1\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && 'WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    return exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (typeof process !== 'undefined' && 'env' in process) {\n    return process.env.DEBUG;\n  }\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"26d5\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMzYi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZGVidWcvYnJvd3Nlci5qcz82NDdhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmICdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh3aW5kb3cuY29uc29sZSAmJiAoY29uc29sZS5maXJlYnVnIHx8IChjb25zb2xlLmV4Y2VwdGlvbiAmJiBjb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuIGFyZ3M7XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzID0gW2FyZ3NbMF0sIGMsICdjb2xvcjogaW5oZXJpdCddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EteiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG4gIHJldHVybiBhcmdzO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHJldHVybiBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///433b\n")},"4c13":function(module,exports,__webpack_require__){eval("\n/**\n * Module dependencies.\n */\n\nvar parser = __webpack_require__(/*! socket.io-parser */ \"6fba\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"ee5b\");\nvar toArray = __webpack_require__(/*! to-array */ \"7de3\");\nvar on = __webpack_require__(/*! ./on */ \"faaa\");\nvar bind = __webpack_require__(/*! component-bind */ \"b6f6\");\nvar debug = __webpack_require__(/*! debug */ \"433b\")('socket.io-client:socket');\nvar hasBin = __webpack_require__(/*! has-binary */ \"d304\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = Socket;\n\n/**\n * Internal events (blacklisted).\n * These events can't be emitted by the user.\n *\n * @api private\n */\n\nvar events = {\n  connect: 1,\n  connect_error: 1,\n  connect_timeout: 1,\n  connecting: 1,\n  disconnect: 1,\n  error: 1,\n  reconnect: 1,\n  reconnect_attempt: 1,\n  reconnect_failed: 1,\n  reconnect_error: 1,\n  reconnecting: 1,\n  ping: 1,\n  pong: 1\n};\n\n/**\n * Shortcut to `Emitter#emit`.\n */\n\nvar emit = Emitter.prototype.emit;\n\n/**\n * `Socket` constructor.\n *\n * @api public\n */\n\nfunction Socket (io, nsp, opts) {\n  this.io = io;\n  this.nsp = nsp;\n  this.json = this; // compat\n  this.ids = 0;\n  this.acks = {};\n  this.receiveBuffer = [];\n  this.sendBuffer = [];\n  this.connected = false;\n  this.disconnected = true;\n  if (opts && opts.query) {\n    this.query = opts.query;\n  }\n  if (this.io.autoConnect) this.open();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Subscribe to open, close and packet events\n *\n * @api private\n */\n\nSocket.prototype.subEvents = function () {\n  if (this.subs) return;\n\n  var io = this.io;\n  this.subs = [\n    on(io, 'open', bind(this, 'onopen')),\n    on(io, 'packet', bind(this, 'onpacket')),\n    on(io, 'close', bind(this, 'onclose'))\n  ];\n};\n\n/**\n * \"Opens\" the socket.\n *\n * @api public\n */\n\nSocket.prototype.open =\nSocket.prototype.connect = function () {\n  if (this.connected) return this;\n\n  this.subEvents();\n  this.io.open(); // ensure open\n  if ('open' === this.io.readyState) this.onopen();\n  this.emit('connecting');\n  return this;\n};\n\n/**\n * Sends a `message` event.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.send = function () {\n  var args = toArray(arguments);\n  args.unshift('message');\n  this.emit.apply(this, args);\n  return this;\n};\n\n/**\n * Override `emit`.\n * If the event is in `events`, it's emitted normally.\n *\n * @param {String} event name\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.emit = function (ev) {\n  if (events.hasOwnProperty(ev)) {\n    emit.apply(this, arguments);\n    return this;\n  }\n\n  var args = toArray(arguments);\n  var parserType = parser.EVENT; // default\n  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary\n  var packet = { type: parserType, data: args };\n\n  packet.options = {};\n  packet.options.compress = !this.flags || false !== this.flags.compress;\n\n  // event ack callback\n  if ('function' === typeof args[args.length - 1]) {\n    debug('emitting packet with ack id %d', this.ids);\n    this.acks[this.ids] = args.pop();\n    packet.id = this.ids++;\n  }\n\n  if (this.connected) {\n    this.packet(packet);\n  } else {\n    this.sendBuffer.push(packet);\n  }\n\n  delete this.flags;\n\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.packet = function (packet) {\n  packet.nsp = this.nsp;\n  this.io.packet(packet);\n};\n\n/**\n * Called upon engine `open`.\n *\n * @api private\n */\n\nSocket.prototype.onopen = function () {\n  debug('transport is open - connecting');\n\n  // write connect packet if necessary\n  if ('/' !== this.nsp) {\n    if (this.query) {\n      this.packet({type: parser.CONNECT, query: this.query});\n    } else {\n      this.packet({type: parser.CONNECT});\n    }\n  }\n};\n\n/**\n * Called upon engine `close`.\n *\n * @param {String} reason\n * @api private\n */\n\nSocket.prototype.onclose = function (reason) {\n  debug('close (%s)', reason);\n  this.connected = false;\n  this.disconnected = true;\n  delete this.id;\n  this.emit('disconnect', reason);\n};\n\n/**\n * Called with socket packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onpacket = function (packet) {\n  if (packet.nsp !== this.nsp) return;\n\n  switch (packet.type) {\n    case parser.CONNECT:\n      this.onconnect();\n      break;\n\n    case parser.EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.BINARY_EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.ACK:\n      this.onack(packet);\n      break;\n\n    case parser.BINARY_ACK:\n      this.onack(packet);\n      break;\n\n    case parser.DISCONNECT:\n      this.ondisconnect();\n      break;\n\n    case parser.ERROR:\n      this.emit('error', packet.data);\n      break;\n  }\n};\n\n/**\n * Called upon a server event.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onevent = function (packet) {\n  var args = packet.data || [];\n  debug('emitting event %j', args);\n\n  if (null != packet.id) {\n    debug('attaching ack callback to event');\n    args.push(this.ack(packet.id));\n  }\n\n  if (this.connected) {\n    emit.apply(this, args);\n  } else {\n    this.receiveBuffer.push(args);\n  }\n};\n\n/**\n * Produces an ack callback to emit with an event.\n *\n * @api private\n */\n\nSocket.prototype.ack = function (id) {\n  var self = this;\n  var sent = false;\n  return function () {\n    // prevent double callbacks\n    if (sent) return;\n    sent = true;\n    var args = toArray(arguments);\n    debug('sending ack %j', args);\n\n    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;\n    self.packet({\n      type: type,\n      id: id,\n      data: args\n    });\n  };\n};\n\n/**\n * Called upon a server acknowlegement.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onack = function (packet) {\n  var ack = this.acks[packet.id];\n  if ('function' === typeof ack) {\n    debug('calling ack %s with %j', packet.id, packet.data);\n    ack.apply(this, packet.data);\n    delete this.acks[packet.id];\n  } else {\n    debug('bad ack %s', packet.id);\n  }\n};\n\n/**\n * Called upon server connect.\n *\n * @api private\n */\n\nSocket.prototype.onconnect = function () {\n  this.connected = true;\n  this.disconnected = false;\n  this.emit('connect');\n  this.emitBuffered();\n};\n\n/**\n * Emit buffered events (received and emitted).\n *\n * @api private\n */\n\nSocket.prototype.emitBuffered = function () {\n  var i;\n  for (i = 0; i < this.receiveBuffer.length; i++) {\n    emit.apply(this, this.receiveBuffer[i]);\n  }\n  this.receiveBuffer = [];\n\n  for (i = 0; i < this.sendBuffer.length; i++) {\n    this.packet(this.sendBuffer[i]);\n  }\n  this.sendBuffer = [];\n};\n\n/**\n * Called upon server disconnect.\n *\n * @api private\n */\n\nSocket.prototype.ondisconnect = function () {\n  debug('server disconnect (%s)', this.nsp);\n  this.destroy();\n  this.onclose('io server disconnect');\n};\n\n/**\n * Called upon forced client/server side disconnections,\n * this method ensures the manager stops tracking us and\n * that reconnections don't get triggered for this.\n *\n * @api private.\n */\n\nSocket.prototype.destroy = function () {\n  if (this.subs) {\n    // clean subscriptions to avoid reconnections\n    for (var i = 0; i < this.subs.length; i++) {\n      this.subs[i].destroy();\n    }\n    this.subs = null;\n  }\n\n  this.io.destroy(this);\n};\n\n/**\n * Disconnects the socket manually.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.close =\nSocket.prototype.disconnect = function () {\n  if (this.connected) {\n    debug('performing disconnect (%s)', this.nsp);\n    this.packet({ type: parser.DISCONNECT });\n  }\n\n  // remove socket from pool\n  this.destroy();\n\n  if (this.connected) {\n    // fire events\n    this.onclose('io client disconnect');\n  }\n  return this;\n};\n\n/**\n * Sets the compress flag.\n *\n * @param {Boolean} if `true`, compresses the sending data\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.compress = function (compress) {\n  this.flags = this.flags || {};\n  this.flags.compress = compress;\n  return this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNGMxMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvc29ja2V0LmpzPzg3ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciB0b0FycmF5ID0gcmVxdWlyZSgndG8tYXJyYXknKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaGFzQmluID0gcmVxdWlyZSgnaGFzLWJpbmFyeScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBJbnRlcm5hbCBldmVudHMgKGJsYWNrbGlzdGVkKS5cbiAqIFRoZXNlIGV2ZW50cyBjYW4ndCBiZSBlbWl0dGVkIGJ5IHRoZSB1c2VyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBldmVudHMgPSB7XG4gIGNvbm5lY3Q6IDEsXG4gIGNvbm5lY3RfZXJyb3I6IDEsXG4gIGNvbm5lY3RfdGltZW91dDogMSxcbiAgY29ubmVjdGluZzogMSxcbiAgZGlzY29ubmVjdDogMSxcbiAgZXJyb3I6IDEsXG4gIHJlY29ubmVjdDogMSxcbiAgcmVjb25uZWN0X2F0dGVtcHQ6IDEsXG4gIHJlY29ubmVjdF9mYWlsZWQ6IDEsXG4gIHJlY29ubmVjdF9lcnJvcjogMSxcbiAgcmVjb25uZWN0aW5nOiAxLFxuICBwaW5nOiAxLFxuICBwb25nOiAxXG59O1xuXG4vKipcbiAqIFNob3J0Y3V0IHRvIGBFbWl0dGVyI2VtaXRgLlxuICovXG5cbnZhciBlbWl0ID0gRW1pdHRlci5wcm90b3R5cGUuZW1pdDtcblxuLyoqXG4gKiBgU29ja2V0YCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldCAoaW8sIG5zcCwgb3B0cykge1xuICB0aGlzLmlvID0gaW87XG4gIHRoaXMubnNwID0gbnNwO1xuICB0aGlzLmpzb24gPSB0aGlzOyAvLyBjb21wYXRcbiAgdGhpcy5pZHMgPSAwO1xuICB0aGlzLmFja3MgPSB7fTtcbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIGlmIChvcHRzICYmIG9wdHMucXVlcnkpIHtcbiAgICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgfVxuICBpZiAodGhpcy5pby5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdWJzKSByZXR1cm47XG5cbiAgdmFyIGlvID0gdGhpcy5pbztcbiAgdGhpcy5zdWJzID0gW1xuICAgIG9uKGlvLCAnb3BlbicsIGJpbmQodGhpcywgJ29ub3BlbicpKSxcbiAgICBvbihpbywgJ3BhY2tldCcsIGJpbmQodGhpcywgJ29ucGFja2V0JykpLFxuICAgIG9uKGlvLCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpXG4gIF07XG59O1xuXG4vKipcbiAqIFwiT3BlbnNcIiB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vcGVuID1cblNvY2tldC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSByZXR1cm4gdGhpcztcblxuICB0aGlzLnN1YkV2ZW50cygpO1xuICB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5pby5yZWFkeVN0YXRlKSB0aGlzLm9ub3BlbigpO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3RpbmcnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICBhcmdzLnVuc2hpZnQoJ21lc3NhZ2UnKTtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYGVtaXRgLlxuICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldikpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgdmFyIHBhcnNlclR5cGUgPSBwYXJzZXIuRVZFTlQ7IC8vIGRlZmF1bHRcbiAgaWYgKGhhc0JpbihhcmdzKSkgeyBwYXJzZXJUeXBlID0gcGFyc2VyLkJJTkFSWV9FVkVOVDsgfSAvLyBiaW5hcnlcbiAgdmFyIHBhY2tldCA9IHsgdHlwZTogcGFyc2VyVHlwZSwgZGF0YTogYXJncyB9O1xuXG4gIHBhY2tldC5vcHRpb25zID0ge307XG4gIHBhY2tldC5vcHRpb25zLmNvbXByZXNzID0gIXRoaXMuZmxhZ3MgfHwgZmFsc2UgIT09IHRoaXMuZmxhZ3MuY29tcHJlc3M7XG5cbiAgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG4gICAgZGVidWcoJ2VtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZCcsIHRoaXMuaWRzKTtcbiAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcbiAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgdGhpcy5wYWNrZXQocGFja2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG5cbiAgZGVsZXRlIHRoaXMuZmxhZ3M7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBwYWNrZXQubnNwID0gdGhpcy5uc3A7XG4gIHRoaXMuaW8ucGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgb3BlbmAuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCd0cmFuc3BvcnQgaXMgb3BlbiAtIGNvbm5lY3RpbmcnKTtcblxuICAvLyB3cml0ZSBjb25uZWN0IHBhY2tldCBpZiBuZWNlc3NhcnlcbiAgaWYgKCcvJyAhPT0gdGhpcy5uc3ApIHtcbiAgICBpZiAodGhpcy5xdWVyeSkge1xuICAgICAgdGhpcy5wYWNrZXQoe3R5cGU6IHBhcnNlci5DT05ORUNULCBxdWVyeTogdGhpcy5xdWVyeX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhY2tldCh7dHlwZTogcGFyc2VyLkNPTk5FQ1R9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBjbG9zZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBkZWJ1ZygnY2xvc2UgKCVzKScsIHJlYXNvbik7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgZGVsZXRlIHRoaXMuaWQ7XG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKHBhY2tldC5uc3AgIT09IHRoaXMubnNwKSByZXR1cm47XG5cbiAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgIGNhc2UgcGFyc2VyLkNPTk5FQ1Q6XG4gICAgICB0aGlzLm9uY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5ESVNDT05ORUNUOlxuICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVJST1I6XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB2YXIgYXJncyA9IHBhY2tldC5kYXRhIHx8IFtdO1xuICBkZWJ1ZygnZW1pdHRpbmcgZXZlbnQgJWonLCBhcmdzKTtcblxuICBpZiAobnVsbCAhPSBwYWNrZXQuaWQpIHtcbiAgICBkZWJ1ZygnYXR0YWNoaW5nIGFjayBjYWxsYmFjayB0byBldmVudCcpO1xuICAgIGFyZ3MucHVzaCh0aGlzLmFjayhwYWNrZXQuaWQpKTtcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goYXJncyk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmFjayA9IGZ1bmN0aW9uIChpZCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzZW50ID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgaWYgKHNlbnQpIHJldHVybjtcbiAgICBzZW50ID0gdHJ1ZTtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICBkZWJ1Zygnc2VuZGluZyBhY2sgJWonLCBhcmdzKTtcblxuICAgIHZhciB0eXBlID0gaGFzQmluKGFyZ3MpID8gcGFyc2VyLkJJTkFSWV9BQ0sgOiBwYXJzZXIuQUNLO1xuICAgIHNlbGYucGFja2V0KHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBpZDogaWQsXG4gICAgICBkYXRhOiBhcmdzXG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25hY2sgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHZhciBhY2sgPSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhY2spIHtcbiAgICBkZWJ1ZygnY2FsbGluZyBhY2sgJXMgd2l0aCAlaicsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICAgIGFjay5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdiYWQgYWNrICVzJywgcGFja2V0LmlkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcbiAgdGhpcy5lbWl0QnVmZmVyZWQoKTtcbn07XG5cbi8qKlxuICogRW1pdCBidWZmZXJlZCBldmVudHMgKHJlY2VpdmVkIGFuZCBlbWl0dGVkKS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXRCdWZmZXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIHRoaXMucmVjZWl2ZUJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucGFja2V0KHRoaXMuc2VuZEJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBkaXNjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc2VydmVyIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIHRoaXMub25jbG9zZSgnaW8gc2VydmVyIGRpc2Nvbm5lY3QnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZm9yY2VkIGNsaWVudC9zZXJ2ZXIgc2lkZSBkaXNjb25uZWN0aW9ucyxcbiAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG4gKiB0aGF0IHJlY29ubmVjdGlvbnMgZG9uJ3QgZ2V0IHRyaWdnZXJlZCBmb3IgdGhpcy5cbiAqXG4gKiBAYXBpIHByaXZhdGUuXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdWJzKSB7XG4gICAgLy8gY2xlYW4gc3Vic2NyaXB0aW9ucyB0byBhdm9pZCByZWNvbm5lY3Rpb25zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuc3Vic1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuc3VicyA9IG51bGw7XG4gIH1cblxuICB0aGlzLmlvLmRlc3Ryb3kodGhpcyk7XG59O1xuXG4vKipcbiAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQgbWFudWFsbHkuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPVxuU29ja2V0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBkZWJ1ZygncGVyZm9ybWluZyBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuRElTQ09OTkVDVCB9KTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG4gIHRoaXMuZGVzdHJveSgpO1xuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIC8vIGZpcmUgZXZlbnRzXG4gICAgdGhpcy5vbmNsb3NlKCdpbyBjbGllbnQgZGlzY29ubmVjdCcpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24gKGNvbXByZXNzKSB7XG4gIHRoaXMuZmxhZ3MgPSB0aGlzLmZsYWdzIHx8IHt9O1xuICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gIHJldHVybiB0aGlzO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4c13\n")},"4d50":function(module,exports,__webpack_require__){eval("/**\n * Facets are the main abstraction over the data.\n *\n * A `Dataset` is a collection of (similar) items, with each item having a certain set of properties, ie. `Facet`s.\n * The `Facet` class defines the property: It can be a continuous value, a set of labels or tags,\n * or it can be result of some transformation or equation.\n *\n * @class Facet\n * @extends Base\n */\nvar BaseModel = __webpack_require__(/*! ./util/base */ \"3902\");\nvar CategorialTransform = __webpack_require__(/*! ./facet/categorial-transform */ \"9b75\");\nvar ContinuousTransform = __webpack_require__(/*! ./facet/continuous-transform */ \"5a80\");\nvar datetimeTransform = __webpack_require__(/*! ./facet/datetime-transform */ \"a0ca\");\nvar durationTransform = __webpack_require__(/*! ./facet/duration-transform */ \"b123\");\nvar textTransform = __webpack_require__(/*! ./facet/text-transform */ \"e810\");\nvar moment = __webpack_require__(/*! moment-timezone */ \"6c9d\");\n\nmodule.exports = BaseModel.extend({\n  initialize: function () {\n    this.on('change:type', function (facet, newval) {\n      // reset transformations on type change\n      this.continuousTransform.reset();\n      this.categorialTransform.reset();\n      this.datetimeTransform.reset();\n      this.durationTransform.reset();\n    });\n  },\n  props: {\n    /**\n     * Show in facet lists (used for interactive searching on Facets page)\n     * @memberof! Facet\n     * @type {boolean}\n     */\n    show: ['boolean', false, true],\n\n    /**\n     * Show facet bar (on Analyze page)\n     * @memberof! Facet\n     * @type {boolean}\n     */\n    isActive: ['boolean', false, false],\n\n    // general facet properties\n    /**\n     * Description of this facet, for displaying purposes\n     * @memberof! Facet\n     * @type {string}\n     */\n    description: ['string', true, ''],\n\n    /**\n     * For continuous facets, its units for displaying purposes\n     * @memberof! Facet\n     * @type {string}\n     */\n    units: ['string', true, ''],\n\n    /**\n     * Short name (human readable) for this facet, must be unique.\n     * @memberof! Facet\n     * @type {string}\n     */\n    name: ['string', true, ''],\n\n    /**\n     * Type of this facet:\n     *  * `constant`        A constant value of \"1\" for all data items\n     *  * `continuous`      The facet takes on real numbers\n     *  * `categorial`      The facet is a string, or an array of strings (for a well defined set of labels and tags)\n     *  * `datetime`        The facet is a datetime (using momentjs.tz)\n     *  * `duration`        The facet is a duration (using momentjs.duration)\n     *  * `text`            Freeform text.\n     * Check for facet type using isConstant, isContinuous, isCategorial, isDatetime, isDuration, or isText  properties.\n     * @memberof! Facet\n     * @type {string}\n     */\n    type: {\n      type: 'string',\n      required: true,\n      default: 'categorial',\n      values: ['constant', 'continuous', 'categorial', 'datetime', 'duration', 'text']\n    },\n\n    /**\n     * The accessor for this facet.\n     * For nested properties use dot notation: For a dataset `[ {name: {first: \"Santa\", last: \"Claus\"}}, ...]`\n     * you can use `name.first` and `name.last` to get Santa and Claus, respectively.\n     *\n     * @memberof! Facet\n     * @type {string}\n     */\n    accessor: ['string', false, null],\n\n    /**\n     * Missing or invalid data indicator; for multiple values, use a comma separated, quoted list\n     * Numbers, strings, booleans, and the special value null are allowed.\n     * Use single or double quotes for strings \"missing\".\n     * The parsed values are available in the misval property.\n     *\n     * @memberof! Facet\n     * @type {string}\n     */\n    misvalAsText: 'string',\n\n    /**\n     * For continuous or datetime Facets, the minimum value as text.\n     * Parsed value available in the `minval` property\n     * @memberof! Facet\n     * @type {string}\n     */\n    minvalAsText: 'string',\n\n    /**\n     * For continuous or datetime Facets, the maximum value as text.\n     * Parsed value available in the `maxval` property\n     * @memberof! Facet\n     * @type {string}\n     */\n    maxvalAsText: 'string'\n  },\n  children: {\n    /**\n     * A categorial transformation to apply to the data\n     * @memberof! Facet\n     * @type {CategorialTransform}\n     */\n    categorialTransform: CategorialTransform,\n    /**\n     * A datetime transformation to apply to the data\n     * @memberof! Facet\n     * @type {dateimeTransform}\n     */\n    datetimeTransform: datetimeTransform,\n    /**\n     * A duration transformation to apply to the data\n     * @memberof! Facet\n     * @type {dateimeTransform}\n     */\n    durationTransform: durationTransform,\n    /**\n     * A continuous transformation to apply to the data\n     * @memberof! Facet\n     * @type {ContinuousTransform}\n     */\n    continuousTransform: ContinuousTransform,\n    /**\n     * A text transform\n     * @memberof! Facet\n     * @type {TextTransform}\n     */\n    textTransform: textTransform\n  },\n\n  derived: {\n    // properties for: type\n    isConstant: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'constant';\n      }\n    },\n    isContinuous: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'continuous';\n      }\n    },\n    isCategorial: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'categorial';\n      }\n    },\n    isDatetime: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'datetime';\n      }\n    },\n    isDuration: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'duration';\n      }\n    },\n    isText: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'text';\n      }\n    },\n\n    /**\n     * Array of missing data indicators\n     * @memberof! Facet\n     * @type {Object[]}\n     * @readonly\n     */\n    misval: {\n      deps: ['misvalAsText'],\n      fn: function () {\n        // Parse the text content as a JSON array:\n        //  - strings should be quoted\n        //  - numbers unquoated\n        //  - special numbers not allowed: NaN, Infinity\n        try {\n          if (this.misvalAsText !== null) {\n            return JSON.parse('[' + this.misvalAsText + ']');\n          } else {\n            return [];\n          }\n        } catch (e) {\n          return [];\n        }\n      },\n      cache: false\n    },\n\n    /**\n     * For continuous or datetime Facets, the minimum value.\n     * @memberof! Facet\n     * @type {number|datetime}\n     * @readonly\n     */\n    minval: {\n      deps: ['minvalAsText', 'type'],\n      fn: function () {\n        var min;\n        if (this.isContinuous) {\n          min = parseFloat(this.minvalAsText);\n          if (isNaN(min)) {\n            min = 0;\n          }\n        } else if (this.isDatetime) {\n          min = moment(this.minvalAsText, moment.ISO_8601);\n          if (!min.isValid()) {\n            min = moment('2010-01-01 00:00', moment.ISO_8601);\n          }\n        } else if (this.isDuration) {\n          min = moment.duration(this.minvalAsText);\n          if (!moment.isDuration(min)) {\n            min = moment.duration(1, 'seconds');\n          }\n        }\n        return min;\n      },\n      cache: false\n    },\n    /**\n     * For continuous or datetime Facets, the maximum value.\n     * @memberof! Facet\n     * @type {number|datetime}\n     * @readonly\n     */\n    maxval: {\n      deps: ['maxvalAsText', 'type'],\n      fn: function () {\n        var max;\n        if (this.isContinuous) {\n          max = parseFloat(this.maxvalAsText);\n          if (isNaN(max)) {\n            max = 100;\n          }\n        } else if (this.isDatetime) {\n          max = moment(this.maxvalAsText, moment.ISO_8601);\n          if (!max.isValid()) {\n            max = moment('2020-01-01 00:00', moment.ISO_8601);\n          }\n        } else if (this.isDuration) {\n          max = moment.duration(this.maxvalAsText);\n          if (!moment.isDuration(max)) {\n            max = moment.duration(100, 'seconds');\n          }\n        }\n        return max;\n      },\n      cache: false\n    },\n    transform: {\n      deps: ['type'],\n      fn: function () {\n        if (this.isContinuous) {\n          return this.continuousTransform;\n        } else if (this.isCategorial) {\n          return this.categorialTransform;\n        } else if (this.isDatetime) {\n          return this.datetimeTransform;\n        } else if (this.isDuration) {\n          return this.durationTransform;\n        } else if (this.isText) {\n          return this.textTransform;\n        }\n        console.error('Invalid facet');\n      },\n      cache: false\n    }\n  },\n  /**\n   * setMinMax sets the range of a continuous or time facet\n   * For facets in a dataview, the minimum is just the minimum of the facet over all active datasets,\n   * and the same for the maximum.\n   * For facets in a datset, the actual implementation is in the dataset driver.\n   *\n   * @memberof! Facet\n   */\n  setMinMax: function () {\n    var Dataset = __webpack_require__(/*! ./dataset */ \"545a\");\n    var Dataview = __webpack_require__(/*! ./dataview */ \"5066\");\n\n    var ancestor = this.collection.parent;\n    var spot;\n\n    if (ancestor instanceof Dataview) {\n      // Facet -> Facets -> Dataview -> Spot\n      spot = this.collection.parent.parent;\n      spot.setFacetMinMax(this);\n    } else if (ancestor instanceof Dataset) {\n      // Dataset -> Datasets -> Spot\n      spot = ancestor.collection.parent;\n      spot.driver.setMinMax(ancestor, this);\n    }\n  },\n  /**\n   * setCategories finds finds all values on an ordinal (categorial) axis\n   * Updates the categorialTransform of the facet\n   * For facets in a dataview, this is the union of the categories of facet over all active datasets.\n   * For facets in a dataset, the actual implementation is in the dataset driver.\n   *\n   * @memberof! Facet\n   */\n  setCategories: function () {\n    var Dataset = __webpack_require__(/*! ./dataset */ \"545a\");\n    var Dataview = __webpack_require__(/*! ./dataview */ \"5066\");\n\n    var ancestor = this.collection.parent;\n    var spot;\n\n    if (ancestor instanceof Dataview) {\n      // Facet -> Facets -> Dataview -> Spot\n      spot = this.collection.parent.parent;\n      spot.setFacetCategories(this);\n    } else if (ancestor instanceof Dataset) {\n      // Facet -> Facets -> Dataset -> Datasets -> Spot\n      spot = ancestor.collection.parent;\n      spot.driver.setCategories(ancestor, this);\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNGQ1MC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmFjZXQuanM/ZDdlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEZhY2V0cyBhcmUgdGhlIG1haW4gYWJzdHJhY3Rpb24gb3ZlciB0aGUgZGF0YS5cbiAqXG4gKiBBIGBEYXRhc2V0YCBpcyBhIGNvbGxlY3Rpb24gb2YgKHNpbWlsYXIpIGl0ZW1zLCB3aXRoIGVhY2ggaXRlbSBoYXZpbmcgYSBjZXJ0YWluIHNldCBvZiBwcm9wZXJ0aWVzLCBpZS4gYEZhY2V0YHMuXG4gKiBUaGUgYEZhY2V0YCBjbGFzcyBkZWZpbmVzIHRoZSBwcm9wZXJ0eTogSXQgY2FuIGJlIGEgY29udGludW91cyB2YWx1ZSwgYSBzZXQgb2YgbGFiZWxzIG9yIHRhZ3MsXG4gKiBvciBpdCBjYW4gYmUgcmVzdWx0IG9mIHNvbWUgdHJhbnNmb3JtYXRpb24gb3IgZXF1YXRpb24uXG4gKlxuICogQGNsYXNzIEZhY2V0XG4gKiBAZXh0ZW5kcyBCYXNlXG4gKi9cbnZhciBCYXNlTW9kZWwgPSByZXF1aXJlKCcuL3V0aWwvYmFzZScpO1xudmFyIENhdGVnb3JpYWxUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2ZhY2V0L2NhdGVnb3JpYWwtdHJhbnNmb3JtJyk7XG52YXIgQ29udGludW91c1RyYW5zZm9ybSA9IHJlcXVpcmUoJy4vZmFjZXQvY29udGludW91cy10cmFuc2Zvcm0nKTtcbnZhciBkYXRldGltZVRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vZmFjZXQvZGF0ZXRpbWUtdHJhbnNmb3JtJyk7XG52YXIgZHVyYXRpb25UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2ZhY2V0L2R1cmF0aW9uLXRyYW5zZm9ybScpO1xudmFyIHRleHRUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2ZhY2V0L3RleHQtdHJhbnNmb3JtJyk7XG52YXIgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50LXRpbWV6b25lJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZU1vZGVsLmV4dGVuZCh7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm9uKCdjaGFuZ2U6dHlwZScsIGZ1bmN0aW9uIChmYWNldCwgbmV3dmFsKSB7XG4gICAgICAvLyByZXNldCB0cmFuc2Zvcm1hdGlvbnMgb24gdHlwZSBjaGFuZ2VcbiAgICAgIHRoaXMuY29udGludW91c1RyYW5zZm9ybS5yZXNldCgpO1xuICAgICAgdGhpcy5jYXRlZ29yaWFsVHJhbnNmb3JtLnJlc2V0KCk7XG4gICAgICB0aGlzLmRhdGV0aW1lVHJhbnNmb3JtLnJlc2V0KCk7XG4gICAgICB0aGlzLmR1cmF0aW9uVHJhbnNmb3JtLnJlc2V0KCk7XG4gICAgfSk7XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgLyoqXG4gICAgICogU2hvdyBpbiBmYWNldCBsaXN0cyAodXNlZCBmb3IgaW50ZXJhY3RpdmUgc2VhcmNoaW5nIG9uIEZhY2V0cyBwYWdlKVxuICAgICAqIEBtZW1iZXJvZiEgRmFjZXRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzaG93OiBbJ2Jvb2xlYW4nLCBmYWxzZSwgdHJ1ZV0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IGZhY2V0IGJhciAob24gQW5hbHl6ZSBwYWdlKVxuICAgICAqIEBtZW1iZXJvZiEgRmFjZXRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0FjdGl2ZTogWydib29sZWFuJywgZmFsc2UsIGZhbHNlXSxcblxuICAgIC8vIGdlbmVyYWwgZmFjZXQgcHJvcGVydGllc1xuICAgIC8qKlxuICAgICAqIERlc2NyaXB0aW9uIG9mIHRoaXMgZmFjZXQsIGZvciBkaXNwbGF5aW5nIHB1cnBvc2VzXG4gICAgICogQG1lbWJlcm9mISBGYWNldFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZGVzY3JpcHRpb246IFsnc3RyaW5nJywgdHJ1ZSwgJyddLFxuXG4gICAgLyoqXG4gICAgICogRm9yIGNvbnRpbnVvdXMgZmFjZXRzLCBpdHMgdW5pdHMgZm9yIGRpc3BsYXlpbmcgcHVycG9zZXNcbiAgICAgKiBAbWVtYmVyb2YhIEZhY2V0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB1bml0czogWydzdHJpbmcnLCB0cnVlLCAnJ10sXG5cbiAgICAvKipcbiAgICAgKiBTaG9ydCBuYW1lIChodW1hbiByZWFkYWJsZSkgZm9yIHRoaXMgZmFjZXQsIG11c3QgYmUgdW5pcXVlLlxuICAgICAqIEBtZW1iZXJvZiEgRmFjZXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIG5hbWU6IFsnc3RyaW5nJywgdHJ1ZSwgJyddLFxuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiB0aGlzIGZhY2V0OlxuICAgICAqICAqIGBjb25zdGFudGAgICAgICAgIEEgY29uc3RhbnQgdmFsdWUgb2YgXCIxXCIgZm9yIGFsbCBkYXRhIGl0ZW1zXG4gICAgICogICogYGNvbnRpbnVvdXNgICAgICAgVGhlIGZhY2V0IHRha2VzIG9uIHJlYWwgbnVtYmVyc1xuICAgICAqICAqIGBjYXRlZ29yaWFsYCAgICAgIFRoZSBmYWNldCBpcyBhIHN0cmluZywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyAoZm9yIGEgd2VsbCBkZWZpbmVkIHNldCBvZiBsYWJlbHMgYW5kIHRhZ3MpXG4gICAgICogICogYGRhdGV0aW1lYCAgICAgICAgVGhlIGZhY2V0IGlzIGEgZGF0ZXRpbWUgKHVzaW5nIG1vbWVudGpzLnR6KVxuICAgICAqICAqIGBkdXJhdGlvbmAgICAgICAgIFRoZSBmYWNldCBpcyBhIGR1cmF0aW9uICh1c2luZyBtb21lbnRqcy5kdXJhdGlvbilcbiAgICAgKiAgKiBgdGV4dGAgICAgICAgICAgICBGcmVlZm9ybSB0ZXh0LlxuICAgICAqIENoZWNrIGZvciBmYWNldCB0eXBlIHVzaW5nIGlzQ29uc3RhbnQsIGlzQ29udGludW91cywgaXNDYXRlZ29yaWFsLCBpc0RhdGV0aW1lLCBpc0R1cmF0aW9uLCBvciBpc1RleHQgIHByb3BlcnRpZXMuXG4gICAgICogQG1lbWJlcm9mISBGYWNldFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdHlwZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6ICdjYXRlZ29yaWFsJyxcbiAgICAgIHZhbHVlczogWydjb25zdGFudCcsICdjb250aW51b3VzJywgJ2NhdGVnb3JpYWwnLCAnZGF0ZXRpbWUnLCAnZHVyYXRpb24nLCAndGV4dCddXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBhY2Nlc3NvciBmb3IgdGhpcyBmYWNldC5cbiAgICAgKiBGb3IgbmVzdGVkIHByb3BlcnRpZXMgdXNlIGRvdCBub3RhdGlvbjogRm9yIGEgZGF0YXNldCBgWyB7bmFtZToge2ZpcnN0OiBcIlNhbnRhXCIsIGxhc3Q6IFwiQ2xhdXNcIn19LCAuLi5dYFxuICAgICAqIHlvdSBjYW4gdXNlIGBuYW1lLmZpcnN0YCBhbmQgYG5hbWUubGFzdGAgdG8gZ2V0IFNhbnRhIGFuZCBDbGF1cywgcmVzcGVjdGl2ZWx5LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mISBGYWNldFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgYWNjZXNzb3I6IFsnc3RyaW5nJywgZmFsc2UsIG51bGxdLFxuXG4gICAgLyoqXG4gICAgICogTWlzc2luZyBvciBpbnZhbGlkIGRhdGEgaW5kaWNhdG9yOyBmb3IgbXVsdGlwbGUgdmFsdWVzLCB1c2UgYSBjb21tYSBzZXBhcmF0ZWQsIHF1b3RlZCBsaXN0XG4gICAgICogTnVtYmVycywgc3RyaW5ncywgYm9vbGVhbnMsIGFuZCB0aGUgc3BlY2lhbCB2YWx1ZSBudWxsIGFyZSBhbGxvd2VkLlxuICAgICAqIFVzZSBzaW5nbGUgb3IgZG91YmxlIHF1b3RlcyBmb3Igc3RyaW5ncyBcIm1pc3NpbmdcIi5cbiAgICAgKiBUaGUgcGFyc2VkIHZhbHVlcyBhcmUgYXZhaWxhYmxlIGluIHRoZSBtaXN2YWwgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YhIEZhY2V0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBtaXN2YWxBc1RleHQ6ICdzdHJpbmcnLFxuXG4gICAgLyoqXG4gICAgICogRm9yIGNvbnRpbnVvdXMgb3IgZGF0ZXRpbWUgRmFjZXRzLCB0aGUgbWluaW11bSB2YWx1ZSBhcyB0ZXh0LlxuICAgICAqIFBhcnNlZCB2YWx1ZSBhdmFpbGFibGUgaW4gdGhlIGBtaW52YWxgIHByb3BlcnR5XG4gICAgICogQG1lbWJlcm9mISBGYWNldFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgbWludmFsQXNUZXh0OiAnc3RyaW5nJyxcblxuICAgIC8qKlxuICAgICAqIEZvciBjb250aW51b3VzIG9yIGRhdGV0aW1lIEZhY2V0cywgdGhlIG1heGltdW0gdmFsdWUgYXMgdGV4dC5cbiAgICAgKiBQYXJzZWQgdmFsdWUgYXZhaWxhYmxlIGluIHRoZSBgbWF4dmFsYCBwcm9wZXJ0eVxuICAgICAqIEBtZW1iZXJvZiEgRmFjZXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIG1heHZhbEFzVGV4dDogJ3N0cmluZydcbiAgfSxcbiAgY2hpbGRyZW46IHtcbiAgICAvKipcbiAgICAgKiBBIGNhdGVnb3JpYWwgdHJhbnNmb3JtYXRpb24gdG8gYXBwbHkgdG8gdGhlIGRhdGFcbiAgICAgKiBAbWVtYmVyb2YhIEZhY2V0XG4gICAgICogQHR5cGUge0NhdGVnb3JpYWxUcmFuc2Zvcm19XG4gICAgICovXG4gICAgY2F0ZWdvcmlhbFRyYW5zZm9ybTogQ2F0ZWdvcmlhbFRyYW5zZm9ybSxcbiAgICAvKipcbiAgICAgKiBBIGRhdGV0aW1lIHRyYW5zZm9ybWF0aW9uIHRvIGFwcGx5IHRvIHRoZSBkYXRhXG4gICAgICogQG1lbWJlcm9mISBGYWNldFxuICAgICAqIEB0eXBlIHtkYXRlaW1lVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIGRhdGV0aW1lVHJhbnNmb3JtOiBkYXRldGltZVRyYW5zZm9ybSxcbiAgICAvKipcbiAgICAgKiBBIGR1cmF0aW9uIHRyYW5zZm9ybWF0aW9uIHRvIGFwcGx5IHRvIHRoZSBkYXRhXG4gICAgICogQG1lbWJlcm9mISBGYWNldFxuICAgICAqIEB0eXBlIHtkYXRlaW1lVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIGR1cmF0aW9uVHJhbnNmb3JtOiBkdXJhdGlvblRyYW5zZm9ybSxcbiAgICAvKipcbiAgICAgKiBBIGNvbnRpbnVvdXMgdHJhbnNmb3JtYXRpb24gdG8gYXBwbHkgdG8gdGhlIGRhdGFcbiAgICAgKiBAbWVtYmVyb2YhIEZhY2V0XG4gICAgICogQHR5cGUge0NvbnRpbnVvdXNUcmFuc2Zvcm19XG4gICAgICovXG4gICAgY29udGludW91c1RyYW5zZm9ybTogQ29udGludW91c1RyYW5zZm9ybSxcbiAgICAvKipcbiAgICAgKiBBIHRleHQgdHJhbnNmb3JtXG4gICAgICogQG1lbWJlcm9mISBGYWNldFxuICAgICAqIEB0eXBlIHtUZXh0VHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRleHRUcmFuc2Zvcm06IHRleHRUcmFuc2Zvcm1cbiAgfSxcblxuICBkZXJpdmVkOiB7XG4gICAgLy8gcHJvcGVydGllcyBmb3I6IHR5cGVcbiAgICBpc0NvbnN0YW50OiB7XG4gICAgICBkZXBzOiBbJ3R5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdjb25zdGFudCc7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc0NvbnRpbnVvdXM6IHtcbiAgICAgIGRlcHM6IFsndHlwZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2NvbnRpbnVvdXMnO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNDYXRlZ29yaWFsOiB7XG4gICAgICBkZXBzOiBbJ3R5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdjYXRlZ29yaWFsJztcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzRGF0ZXRpbWU6IHtcbiAgICAgIGRlcHM6IFsndHlwZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2RhdGV0aW1lJztcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzRHVyYXRpb246IHtcbiAgICAgIGRlcHM6IFsndHlwZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2R1cmF0aW9uJztcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzVGV4dDoge1xuICAgICAgZGVwczogWyd0eXBlJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAndGV4dCc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIG1pc3NpbmcgZGF0YSBpbmRpY2F0b3JzXG4gICAgICogQG1lbWJlcm9mISBGYWNldFxuICAgICAqIEB0eXBlIHtPYmplY3RbXX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBtaXN2YWw6IHtcbiAgICAgIGRlcHM6IFsnbWlzdmFsQXNUZXh0J10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJzZSB0aGUgdGV4dCBjb250ZW50IGFzIGEgSlNPTiBhcnJheTpcbiAgICAgICAgLy8gIC0gc3RyaW5ncyBzaG91bGQgYmUgcXVvdGVkXG4gICAgICAgIC8vICAtIG51bWJlcnMgdW5xdW9hdGVkXG4gICAgICAgIC8vICAtIHNwZWNpYWwgbnVtYmVycyBub3QgYWxsb3dlZDogTmFOLCBJbmZpbml0eVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0aGlzLm1pc3ZhbEFzVGV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoJ1snICsgdGhpcy5taXN2YWxBc1RleHQgKyAnXScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FjaGU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZvciBjb250aW51b3VzIG9yIGRhdGV0aW1lIEZhY2V0cywgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQG1lbWJlcm9mISBGYWNldFxuICAgICAqIEB0eXBlIHtudW1iZXJ8ZGF0ZXRpbWV9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgbWludmFsOiB7XG4gICAgICBkZXBzOiBbJ21pbnZhbEFzVGV4dCcsICd0eXBlJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWluO1xuICAgICAgICBpZiAodGhpcy5pc0NvbnRpbnVvdXMpIHtcbiAgICAgICAgICBtaW4gPSBwYXJzZUZsb2F0KHRoaXMubWludmFsQXNUZXh0KTtcbiAgICAgICAgICBpZiAoaXNOYU4obWluKSkge1xuICAgICAgICAgICAgbWluID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0RhdGV0aW1lKSB7XG4gICAgICAgICAgbWluID0gbW9tZW50KHRoaXMubWludmFsQXNUZXh0LCBtb21lbnQuSVNPXzg2MDEpO1xuICAgICAgICAgIGlmICghbWluLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgbWluID0gbW9tZW50KCcyMDEwLTAxLTAxIDAwOjAwJywgbW9tZW50LklTT184NjAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0R1cmF0aW9uKSB7XG4gICAgICAgICAgbWluID0gbW9tZW50LmR1cmF0aW9uKHRoaXMubWludmFsQXNUZXh0KTtcbiAgICAgICAgICBpZiAoIW1vbWVudC5pc0R1cmF0aW9uKG1pbikpIHtcbiAgICAgICAgICAgIG1pbiA9IG1vbWVudC5kdXJhdGlvbigxLCAnc2Vjb25kcycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgICAgfSxcbiAgICAgIGNhY2hlOiBmYWxzZVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogRm9yIGNvbnRpbnVvdXMgb3IgZGF0ZXRpbWUgRmFjZXRzLCB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAbWVtYmVyb2YhIEZhY2V0XG4gICAgICogQHR5cGUge251bWJlcnxkYXRldGltZX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBtYXh2YWw6IHtcbiAgICAgIGRlcHM6IFsnbWF4dmFsQXNUZXh0JywgJ3R5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXg7XG4gICAgICAgIGlmICh0aGlzLmlzQ29udGludW91cykge1xuICAgICAgICAgIG1heCA9IHBhcnNlRmxvYXQodGhpcy5tYXh2YWxBc1RleHQpO1xuICAgICAgICAgIGlmIChpc05hTihtYXgpKSB7XG4gICAgICAgICAgICBtYXggPSAxMDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNEYXRldGltZSkge1xuICAgICAgICAgIG1heCA9IG1vbWVudCh0aGlzLm1heHZhbEFzVGV4dCwgbW9tZW50LklTT184NjAxKTtcbiAgICAgICAgICBpZiAoIW1heC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIG1heCA9IG1vbWVudCgnMjAyMC0wMS0wMSAwMDowMCcsIG1vbWVudC5JU09fODYwMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNEdXJhdGlvbikge1xuICAgICAgICAgIG1heCA9IG1vbWVudC5kdXJhdGlvbih0aGlzLm1heHZhbEFzVGV4dCk7XG4gICAgICAgICAgaWYgKCFtb21lbnQuaXNEdXJhdGlvbihtYXgpKSB7XG4gICAgICAgICAgICBtYXggPSBtb21lbnQuZHVyYXRpb24oMTAwLCAnc2Vjb25kcycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgfSxcbiAgICAgIGNhY2hlOiBmYWxzZVxuICAgIH0sXG4gICAgdHJhbnNmb3JtOiB7XG4gICAgICBkZXBzOiBbJ3R5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29udGludW91cykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRpbnVvdXNUcmFuc2Zvcm07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0NhdGVnb3JpYWwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jYXRlZ29yaWFsVHJhbnNmb3JtO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNEYXRldGltZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRhdGV0aW1lVHJhbnNmb3JtO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNEdXJhdGlvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmR1cmF0aW9uVHJhbnNmb3JtO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNUZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGV4dFRyYW5zZm9ybTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGZhY2V0Jyk7XG4gICAgICB9LFxuICAgICAgY2FjaGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICAvKipcbiAgICogc2V0TWluTWF4IHNldHMgdGhlIHJhbmdlIG9mIGEgY29udGludW91cyBvciB0aW1lIGZhY2V0XG4gICAqIEZvciBmYWNldHMgaW4gYSBkYXRhdmlldywgdGhlIG1pbmltdW0gaXMganVzdCB0aGUgbWluaW11bSBvZiB0aGUgZmFjZXQgb3ZlciBhbGwgYWN0aXZlIGRhdGFzZXRzLFxuICAgKiBhbmQgdGhlIHNhbWUgZm9yIHRoZSBtYXhpbXVtLlxuICAgKiBGb3IgZmFjZXRzIGluIGEgZGF0c2V0LCB0aGUgYWN0dWFsIGltcGxlbWVudGF0aW9uIGlzIGluIHRoZSBkYXRhc2V0IGRyaXZlci5cbiAgICpcbiAgICogQG1lbWJlcm9mISBGYWNldFxuICAgKi9cbiAgc2V0TWluTWF4OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIERhdGFzZXQgPSByZXF1aXJlKCcuL2RhdGFzZXQnKTtcbiAgICB2YXIgRGF0YXZpZXcgPSByZXF1aXJlKCcuL2RhdGF2aWV3Jyk7XG5cbiAgICB2YXIgYW5jZXN0b3IgPSB0aGlzLmNvbGxlY3Rpb24ucGFyZW50O1xuICAgIHZhciBzcG90O1xuXG4gICAgaWYgKGFuY2VzdG9yIGluc3RhbmNlb2YgRGF0YXZpZXcpIHtcbiAgICAgIC8vIEZhY2V0IC0+IEZhY2V0cyAtPiBEYXRhdmlldyAtPiBTcG90XG4gICAgICBzcG90ID0gdGhpcy5jb2xsZWN0aW9uLnBhcmVudC5wYXJlbnQ7XG4gICAgICBzcG90LnNldEZhY2V0TWluTWF4KHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoYW5jZXN0b3IgaW5zdGFuY2VvZiBEYXRhc2V0KSB7XG4gICAgICAvLyBEYXRhc2V0IC0+IERhdGFzZXRzIC0+IFNwb3RcbiAgICAgIHNwb3QgPSBhbmNlc3Rvci5jb2xsZWN0aW9uLnBhcmVudDtcbiAgICAgIHNwb3QuZHJpdmVyLnNldE1pbk1heChhbmNlc3RvciwgdGhpcyk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogc2V0Q2F0ZWdvcmllcyBmaW5kcyBmaW5kcyBhbGwgdmFsdWVzIG9uIGFuIG9yZGluYWwgKGNhdGVnb3JpYWwpIGF4aXNcbiAgICogVXBkYXRlcyB0aGUgY2F0ZWdvcmlhbFRyYW5zZm9ybSBvZiB0aGUgZmFjZXRcbiAgICogRm9yIGZhY2V0cyBpbiBhIGRhdGF2aWV3LCB0aGlzIGlzIHRoZSB1bmlvbiBvZiB0aGUgY2F0ZWdvcmllcyBvZiBmYWNldCBvdmVyIGFsbCBhY3RpdmUgZGF0YXNldHMuXG4gICAqIEZvciBmYWNldHMgaW4gYSBkYXRhc2V0LCB0aGUgYWN0dWFsIGltcGxlbWVudGF0aW9uIGlzIGluIHRoZSBkYXRhc2V0IGRyaXZlci5cbiAgICpcbiAgICogQG1lbWJlcm9mISBGYWNldFxuICAgKi9cbiAgc2V0Q2F0ZWdvcmllczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBEYXRhc2V0ID0gcmVxdWlyZSgnLi9kYXRhc2V0Jyk7XG4gICAgdmFyIERhdGF2aWV3ID0gcmVxdWlyZSgnLi9kYXRhdmlldycpO1xuXG4gICAgdmFyIGFuY2VzdG9yID0gdGhpcy5jb2xsZWN0aW9uLnBhcmVudDtcbiAgICB2YXIgc3BvdDtcblxuICAgIGlmIChhbmNlc3RvciBpbnN0YW5jZW9mIERhdGF2aWV3KSB7XG4gICAgICAvLyBGYWNldCAtPiBGYWNldHMgLT4gRGF0YXZpZXcgLT4gU3BvdFxuICAgICAgc3BvdCA9IHRoaXMuY29sbGVjdGlvbi5wYXJlbnQucGFyZW50O1xuICAgICAgc3BvdC5zZXRGYWNldENhdGVnb3JpZXModGhpcyk7XG4gICAgfSBlbHNlIGlmIChhbmNlc3RvciBpbnN0YW5jZW9mIERhdGFzZXQpIHtcbiAgICAgIC8vIEZhY2V0IC0+IEZhY2V0cyAtPiBEYXRhc2V0IC0+IERhdGFzZXRzIC0+IFNwb3RcbiAgICAgIHNwb3QgPSBhbmNlc3Rvci5jb2xsZWN0aW9uLnBhcmVudDtcbiAgICAgIHNwb3QuZHJpdmVyLnNldENhdGVnb3JpZXMoYW5jZXN0b3IsIHRoaXMpO1xuICAgIH1cbiAgfVxufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4d50\n")},5066:function(module,exports,__webpack_require__){eval("/**\n * A Dataview is a join of Datasets\n *\n * @class Dataview\n * @extends Base\n */\nvar Crossfilter = __webpack_require__(/*! crossfilter2 */ \"cd9f\"); // TODO: only for client side datasets\nvar BaseModel = __webpack_require__(/*! ./util/base */ \"3902\");\nvar Filters = __webpack_require__(/*! ./filter/collection */ \"7fa4\");\nvar Facets = __webpack_require__(/*! ./facet/collection */ \"51fb\");\n\nfunction getData () {\n  if (this.isPaused) {\n    return;\n  }\n  console.time('Get data');\n\n  var spot = this.parent;\n\n  return spot.driver.getData(this);\n}\n\nmodule.exports = BaseModel.extend({\n  initialize: function () {\n    // first do parent class initialization\n    BaseModel.prototype.initialize.apply(this, arguments);\n\n    /**\n     * Crossfilter instance, see [here](http://square.github.io/crossfilter/)\n     * used for client side data handling.\n     *\n     * @memberof! Dataset\n     */\n    this.crossfilter = new Crossfilter([]);\n    this.countGroup = this.crossfilter.groupAll().reduceCount();\n  },\n  props: {\n    /**\n     * Total number of datapoints in the current dataview\n     *\n     * @memberof! Dataview\n     * @readonly\n     * @type {number}\n     */\n    dataTotal: ['number', true, 0],\n    /**\n     * Number of datapoints that are currently selected\n     *\n     * @memberof! Dataview\n     * @readonly\n     * @type {number}\n     */\n    dataSelected: ['number', true, 0],\n    /**\n     * DatasetId's of active datasets\n     *\n     * @memberof! Dataview\n     * @type {String[]}\n     */\n    datasetIds: {\n      type: 'array',\n      default: function () {\n        return [];\n      }\n    }\n  },\n  session: {\n    /**\n     * isPaused when true, calls to getAllData are ignored.\n     * This is useful to suppres calls to getData\n     * when adding and removing a number of filters at once.\n     * @memberof! Dataview\n     * @type {boolean}\n     */\n    isPaused: ['boolean', true, false]\n  },\n  collections: {\n    /**\n     * A Facet collection holding pre defined facets\n     *\n     * @memberof! Dataview\n     * @type {Facet[]}\n     */\n    facets: Facets,\n    /**\n     * A Filter collection holding all active filters on the dataview\n     *\n     * @memberof! Dataview\n     * @type {Filter[]}\n     */\n    filters: Filters\n  },\n  /**\n   * Pause the dataview. This means calls to getData are blocked.\n   * Useful when updating a lot of filters and you are not interested in the intermediate state.\n   *\n   * @memberof! Dataview\n   */\n  pause: function () {\n    this.isPaused = true;\n  },\n  /**\n   * Unpause the dataview.\n   *\n   * @memberof! Dataview\n   */\n  play: function () {\n    this.isPaused = false;\n  },\n\n  /**\n   * Get data for all filters linked to this dataview.\n   * When data has become available for a filter, a `newData` event is triggered on that filter.\n   *\n   * @memberof! Dataview\n   * @function\n   */\n  getData: getData\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA2Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZGF0YXZpZXcuanM/NGQ0YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgRGF0YXZpZXcgaXMgYSBqb2luIG9mIERhdGFzZXRzXG4gKlxuICogQGNsYXNzIERhdGF2aWV3XG4gKiBAZXh0ZW5kcyBCYXNlXG4gKi9cbnZhciBDcm9zc2ZpbHRlciA9IHJlcXVpcmUoJ2Nyb3NzZmlsdGVyMicpOyAvLyBUT0RPOiBvbmx5IGZvciBjbGllbnQgc2lkZSBkYXRhc2V0c1xudmFyIEJhc2VNb2RlbCA9IHJlcXVpcmUoJy4vdXRpbC9iYXNlJyk7XG52YXIgRmlsdGVycyA9IHJlcXVpcmUoJy4vZmlsdGVyL2NvbGxlY3Rpb24nKTtcbnZhciBGYWNldHMgPSByZXF1aXJlKCcuL2ZhY2V0L2NvbGxlY3Rpb24nKTtcblxuZnVuY3Rpb24gZ2V0RGF0YSAoKSB7XG4gIGlmICh0aGlzLmlzUGF1c2VkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUudGltZSgnR2V0IGRhdGEnKTtcblxuICB2YXIgc3BvdCA9IHRoaXMucGFyZW50O1xuXG4gIHJldHVybiBzcG90LmRyaXZlci5nZXREYXRhKHRoaXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VNb2RlbC5leHRlbmQoe1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZmlyc3QgZG8gcGFyZW50IGNsYXNzIGluaXRpYWxpemF0aW9uXG4gICAgQmFzZU1vZGVsLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvKipcbiAgICAgKiBDcm9zc2ZpbHRlciBpbnN0YW5jZSwgc2VlIFtoZXJlXShodHRwOi8vc3F1YXJlLmdpdGh1Yi5pby9jcm9zc2ZpbHRlci8pXG4gICAgICogdXNlZCBmb3IgY2xpZW50IHNpZGUgZGF0YSBoYW5kbGluZy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiEgRGF0YXNldFxuICAgICAqL1xuICAgIHRoaXMuY3Jvc3NmaWx0ZXIgPSBuZXcgQ3Jvc3NmaWx0ZXIoW10pO1xuICAgIHRoaXMuY291bnRHcm91cCA9IHRoaXMuY3Jvc3NmaWx0ZXIuZ3JvdXBBbGwoKS5yZWR1Y2VDb3VudCgpO1xuICB9LFxuICBwcm9wczoge1xuICAgIC8qKlxuICAgICAqIFRvdGFsIG51bWJlciBvZiBkYXRhcG9pbnRzIGluIHRoZSBjdXJyZW50IGRhdGF2aWV3XG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YhIERhdGF2aWV3XG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBkYXRhVG90YWw6IFsnbnVtYmVyJywgdHJ1ZSwgMF0sXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGRhdGFwb2ludHMgdGhhdCBhcmUgY3VycmVudGx5IHNlbGVjdGVkXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YhIERhdGF2aWV3XG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBkYXRhU2VsZWN0ZWQ6IFsnbnVtYmVyJywgdHJ1ZSwgMF0sXG4gICAgLyoqXG4gICAgICogRGF0YXNldElkJ3Mgb2YgYWN0aXZlIGRhdGFzZXRzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YhIERhdGF2aWV3XG4gICAgICogQHR5cGUge1N0cmluZ1tdfVxuICAgICAqL1xuICAgIGRhdGFzZXRJZHM6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNlc3Npb246IHtcbiAgICAvKipcbiAgICAgKiBpc1BhdXNlZCB3aGVuIHRydWUsIGNhbGxzIHRvIGdldEFsbERhdGEgYXJlIGlnbm9yZWQuXG4gICAgICogVGhpcyBpcyB1c2VmdWwgdG8gc3VwcHJlcyBjYWxscyB0byBnZXREYXRhXG4gICAgICogd2hlbiBhZGRpbmcgYW5kIHJlbW92aW5nIGEgbnVtYmVyIG9mIGZpbHRlcnMgYXQgb25jZS5cbiAgICAgKiBAbWVtYmVyb2YhIERhdGF2aWV3XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNQYXVzZWQ6IFsnYm9vbGVhbicsIHRydWUsIGZhbHNlXVxuICB9LFxuICBjb2xsZWN0aW9uczoge1xuICAgIC8qKlxuICAgICAqIEEgRmFjZXQgY29sbGVjdGlvbiBob2xkaW5nIHByZSBkZWZpbmVkIGZhY2V0c1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mISBEYXRhdmlld1xuICAgICAqIEB0eXBlIHtGYWNldFtdfVxuICAgICAqL1xuICAgIGZhY2V0czogRmFjZXRzLFxuICAgIC8qKlxuICAgICAqIEEgRmlsdGVyIGNvbGxlY3Rpb24gaG9sZGluZyBhbGwgYWN0aXZlIGZpbHRlcnMgb24gdGhlIGRhdGF2aWV3XG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YhIERhdGF2aWV3XG4gICAgICogQHR5cGUge0ZpbHRlcltdfVxuICAgICAqL1xuICAgIGZpbHRlcnM6IEZpbHRlcnNcbiAgfSxcbiAgLyoqXG4gICAqIFBhdXNlIHRoZSBkYXRhdmlldy4gVGhpcyBtZWFucyBjYWxscyB0byBnZXREYXRhIGFyZSBibG9ja2VkLlxuICAgKiBVc2VmdWwgd2hlbiB1cGRhdGluZyBhIGxvdCBvZiBmaWx0ZXJzIGFuZCB5b3UgYXJlIG5vdCBpbnRlcmVzdGVkIGluIHRoZSBpbnRlcm1lZGlhdGUgc3RhdGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiEgRGF0YXZpZXdcbiAgICovXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gIH0sXG4gIC8qKlxuICAgKiBVbnBhdXNlIHRoZSBkYXRhdmlldy5cbiAgICpcbiAgICogQG1lbWJlcm9mISBEYXRhdmlld1xuICAgKi9cbiAgcGxheTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGRhdGEgZm9yIGFsbCBmaWx0ZXJzIGxpbmtlZCB0byB0aGlzIGRhdGF2aWV3LlxuICAgKiBXaGVuIGRhdGEgaGFzIGJlY29tZSBhdmFpbGFibGUgZm9yIGEgZmlsdGVyLCBhIGBuZXdEYXRhYCBldmVudCBpcyB0cmlnZ2VyZWQgb24gdGhhdCBmaWx0ZXIuXG4gICAqXG4gICAqIEBtZW1iZXJvZiEgRGF0YXZpZXdcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBnZXREYXRhOiBnZXREYXRhXG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5066\n")},"51fb":function(module,exports,__webpack_require__){eval("var Collection = __webpack_require__(/*! ampersand-collection */ \"7bd3\");\nvar Facet = __webpack_require__(/*! ../facet */ \"4d50\");\n\nmodule.exports = Collection.extend({\n  model: Facet,\n  mainIndex: 'id',\n  indexes: ['name'],\n  session: {\n    needle: ['string', true, ''], // search string used on the Facet page\n    showSearch: ['boolean', true, false] // show/hide the search bar on the Facet page\n  },\n  comparator: function (left, right) {\n    return left.name.localeCompare(right.name);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTFmYi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmFjZXQvY29sbGVjdGlvbi5qcz84ZWU5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnYW1wZXJzYW5kLWNvbGxlY3Rpb24nKTtcbnZhciBGYWNldCA9IHJlcXVpcmUoJy4uL2ZhY2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGlvbi5leHRlbmQoe1xuICBtb2RlbDogRmFjZXQsXG4gIG1haW5JbmRleDogJ2lkJyxcbiAgaW5kZXhlczogWyduYW1lJ10sXG4gIHNlc3Npb246IHtcbiAgICBuZWVkbGU6IFsnc3RyaW5nJywgdHJ1ZSwgJyddLCAvLyBzZWFyY2ggc3RyaW5nIHVzZWQgb24gdGhlIEZhY2V0IHBhZ2VcbiAgICBzaG93U2VhcmNoOiBbJ2Jvb2xlYW4nLCB0cnVlLCBmYWxzZV0gLy8gc2hvdy9oaWRlIHRoZSBzZWFyY2ggYmFyIG9uIHRoZSBGYWNldCBwYWdlXG4gIH0sXG4gIGNvbXBhcmF0b3I6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBsZWZ0Lm5hbWUubG9jYWxlQ29tcGFyZShyaWdodC5uYW1lKTtcbiAgfVxufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///51fb\n")},"544d":function(module,exports,__webpack_require__){eval("var Collection = __webpack_require__(/*! ampersand-collection */ \"7bd3\");\nvar Dataset = __webpack_require__(/*! ../dataset */ \"545a\");\n\nmodule.exports = Collection.extend({\n  mainIndex: 'id',\n  indexes: ['name'],\n  model: Dataset\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ0ZC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZGF0YXNldC9jb2xsZWN0aW9uLmpzPzkxZDkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCdhbXBlcnNhbmQtY29sbGVjdGlvbicpO1xudmFyIERhdGFzZXQgPSByZXF1aXJlKCcuLi9kYXRhc2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGlvbi5leHRlbmQoe1xuICBtYWluSW5kZXg6ICdpZCcsXG4gIGluZGV4ZXM6IFsnbmFtZSddLFxuICBtb2RlbDogRGF0YXNldFxufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///544d\n")},"545a":function(module,exports,__webpack_require__){eval("/**\n * @class Dataset\n * @extends Base\n */\nvar Crossfilter = __webpack_require__(/*! crossfilter2 */ \"cd9f\"); // TODO: only for client side datasets\nvar BaseModel = __webpack_require__(/*! ./util/base */ \"3902\");\nvar Facets = __webpack_require__(/*! ./facet/collection */ \"51fb\");\n\nmodule.exports = BaseModel.extend({\n  initialize: function () {\n    // first do parent class initialization\n    BaseModel.prototype.initialize.apply(this, arguments);\n\n    /**\n     * Crossfilter instance, see [here](http://square.github.io/crossfilter/)\n     * used for client side data handling.\n     *\n     * @memberof! Dataset\n     */\n    this.crossfilter = new Crossfilter([]);\n    this.countGroup = this.crossfilter.groupAll().reduceCount();\n  },\n  props: {\n    /**\n     * Name of the dataset\n     * @memberof! Dataset\n     * @type {string}\n     */\n    name: {\n      type: 'string',\n      required: true,\n      default: 'Name'\n    },\n    /**\n     * URL, fi. to paper, dataset owner, etc.\n     * @memberof! Dataset\n     * @type {string}\n     */\n    URL: {\n      type: 'string',\n      required: true,\n      default: 'URL'\n    },\n    /**\n     * Database table name for server datasets\n     * @memberof! Dataset\n     * @type {string}\n     */\n    databaseTable: {\n      type: 'string',\n      default: ''\n    },\n    /**\n     * Short description of the dataset\n     * @memberof! Dataset\n     * @type {string}\n     */\n    description: {\n      type: 'string',\n      required: true,\n      default: 'Description'\n    },\n    /**\n     * If dataset is part of the current session\n     * @memberof! Dataset\n     * @type {boolean}\n     */\n    isActive: {\n      type: 'boolean',\n      required: true,\n      default: false\n    }\n  },\n  session: {\n    /**\n     * For searching through datasets URL and description.\n     * True if this dataset matches the search paramters.\n     */\n    show: {\n      type: 'boolean',\n      required: true,\n      default: true\n    },\n    data: {\n      type: 'array',\n      default: function () {\n        return [];\n      }\n    }\n  },\n  collections: {\n    /**\n     * A Facet collection holding pre defined facets\n     * @memberof! Dataset\n     * @type {Facet[]}\n     */\n    facets: Facets\n  },\n  scan: function () {\n    // Dataset -> Datasets -> spot\n    var spot = this.collection.parent;\n\n    // clear all existing facets\n    this.facets.reset();\n\n    spot.driver.scan(this);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ1YS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZGF0YXNldC5qcz9lYTcwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGNsYXNzIERhdGFzZXRcbiAqIEBleHRlbmRzIEJhc2VcbiAqL1xudmFyIENyb3NzZmlsdGVyID0gcmVxdWlyZSgnY3Jvc3NmaWx0ZXIyJyk7IC8vIFRPRE86IG9ubHkgZm9yIGNsaWVudCBzaWRlIGRhdGFzZXRzXG52YXIgQmFzZU1vZGVsID0gcmVxdWlyZSgnLi91dGlsL2Jhc2UnKTtcbnZhciBGYWNldHMgPSByZXF1aXJlKCcuL2ZhY2V0L2NvbGxlY3Rpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlTW9kZWwuZXh0ZW5kKHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIC8vIGZpcnN0IGRvIHBhcmVudCBjbGFzcyBpbml0aWFsaXphdGlvblxuICAgIEJhc2VNb2RlbC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLyoqXG4gICAgICogQ3Jvc3NmaWx0ZXIgaW5zdGFuY2UsIHNlZSBbaGVyZV0oaHR0cDovL3NxdWFyZS5naXRodWIuaW8vY3Jvc3NmaWx0ZXIvKVxuICAgICAqIHVzZWQgZm9yIGNsaWVudCBzaWRlIGRhdGEgaGFuZGxpbmcuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YhIERhdGFzZXRcbiAgICAgKi9cbiAgICB0aGlzLmNyb3NzZmlsdGVyID0gbmV3IENyb3NzZmlsdGVyKFtdKTtcbiAgICB0aGlzLmNvdW50R3JvdXAgPSB0aGlzLmNyb3NzZmlsdGVyLmdyb3VwQWxsKCkucmVkdWNlQ291bnQoKTtcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoZSBkYXRhc2V0XG4gICAgICogQG1lbWJlcm9mISBEYXRhc2V0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBuYW1lOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZGVmYXVsdDogJ05hbWUnXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBVUkwsIGZpLiB0byBwYXBlciwgZGF0YXNldCBvd25lciwgZXRjLlxuICAgICAqIEBtZW1iZXJvZiEgRGF0YXNldFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgVVJMOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZGVmYXVsdDogJ1VSTCdcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERhdGFiYXNlIHRhYmxlIG5hbWUgZm9yIHNlcnZlciBkYXRhc2V0c1xuICAgICAqIEBtZW1iZXJvZiEgRGF0YXNldFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZGF0YWJhc2VUYWJsZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiAnJ1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2hvcnQgZGVzY3JpcHRpb24gb2YgdGhlIGRhdGFzZXRcbiAgICAgKiBAbWVtYmVyb2YhIERhdGFzZXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGRlc2NyaXB0aW9uOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZGVmYXVsdDogJ0Rlc2NyaXB0aW9uJ1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSWYgZGF0YXNldCBpcyBwYXJ0IG9mIHRoZSBjdXJyZW50IHNlc3Npb25cbiAgICAgKiBAbWVtYmVyb2YhIERhdGFzZXRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0FjdGl2ZToge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgc2Vzc2lvbjoge1xuICAgIC8qKlxuICAgICAqIEZvciBzZWFyY2hpbmcgdGhyb3VnaCBkYXRhc2V0cyBVUkwgYW5kIGRlc2NyaXB0aW9uLlxuICAgICAqIFRydWUgaWYgdGhpcyBkYXRhc2V0IG1hdGNoZXMgdGhlIHNlYXJjaCBwYXJhbXRlcnMuXG4gICAgICovXG4gICAgc2hvdzoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBkYXRhOiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb2xsZWN0aW9uczoge1xuICAgIC8qKlxuICAgICAqIEEgRmFjZXQgY29sbGVjdGlvbiBob2xkaW5nIHByZSBkZWZpbmVkIGZhY2V0c1xuICAgICAqIEBtZW1iZXJvZiEgRGF0YXNldFxuICAgICAqIEB0eXBlIHtGYWNldFtdfVxuICAgICAqL1xuICAgIGZhY2V0czogRmFjZXRzXG4gIH0sXG4gIHNjYW46IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBEYXRhc2V0IC0+IERhdGFzZXRzIC0+IHNwb3RcbiAgICB2YXIgc3BvdCA9IHRoaXMuY29sbGVjdGlvbi5wYXJlbnQ7XG5cbiAgICAvLyBjbGVhciBhbGwgZXhpc3RpbmcgZmFjZXRzXG4gICAgdGhpcy5mYWNldHMucmVzZXQoKTtcblxuICAgIHNwb3QuZHJpdmVyLnNjYW4odGhpcyk7XG4gIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///545a\n")},"58ab":function(module,exports,__webpack_require__){eval('\nmodule.exports = __webpack_require__(/*! ./socket */ "0112");\n\n/**\n * Exports parser\n *\n * @api public\n *\n */\nmodule.exports.parser = __webpack_require__(/*! engine.io-parser */ "aa6c");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNThhYi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanM/ZWViYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnRzIHBhcnNlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///58ab\n')},"5a80":function(module,exports,__webpack_require__){eval("/**\n * ContinuousTransfrom defines a transformation on continuous (nummerical) data.\n * Currently linear interpolation between a set of control points is implemented.\n *\n * @class ContinuousTransform\n */\nvar AmpersandModel = __webpack_require__(/*! ampersand-model */ \"3bfc\");\nvar Collection = __webpack_require__(/*! ampersand-collection */ \"7bd3\");\nvar misval = __webpack_require__(/*! ../util/misval */ \"bff6\");\n\nvar ControlPoint = __webpack_require__(/*! ./control-point */ \"09c5\");\nvar ControlPoints = Collection.extend({\n  model: ControlPoint\n});\n\n/**\n * Apply piecewise linear transformation\n * The function is constant outside the range spanned by the control points;\n * there it is set to value of the first, or the last, control points.\n *\n * @function\n * @memberof! ContinuousTransform\n * @param {number} x\n * @returns {number} fx\n */\nfunction transform (cps, x) {\n  if (x === misval) {\n    return misval;\n  }\n\n  var ncps = cps.models.length;\n  if (x <= cps.models[0].x) {\n    // outside range on left side\n    return cps.models[0].fx;\n  } else if (x >= cps.models[ncps - 1].x) {\n    // outside range on right side\n    return cps.models[ncps - 1].fx;\n  } else {\n    // inside range\n    var i = 0;\n    while (x > cps.models[i].x) {\n      i = i + 1;\n    }\n\n    // linear interpolate between fx_i and fx_(i+1)\n    var xm = cps.models[i].x;\n    var xp = cps.models[i + 1].x;\n    var fxm = cps.models[i].fx;\n    var fxp = cps.models[i + 1].fx;\n    if (xp === xm) {\n      return 0.5 * (fxm + fxp);\n    } else {\n      return fxm + (x - xm) * (fxp - fxm) / (xp - xm);\n    }\n  }\n}\n\n/**\n * The inverse of the transform\n *\n * @function\n * @memberof! ContinuousTransform\n * @param {number} fx\n * @returns {number} x\n */\nfunction inverse (cps, fx) {\n  if (fx === misval) {\n    return misval;\n  }\n\n  var ncps = cps.models.length;\n  if (fx <= cps.models[0].fx) {\n    // outside range on left side\n    return cps.models[0].x;\n  } else if (fx >= cps.models[ncps - 1].fx) {\n    // outside range on right side\n    return cps.models[ncps - 1].x;\n  } else {\n    // inside range\n    var i = 0;\n    while (fx > cps.models[i].fx) {\n      i = i + 1;\n    }\n\n    // linear interpolate between fx_i and fx_(i+1)\n    var xm = cps.models[i].x;\n    var xp = cps.models[i + 1].x;\n    var fxm = cps.models[i].fx;\n    var fxp = cps.models[i + 1].fx;\n    if (fxp === fxm) {\n      return 0.5 * (xm + xp);\n    } else {\n      return xm + (fx - fxm) * (xp - xm) / (fxp - fxm);\n    }\n  }\n}\n\nmodule.exports = AmpersandModel.extend({\n  props: {\n    /**\n     * The type of continuous transform, can be none, or percentiles\n     * Use isNone, or isPercentiles, check for transform type\n     * @memberof! ContinuousTransform\n     */\n    type: {\n      type: 'string',\n      required: true,\n      default: 'none',\n      values: ['none', 'percentiles']\n    },\n    transformedType: {\n      type: 'string',\n      required: true,\n      default: 'continuous',\n      values: ['continuous']\n    }\n  },\n  derived: {\n    isNone: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'none';\n      }\n    },\n    isPercentiles: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'percentiles';\n      }\n    },\n    /**\n     * The minimum value this facet can take, after the transformation has been applied\n     * @type {number}\n     * @memberof! ContinuousTransform\n     */\n    transformedMin: {\n      deps: ['type'],\n      fn: function () {\n        if (this.isPercentiles) {\n          return 0;\n        } else if (this.isNone) {\n          return this.parent.minval;\n        } else {\n          console.error('Invalid continuous transform');\n        }\n      },\n      cache: false\n    },\n    /**\n     * The maximum value this facet can take, after the transformation has been applied\n     * @type {number}\n     * @memberof! ContinuousTransform\n     */\n    transformedMax: {\n      deps: ['type'],\n      fn: function () {\n        if (this.isPercentiles) {\n          return 100;\n        } else if (this.isNone) {\n          return this.parent.maxval;\n        } else {\n          console.error('Invalid continuous transform');\n        }\n      },\n      cache: false\n    },\n    /**\n     * The minimum value this facet can take, after the transformation has been applied\n     *\n     * @type {string}\n     * @memberof! ContinuousTransform\n     */\n    transformedMinAsText: {\n      deps: ['transformedMin', 'transformedType'],\n      fn: function () {\n        var minval = this.transformedMin;\n        if (this.transformedType === 'datetime') {\n          return minval.format();\n        } else {\n          return minval.toString();\n        }\n      },\n      cache: false\n    },\n    /**\n     * The maximum value this facet can take, after the transformation has been applied\n     *\n     * @type {string}\n     * @memberof! ContinuousTransform\n     */\n    transformedMaxAsText: {\n      deps: ['transformedMax', 'transformedType'],\n      fn: function () {\n        var maxval = this.transformedMax;\n        if (this.transformedType === 'datetime') {\n          return maxval.format();\n        } else {\n          return maxval.toString();\n        }\n      },\n      cache: false\n    }\n  },\n  collections: {\n    cps: ControlPoints\n  },\n  transform: function (x) {\n    return transform(this.cps, x);\n  },\n  inverse: function (fx) {\n    return inverse(this.cps, fx);\n  },\n  reset: function () {\n    this.type = 'none';\n    this.cps.reset();\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNWE4MC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmFjZXQvY29udGludW91cy10cmFuc2Zvcm0uanM/YzgwOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbnRpbnVvdXNUcmFuc2Zyb20gZGVmaW5lcyBhIHRyYW5zZm9ybWF0aW9uIG9uIGNvbnRpbnVvdXMgKG51bW1lcmljYWwpIGRhdGEuXG4gKiBDdXJyZW50bHkgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiBhIHNldCBvZiBjb250cm9sIHBvaW50cyBpcyBpbXBsZW1lbnRlZC5cbiAqXG4gKiBAY2xhc3MgQ29udGludW91c1RyYW5zZm9ybVxuICovXG52YXIgQW1wZXJzYW5kTW9kZWwgPSByZXF1aXJlKCdhbXBlcnNhbmQtbW9kZWwnKTtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnYW1wZXJzYW5kLWNvbGxlY3Rpb24nKTtcbnZhciBtaXN2YWwgPSByZXF1aXJlKCcuLi91dGlsL21pc3ZhbCcpO1xuXG52YXIgQ29udHJvbFBvaW50ID0gcmVxdWlyZSgnLi9jb250cm9sLXBvaW50Jyk7XG52YXIgQ29udHJvbFBvaW50cyA9IENvbGxlY3Rpb24uZXh0ZW5kKHtcbiAgbW9kZWw6IENvbnRyb2xQb2ludFxufSk7XG5cbi8qKlxuICogQXBwbHkgcGllY2V3aXNlIGxpbmVhciB0cmFuc2Zvcm1hdGlvblxuICogVGhlIGZ1bmN0aW9uIGlzIGNvbnN0YW50IG91dHNpZGUgdGhlIHJhbmdlIHNwYW5uZWQgYnkgdGhlIGNvbnRyb2wgcG9pbnRzO1xuICogdGhlcmUgaXQgaXMgc2V0IHRvIHZhbHVlIG9mIHRoZSBmaXJzdCwgb3IgdGhlIGxhc3QsIGNvbnRyb2wgcG9pbnRzLlxuICpcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mISBDb250aW51b3VzVHJhbnNmb3JtXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHJldHVybnMge251bWJlcn0gZnhcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtIChjcHMsIHgpIHtcbiAgaWYgKHggPT09IG1pc3ZhbCkge1xuICAgIHJldHVybiBtaXN2YWw7XG4gIH1cblxuICB2YXIgbmNwcyA9IGNwcy5tb2RlbHMubGVuZ3RoO1xuICBpZiAoeCA8PSBjcHMubW9kZWxzWzBdLngpIHtcbiAgICAvLyBvdXRzaWRlIHJhbmdlIG9uIGxlZnQgc2lkZVxuICAgIHJldHVybiBjcHMubW9kZWxzWzBdLmZ4O1xuICB9IGVsc2UgaWYgKHggPj0gY3BzLm1vZGVsc1tuY3BzIC0gMV0ueCkge1xuICAgIC8vIG91dHNpZGUgcmFuZ2Ugb24gcmlnaHQgc2lkZVxuICAgIHJldHVybiBjcHMubW9kZWxzW25jcHMgLSAxXS5meDtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbnNpZGUgcmFuZ2VcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHggPiBjcHMubW9kZWxzW2ldLngpIHtcbiAgICAgIGkgPSBpICsgMTtcbiAgICB9XG5cbiAgICAvLyBsaW5lYXIgaW50ZXJwb2xhdGUgYmV0d2VlbiBmeF9pIGFuZCBmeF8oaSsxKVxuICAgIHZhciB4bSA9IGNwcy5tb2RlbHNbaV0ueDtcbiAgICB2YXIgeHAgPSBjcHMubW9kZWxzW2kgKyAxXS54O1xuICAgIHZhciBmeG0gPSBjcHMubW9kZWxzW2ldLmZ4O1xuICAgIHZhciBmeHAgPSBjcHMubW9kZWxzW2kgKyAxXS5meDtcbiAgICBpZiAoeHAgPT09IHhtKSB7XG4gICAgICByZXR1cm4gMC41ICogKGZ4bSArIGZ4cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmeG0gKyAoeCAtIHhtKSAqIChmeHAgLSBmeG0pIC8gKHhwIC0geG0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoZSBpbnZlcnNlIG9mIHRoZSB0cmFuc2Zvcm1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiEgQ29udGludW91c1RyYW5zZm9ybVxuICogQHBhcmFtIHtudW1iZXJ9IGZ4XG4gKiBAcmV0dXJucyB7bnVtYmVyfSB4XG4gKi9cbmZ1bmN0aW9uIGludmVyc2UgKGNwcywgZngpIHtcbiAgaWYgKGZ4ID09PSBtaXN2YWwpIHtcbiAgICByZXR1cm4gbWlzdmFsO1xuICB9XG5cbiAgdmFyIG5jcHMgPSBjcHMubW9kZWxzLmxlbmd0aDtcbiAgaWYgKGZ4IDw9IGNwcy5tb2RlbHNbMF0uZngpIHtcbiAgICAvLyBvdXRzaWRlIHJhbmdlIG9uIGxlZnQgc2lkZVxuICAgIHJldHVybiBjcHMubW9kZWxzWzBdLng7XG4gIH0gZWxzZSBpZiAoZnggPj0gY3BzLm1vZGVsc1tuY3BzIC0gMV0uZngpIHtcbiAgICAvLyBvdXRzaWRlIHJhbmdlIG9uIHJpZ2h0IHNpZGVcbiAgICByZXR1cm4gY3BzLm1vZGVsc1tuY3BzIC0gMV0ueDtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbnNpZGUgcmFuZ2VcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGZ4ID4gY3BzLm1vZGVsc1tpXS5meCkge1xuICAgICAgaSA9IGkgKyAxO1xuICAgIH1cblxuICAgIC8vIGxpbmVhciBpbnRlcnBvbGF0ZSBiZXR3ZWVuIGZ4X2kgYW5kIGZ4XyhpKzEpXG4gICAgdmFyIHhtID0gY3BzLm1vZGVsc1tpXS54O1xuICAgIHZhciB4cCA9IGNwcy5tb2RlbHNbaSArIDFdLng7XG4gICAgdmFyIGZ4bSA9IGNwcy5tb2RlbHNbaV0uZng7XG4gICAgdmFyIGZ4cCA9IGNwcy5tb2RlbHNbaSArIDFdLmZ4O1xuICAgIGlmIChmeHAgPT09IGZ4bSkge1xuICAgICAgcmV0dXJuIDAuNSAqICh4bSArIHhwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHhtICsgKGZ4IC0gZnhtKSAqICh4cCAtIHhtKSAvIChmeHAgLSBmeG0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFtcGVyc2FuZE1vZGVsLmV4dGVuZCh7XG4gIHByb3BzOiB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgY29udGludW91cyB0cmFuc2Zvcm0sIGNhbiBiZSBub25lLCBvciBwZXJjZW50aWxlc1xuICAgICAqIFVzZSBpc05vbmUsIG9yIGlzUGVyY2VudGlsZXMsIGNoZWNrIGZvciB0cmFuc2Zvcm0gdHlwZVxuICAgICAqIEBtZW1iZXJvZiEgQ29udGludW91c1RyYW5zZm9ybVxuICAgICAqL1xuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiAnbm9uZScsXG4gICAgICB2YWx1ZXM6IFsnbm9uZScsICdwZXJjZW50aWxlcyddXG4gICAgfSxcbiAgICB0cmFuc2Zvcm1lZFR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiAnY29udGludW91cycsXG4gICAgICB2YWx1ZXM6IFsnY29udGludW91cyddXG4gICAgfVxuICB9LFxuICBkZXJpdmVkOiB7XG4gICAgaXNOb25lOiB7XG4gICAgICBkZXBzOiBbJ3R5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdub25lJztcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzUGVyY2VudGlsZXM6IHtcbiAgICAgIGRlcHM6IFsndHlwZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ3BlcmNlbnRpbGVzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBtaW5pbXVtIHZhbHVlIHRoaXMgZmFjZXQgY2FuIHRha2UsIGFmdGVyIHRoZSB0cmFuc2Zvcm1hdGlvbiBoYXMgYmVlbiBhcHBsaWVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YhIENvbnRpbnVvdXNUcmFuc2Zvcm1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1lZE1pbjoge1xuICAgICAgZGVwczogWyd0eXBlJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc1BlcmNlbnRpbGVzKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc05vbmUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubWludmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgY29udGludW91cyB0cmFuc2Zvcm0nKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhY2hlOiBmYWxzZVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gdmFsdWUgdGhpcyBmYWNldCBjYW4gdGFrZSwgYWZ0ZXIgdGhlIHRyYW5zZm9ybWF0aW9uIGhhcyBiZWVuIGFwcGxpZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiEgQ29udGludW91c1RyYW5zZm9ybVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWVkTWF4OiB7XG4gICAgICBkZXBzOiBbJ3R5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUGVyY2VudGlsZXMpIHtcbiAgICAgICAgICByZXR1cm4gMTAwO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNOb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm1heHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGNvbnRpbnVvdXMgdHJhbnNmb3JtJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWNoZTogZmFsc2VcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBtaW5pbXVtIHZhbHVlIHRoaXMgZmFjZXQgY2FuIHRha2UsIGFmdGVyIHRoZSB0cmFuc2Zvcm1hdGlvbiBoYXMgYmVlbiBhcHBsaWVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJvZiEgQ29udGludW91c1RyYW5zZm9ybVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWVkTWluQXNUZXh0OiB7XG4gICAgICBkZXBzOiBbJ3RyYW5zZm9ybWVkTWluJywgJ3RyYW5zZm9ybWVkVHlwZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1pbnZhbCA9IHRoaXMudHJhbnNmb3JtZWRNaW47XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybWVkVHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgIHJldHVybiBtaW52YWwuZm9ybWF0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG1pbnZhbC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FjaGU6IGZhbHNlXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSB2YWx1ZSB0aGlzIGZhY2V0IGNhbiB0YWtlLCBhZnRlciB0aGUgdHJhbnNmb3JtYXRpb24gaGFzIGJlZW4gYXBwbGllZFxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YhIENvbnRpbnVvdXNUcmFuc2Zvcm1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1lZE1heEFzVGV4dDoge1xuICAgICAgZGVwczogWyd0cmFuc2Zvcm1lZE1heCcsICd0cmFuc2Zvcm1lZFR5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXh2YWwgPSB0aGlzLnRyYW5zZm9ybWVkTWF4O1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm1lZFR5cGUgPT09ICdkYXRldGltZScpIHtcbiAgICAgICAgICByZXR1cm4gbWF4dmFsLmZvcm1hdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtYXh2YWwudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhY2hlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgY29sbGVjdGlvbnM6IHtcbiAgICBjcHM6IENvbnRyb2xQb2ludHNcbiAgfSxcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB0cmFuc2Zvcm0odGhpcy5jcHMsIHgpO1xuICB9LFxuICBpbnZlcnNlOiBmdW5jdGlvbiAoZngpIHtcbiAgICByZXR1cm4gaW52ZXJzZSh0aGlzLmNwcywgZngpO1xuICB9LFxuICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHlwZSA9ICdub25lJztcbiAgICB0aGlzLmNwcy5yZXNldCgpO1xuICB9XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5a80\n")},6176:function(module,exports){eval("module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjE3Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcz8xYjA4Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6176\n")},"636d":function(module,exports){eval("\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjM2ZC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanM/ZWVlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogRXhwb3NlIGBFbWl0dGVyYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn07XG5cbi8qKlxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAodGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW10pXG4gICAgLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICBmdW5jdGlvbiBvbigpIHtcbiAgICBzZWxmLm9mZihldmVudCwgb24pO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBvbi5mbiA9IGZuO1xuICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIC8vIGFsbFxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzcGVjaWZpYyBldmVudFxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcbiAgdmFyIGNiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///636d\n")},"6b20":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Module dependencies.\n */\n\nvar Transport = __webpack_require__(/*! ../transport */ \"0d97\");\nvar parser = __webpack_require__(/*! engine.io-parser */ \"aa6c\");\nvar parseqs = __webpack_require__(/*! parseqs */ \"914f\");\nvar inherit = __webpack_require__(/*! component-inherit */ \"42bf\");\nvar yeast = __webpack_require__(/*! yeast */ \"c16d\");\nvar debug = __webpack_require__(/*! debug */ \"433b\")('engine.io-client:websocket');\nvar BrowserWebSocket = global.WebSocket || global.MozWebSocket;\nvar NodeWebSocket;\nif (typeof window === 'undefined') {\n  try {\n    NodeWebSocket = __webpack_require__(/*! ws */ 0);\n  } catch (e) { }\n}\n\n/**\n * Get either the `WebSocket` or `MozWebSocket` globals\n * in the browser or try to resolve WebSocket-compatible\n * interface exposed by `ws` for Node-like environment.\n */\n\nvar WebSocket = BrowserWebSocket;\nif (!WebSocket && typeof window === 'undefined') {\n  WebSocket = NodeWebSocket;\n}\n\n/**\n * Module exports.\n */\n\nmodule.exports = WS;\n\n/**\n * WebSocket transport constructor.\n *\n * @api {Object} connection options\n * @api public\n */\n\nfunction WS (opts) {\n  var forceBase64 = (opts && opts.forceBase64);\n  if (forceBase64) {\n    this.supportsBinary = false;\n  }\n  this.perMessageDeflate = opts.perMessageDeflate;\n  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;\n  if (!this.usingBrowserWebSocket) {\n    WebSocket = NodeWebSocket;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(WS, Transport);\n\n/**\n * Transport name.\n *\n * @api public\n */\n\nWS.prototype.name = 'websocket';\n\n/*\n * WebSockets support binary\n */\n\nWS.prototype.supportsBinary = true;\n\n/**\n * Opens socket.\n *\n * @api private\n */\n\nWS.prototype.doOpen = function () {\n  if (!this.check()) {\n    // let probe timeout\n    return;\n  }\n\n  var uri = this.uri();\n  var protocols = void (0);\n  var opts = {\n    agent: this.agent,\n    perMessageDeflate: this.perMessageDeflate\n  };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n  if (this.extraHeaders) {\n    opts.headers = this.extraHeaders;\n  }\n  if (this.localAddress) {\n    opts.localAddress = this.localAddress;\n  }\n\n  try {\n    this.ws = this.usingBrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);\n  } catch (err) {\n    return this.emit('error', err);\n  }\n\n  if (this.ws.binaryType === undefined) {\n    this.supportsBinary = false;\n  }\n\n  if (this.ws.supports && this.ws.supports.binary) {\n    this.supportsBinary = true;\n    this.ws.binaryType = 'nodebuffer';\n  } else {\n    this.ws.binaryType = 'arraybuffer';\n  }\n\n  this.addEventListeners();\n};\n\n/**\n * Adds event listeners to the socket\n *\n * @api private\n */\n\nWS.prototype.addEventListeners = function () {\n  var self = this;\n\n  this.ws.onopen = function () {\n    self.onOpen();\n  };\n  this.ws.onclose = function () {\n    self.onClose();\n  };\n  this.ws.onmessage = function (ev) {\n    self.onData(ev.data);\n  };\n  this.ws.onerror = function (e) {\n    self.onError('websocket error', e);\n  };\n};\n\n/**\n * Writes data to socket.\n *\n * @param {Array} array of packets.\n * @api private\n */\n\nWS.prototype.write = function (packets) {\n  var self = this;\n  this.writable = false;\n\n  // encodePacket efficient as it uses WS framing\n  // no need for encodePayload\n  var total = packets.length;\n  for (var i = 0, l = total; i < l; i++) {\n    (function (packet) {\n      parser.encodePacket(packet, self.supportsBinary, function (data) {\n        if (!self.usingBrowserWebSocket) {\n          // always create a new object (GH-437)\n          var opts = {};\n          if (packet.options) {\n            opts.compress = packet.options.compress;\n          }\n\n          if (self.perMessageDeflate) {\n            var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;\n            if (len < self.perMessageDeflate.threshold) {\n              opts.compress = false;\n            }\n          }\n        }\n\n        // Sometimes the websocket has already been closed but the browser didn't\n        // have a chance of informing us about it yet, in that case send will\n        // throw an error\n        try {\n          if (self.usingBrowserWebSocket) {\n            // TypeError is thrown when passing the second argument on Safari\n            self.ws.send(data);\n          } else {\n            self.ws.send(data, opts);\n          }\n        } catch (e) {\n          debug('websocket closed before onclose event');\n        }\n\n        --total || done();\n      });\n    })(packets[i]);\n  }\n\n  function done () {\n    self.emit('flush');\n\n    // fake drain\n    // defer to next tick to allow Socket to clear writeBuffer\n    setTimeout(function () {\n      self.writable = true;\n      self.emit('drain');\n    }, 0);\n  }\n};\n\n/**\n * Called upon close\n *\n * @api private\n */\n\nWS.prototype.onClose = function () {\n  Transport.prototype.onClose.call(this);\n};\n\n/**\n * Closes socket.\n *\n * @api private\n */\n\nWS.prototype.doClose = function () {\n  if (typeof this.ws !== 'undefined') {\n    this.ws.close();\n  }\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nWS.prototype.uri = function () {\n  var query = this.query || {};\n  var schema = this.secure ? 'wss' : 'ws';\n  var port = '';\n\n  // avoid port if default for schema\n  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||\n    ('ws' === schema && Number(this.port) !== 80))) {\n    port = ':' + this.port;\n  }\n\n  // append timestamp to URI\n  if (this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  // communicate binary support capabilities\n  if (!this.supportsBinary) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n\n/**\n * Feature detection for WebSocket.\n *\n * @return {Boolean} whether this transport is available.\n * @api public\n */\n\nWS.prototype.check = function () {\n  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"698d\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNmIyMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanM/ZGI4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gcmVxdWlyZSgneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6d2Vic29ja2V0Jyk7XG52YXIgQnJvd3NlcldlYlNvY2tldCA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcbnZhciBOb2RlV2ViU29ja2V0O1xuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRyeSB7XG4gICAgTm9kZVdlYlNvY2tldCA9IHJlcXVpcmUoJ3dzJyk7XG4gIH0gY2F0Y2ggKGUpIHsgfVxufVxuXG4vKipcbiAqIEdldCBlaXRoZXIgdGhlIGBXZWJTb2NrZXRgIG9yIGBNb3pXZWJTb2NrZXRgIGdsb2JhbHNcbiAqIGluIHRoZSBicm93c2VyIG9yIHRyeSB0byByZXNvbHZlIFdlYlNvY2tldC1jb21wYXRpYmxlXG4gKiBpbnRlcmZhY2UgZXhwb3NlZCBieSBgd3NgIGZvciBOb2RlLWxpa2UgZW52aXJvbm1lbnQuXG4gKi9cblxudmFyIFdlYlNvY2tldCA9IEJyb3dzZXJXZWJTb2NrZXQ7XG5pZiAoIVdlYlNvY2tldCAmJiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICBXZWJTb2NrZXQgPSBOb2RlV2ViU29ja2V0O1xufVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gV1M7XG5cbi8qKlxuICogV2ViU29ja2V0IHRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHtPYmplY3R9IGNvbm5lY3Rpb24gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBXUyAob3B0cykge1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlO1xuICB0aGlzLnVzaW5nQnJvd3NlcldlYlNvY2tldCA9IEJyb3dzZXJXZWJTb2NrZXQgJiYgIW9wdHMuZm9yY2VOb2RlO1xuICBpZiAoIXRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgV2ViU29ja2V0ID0gTm9kZVdlYlNvY2tldDtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFdTLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuLypcbiAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcbiAqL1xuXG5XUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIE9wZW5zIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuY2hlY2soKSkge1xuICAgIC8vIGxldCBwcm9iZSB0aW1lb3V0XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHVyaSA9IHRoaXMudXJpKCk7XG4gIHZhciBwcm90b2NvbHMgPSB2b2lkICgwKTtcbiAgdmFyIG9wdHMgPSB7XG4gICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGVcbiAgfTtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgIG9wdHMuaGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuICB9XG4gIGlmICh0aGlzLmxvY2FsQWRkcmVzcykge1xuICAgIG9wdHMubG9jYWxBZGRyZXNzID0gdGhpcy5sb2NhbEFkZHJlc3M7XG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMud3MgPSB0aGlzLnVzaW5nQnJvd3NlcldlYlNvY2tldCA/IG5ldyBXZWJTb2NrZXQodXJpKSA6IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdub2RlYnVmZmVyJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICB9XG5cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuLyoqXG4gKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbk9wZW4oKTtcbiAgfTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25DbG9zZSgpO1xuICB9O1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgIHNlbGYub25EYXRhKGV2LmRhdGEpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgLy8gZW5jb2RlUGFja2V0IGVmZmljaWVudCBhcyBpdCB1c2VzIFdTIGZyYW1pbmdcbiAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuICB2YXIgdG90YWwgPSBwYWNrZXRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b3RhbDsgaSA8IGw7IGkrKykge1xuICAgIChmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCFzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgIC8vIGFsd2F5cyBjcmVhdGUgYSBuZXcgb2JqZWN0IChHSC00MzcpXG4gICAgICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9ICdzdHJpbmcnID09PSB0eXBlb2YgZGF0YSA/IGdsb2JhbC5CdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA8IHNlbGYucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG4gICAgICAgIC8vIGhhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuICAgICAgICAvLyB0aHJvdyBhbiBlcnJvclxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgICAgLy8gVHlwZUVycm9yIGlzIHRocm93biB3aGVuIHBhc3NpbmcgdGhlIHNlY29uZCBhcmd1bWVudCBvbiBTYWZhcmlcbiAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEsIG9wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCd3ZWJzb2NrZXQgY2xvc2VkIGJlZm9yZSBvbmNsb3NlIGV2ZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAtLXRvdGFsIHx8IGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pKHBhY2tldHNbaV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgc2VsZi5lbWl0KCdmbHVzaCcpO1xuXG4gICAgLy8gZmFrZSBkcmFpblxuICAgIC8vIGRlZmVyIHRvIG5leHQgdGljayB0byBhbGxvdyBTb2NrZXQgdG8gY2xlYXIgd3JpdGVCdWZmZXJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICAgIH0sIDApO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHRoaXMud3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy53cy5jbG9zZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnd3NzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA0NDMpIHx8XG4gICAgKCd3cycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBhcHBlbmQgdGltZXN0YW1wIHRvIFVSSVxuICBpZiAodGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBGZWF0dXJlIGRldGVjdGlvbiBmb3IgV2ViU29ja2V0LlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhpcyB0cmFuc3BvcnQgaXMgYXZhaWxhYmxlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIVdlYlNvY2tldCAmJiAhKCdfX2luaXRpYWxpemUnIGluIFdlYlNvY2tldCAmJiB0aGlzLm5hbWUgPT09IFdTLnByb3RvdHlwZS5uYW1lKTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6b20\n")},"6fba":function(module,exports,__webpack_require__){eval("\n/**\n * Module dependencies.\n */\n\nvar debug = __webpack_require__(/*! debug */ \"8233\")('socket.io-parser');\nvar json = __webpack_require__(/*! json3 */ \"3b17\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"636d\");\nvar binary = __webpack_require__(/*! ./binary */ \"ea82\");\nvar isBuf = __webpack_require__(/*! ./is-buffer */ \"419b\");\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = 4;\n\n/**\n * Packet types.\n *\n * @api public\n */\n\nexports.types = [\n  'CONNECT',\n  'DISCONNECT',\n  'EVENT',\n  'ACK',\n  'ERROR',\n  'BINARY_EVENT',\n  'BINARY_ACK'\n];\n\n/**\n * Packet type `connect`.\n *\n * @api public\n */\n\nexports.CONNECT = 0;\n\n/**\n * Packet type `disconnect`.\n *\n * @api public\n */\n\nexports.DISCONNECT = 1;\n\n/**\n * Packet type `event`.\n *\n * @api public\n */\n\nexports.EVENT = 2;\n\n/**\n * Packet type `ack`.\n *\n * @api public\n */\n\nexports.ACK = 3;\n\n/**\n * Packet type `error`.\n *\n * @api public\n */\n\nexports.ERROR = 4;\n\n/**\n * Packet type 'binary event'\n *\n * @api public\n */\n\nexports.BINARY_EVENT = 5;\n\n/**\n * Packet type `binary ack`. For acks with binary arguments.\n *\n * @api public\n */\n\nexports.BINARY_ACK = 6;\n\n/**\n * Encoder constructor.\n *\n * @api public\n */\n\nexports.Encoder = Encoder;\n\n/**\n * Decoder constructor.\n *\n * @api public\n */\n\nexports.Decoder = Decoder;\n\n/**\n * A socket.io Encoder instance\n *\n * @api public\n */\n\nfunction Encoder() {}\n\n/**\n * Encode a packet as a single string if non-binary, or as a\n * buffer sequence, depending on packet type.\n *\n * @param {Object} obj - packet object\n * @param {Function} callback - function to handle encodings (likely engine.write)\n * @return Calls callback with Array of encodings\n * @api public\n */\n\nEncoder.prototype.encode = function(obj, callback){\n  debug('encoding packet %j', obj);\n\n  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n    encodeAsBinary(obj, callback);\n  }\n  else {\n    var encoding = encodeAsString(obj);\n    callback([encoding]);\n  }\n};\n\n/**\n * Encode packet as string.\n *\n * @param {Object} packet\n * @return {String} encoded\n * @api private\n */\n\nfunction encodeAsString(obj) {\n  var str = '';\n  var nsp = false;\n\n  // first is type\n  str += obj.type;\n\n  // attachments if we have them\n  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n    str += obj.attachments;\n    str += '-';\n  }\n\n  // if we have a namespace other than `/`\n  // we append it followed by a comma `,`\n  if (obj.nsp && '/' != obj.nsp) {\n    nsp = true;\n    str += obj.nsp;\n  }\n\n  // immediately followed by the id\n  if (null != obj.id) {\n    if (nsp) {\n      str += ',';\n      nsp = false;\n    }\n    str += obj.id;\n  }\n\n  // json data\n  if (null != obj.data) {\n    if (nsp) str += ',';\n    str += json.stringify(obj.data);\n  }\n\n  debug('encoded %j as %s', obj, str);\n  return str;\n}\n\n/**\n * Encode packet as 'buffer sequence' by removing blobs, and\n * deconstructing packet into object with placeholders and\n * a list of buffers.\n *\n * @param {Object} packet\n * @return {Buffer} encoded\n * @api private\n */\n\nfunction encodeAsBinary(obj, callback) {\n\n  function writeEncoding(bloblessData) {\n    var deconstruction = binary.deconstructPacket(bloblessData);\n    var pack = encodeAsString(deconstruction.packet);\n    var buffers = deconstruction.buffers;\n\n    buffers.unshift(pack); // add packet info to beginning of data list\n    callback(buffers); // write all the buffers\n  }\n\n  binary.removeBlobs(obj, writeEncoding);\n}\n\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n * @api public\n */\n\nfunction Decoder() {\n  this.reconstructor = null;\n}\n\n/**\n * Mix in `Emitter` with Decoder.\n */\n\nEmitter(Decoder.prototype);\n\n/**\n * Decodes an ecoded packet string into packet JSON.\n *\n * @param {String} obj - encoded packet\n * @return {Object} packet\n * @api public\n */\n\nDecoder.prototype.add = function(obj) {\n  var packet;\n  if ('string' == typeof obj) {\n    packet = decodeString(obj);\n    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json\n      this.reconstructor = new BinaryReconstructor(packet);\n\n      // no attachments, labeled binary but no binary data to follow\n      if (this.reconstructor.reconPack.attachments === 0) {\n        this.emit('decoded', packet);\n      }\n    } else { // non-binary full packet\n      this.emit('decoded', packet);\n    }\n  }\n  else if (isBuf(obj) || obj.base64) { // raw binary data\n    if (!this.reconstructor) {\n      throw new Error('got binary data when not reconstructing a packet');\n    } else {\n      packet = this.reconstructor.takeBinaryData(obj);\n      if (packet) { // received final buffer\n        this.reconstructor = null;\n        this.emit('decoded', packet);\n      }\n    }\n  }\n  else {\n    throw new Error('Unknown type: ' + obj);\n  }\n};\n\n/**\n * Decode a packet String (JSON data)\n *\n * @param {String} str\n * @return {Object} packet\n * @api private\n */\n\nfunction decodeString(str) {\n  var p = {};\n  var i = 0;\n\n  // look up type\n  p.type = Number(str.charAt(0));\n  if (null == exports.types[p.type]) return error();\n\n  // look up attachments if type binary\n  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {\n    var buf = '';\n    while (str.charAt(++i) != '-') {\n      buf += str.charAt(i);\n      if (i == str.length) break;\n    }\n    if (buf != Number(buf) || str.charAt(i) != '-') {\n      throw new Error('Illegal attachments');\n    }\n    p.attachments = Number(buf);\n  }\n\n  // look up namespace (if any)\n  if ('/' == str.charAt(i + 1)) {\n    p.nsp = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (',' == c) break;\n      p.nsp += c;\n      if (i == str.length) break;\n    }\n  } else {\n    p.nsp = '/';\n  }\n\n  // look up id\n  var next = str.charAt(i + 1);\n  if ('' !== next && Number(next) == next) {\n    p.id = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (null == c || Number(c) != c) {\n        --i;\n        break;\n      }\n      p.id += str.charAt(i);\n      if (i == str.length) break;\n    }\n    p.id = Number(p.id);\n  }\n\n  // look up json data\n  if (str.charAt(++i)) {\n    p = tryParse(p, str.substr(i));\n  }\n\n  debug('decoded %s as %j', str, p);\n  return p;\n}\n\nfunction tryParse(p, str) {\n  try {\n    p.data = json.parse(str);\n  } catch(e){\n    return error();\n  }\n  return p; \n};\n\n/**\n * Deallocates a parser's resources\n *\n * @api public\n */\n\nDecoder.prototype.destroy = function() {\n  if (this.reconstructor) {\n    this.reconstructor.finishedReconstruction();\n  }\n};\n\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n * @api private\n */\n\nfunction BinaryReconstructor(packet) {\n  this.reconPack = packet;\n  this.buffers = [];\n}\n\n/**\n * Method to be called when binary data received from connection\n * after a BINARY_EVENT packet.\n *\n * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n * @return {null | Object} returns null if more binary data is expected or\n *   a reconstructed packet object if all buffers have been received.\n * @api private\n */\n\nBinaryReconstructor.prototype.takeBinaryData = function(binData) {\n  this.buffers.push(binData);\n  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list\n    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n    this.finishedReconstruction();\n    return packet;\n  }\n  return null;\n};\n\n/**\n * Cleans up binary packet reconstruction variables.\n *\n * @api private\n */\n\nBinaryReconstructor.prototype.finishedReconstruction = function() {\n  this.reconPack = null;\n  this.buffers = [];\n};\n\nfunction error(data){\n  return {\n    type: exports.ERROR,\n    data: 'parser error'\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNmZiYS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pbmRleC5qcz84ZjQzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBqc29uID0gcmVxdWlyZSgnanNvbjMnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBiaW5hcnkgPSByZXF1aXJlKCcuL2JpbmFyeScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy50eXBlcyA9IFtcbiAgJ0NPTk5FQ1QnLFxuICAnRElTQ09OTkVDVCcsXG4gICdFVkVOVCcsXG4gICdBQ0snLFxuICAnRVJST1InLFxuICAnQklOQVJZX0VWRU5UJyxcbiAgJ0JJTkFSWV9BQ0snXG5dO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FVkVOVCA9IDI7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGFja2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkFDSyA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGVycm9yYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVJST1IgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG4vKipcbiAqIEVuY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXG4vKipcbiAqIERlY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG4vKipcbiAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuXG4vKipcbiAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gdG8gaGFuZGxlIGVuY29kaW5ncyAobGlrZWx5IGVuZ2luZS53cml0ZSlcbiAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3NcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24ob2JqLCBjYWxsYmFjayl7XG4gIGRlYnVnKCdlbmNvZGluZyBwYWNrZXQgJWonLCBvYmopO1xuXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gb2JqLnR5cGUpIHtcbiAgICBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBlbmNvZGVBc1N0cmluZyhvYmopO1xuICAgIGNhbGxiYWNrKFtlbmNvZGluZ10pO1xuICB9XG59O1xuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcob2JqKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIG5zcCA9IGZhbHNlO1xuXG4gIC8vIGZpcnN0IGlzIHR5cGVcbiAgc3RyICs9IG9iai50eXBlO1xuXG4gIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IG9iai50eXBlKSB7XG4gICAgc3RyICs9IG9iai5hdHRhY2htZW50cztcbiAgICBzdHIgKz0gJy0nO1xuICB9XG5cbiAgLy8gaWYgd2UgaGF2ZSBhIG5hbWVzcGFjZSBvdGhlciB0aGFuIGAvYFxuICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcbiAgaWYgKG9iai5uc3AgJiYgJy8nICE9IG9iai5uc3ApIHtcbiAgICBuc3AgPSB0cnVlO1xuICAgIHN0ciArPSBvYmoubnNwO1xuICB9XG5cbiAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgIGlmIChuc3ApIHtcbiAgICAgIHN0ciArPSAnLCc7XG4gICAgICBuc3AgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RyICs9IG9iai5pZDtcbiAgfVxuXG4gIC8vIGpzb24gZGF0YVxuICBpZiAobnVsbCAhPSBvYmouZGF0YSkge1xuICAgIGlmIChuc3ApIHN0ciArPSAnLCc7XG4gICAgc3RyICs9IGpzb24uc3RyaW5naWZ5KG9iai5kYXRhKTtcbiAgfVxuXG4gIGRlYnVnKCdlbmNvZGVkICVqIGFzICVzJywgb2JqLCBzdHIpO1xuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcbiAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcbiAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG4gICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgfVxuXG4gIGJpbmFyeS5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cbiAqL1xuXG5FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIGVjb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9iaiAtIGVuY29kZWQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHBhY2tldDtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBvYmopIHtcbiAgICBwYWNrZXQgPSBkZWNvZGVTdHJpbmcob2JqKTtcbiAgICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcGFja2V0LnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHBhY2tldC50eXBlKSB7IC8vIGJpbmFyeSBwYWNrZXQncyBqc29uXG4gICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpO1xuXG4gICAgICAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvci5yZWNvblBhY2suYXR0YWNobWVudHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG4gICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChpc0J1ZihvYmopIHx8IG9iai5iYXNlNjQpIHsgLy8gcmF3IGJpbmFyeSBkYXRhXG4gICAgaWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO1xuICAgICAgaWYgKHBhY2tldCkgeyAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cikge1xuICB2YXIgcCA9IHt9O1xuICB2YXIgaSA9IDA7XG5cbiAgLy8gbG9vayB1cCB0eXBlXG4gIHAudHlwZSA9IE51bWJlcihzdHIuY2hhckF0KDApKTtcbiAgaWYgKG51bGwgPT0gZXhwb3J0cy50eXBlc1twLnR5cGVdKSByZXR1cm4gZXJyb3IoKTtcblxuICAvLyBsb29rIHVwIGF0dGFjaG1lbnRzIGlmIHR5cGUgYmluYXJ5XG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBwLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHAudHlwZSkge1xuICAgIHZhciBidWYgPSAnJztcbiAgICB3aGlsZSAoc3RyLmNoYXJBdCgrK2kpICE9ICctJykge1xuICAgICAgYnVmICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgaWYgKGJ1ZiAhPSBOdW1iZXIoYnVmKSB8fCBzdHIuY2hhckF0KGkpICE9ICctJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGF0dGFjaG1lbnRzJyk7XG4gICAgfVxuICAgIHAuYXR0YWNobWVudHMgPSBOdW1iZXIoYnVmKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG4gIGlmICgnLycgPT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICBwLm5zcCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmICgnLCcgPT0gYykgYnJlYWs7XG4gICAgICBwLm5zcCArPSBjO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHAubnNwID0gJy8nO1xuICB9XG5cbiAgLy8gbG9vayB1cCBpZFxuICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuICBpZiAoJycgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICBwLmlkID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAtLWk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcC5pZCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIHAuaWQgPSBOdW1iZXIocC5pZCk7XG4gIH1cblxuICAvLyBsb29rIHVwIGpzb24gZGF0YVxuICBpZiAoc3RyLmNoYXJBdCgrK2kpKSB7XG4gICAgcCA9IHRyeVBhcnNlKHAsIHN0ci5zdWJzdHIoaSkpO1xuICB9XG5cbiAgZGVidWcoJ2RlY29kZWQgJXMgYXMgJWonLCBzdHIsIHApO1xuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gdHJ5UGFyc2UocCwgc3RyKSB7XG4gIHRyeSB7XG4gICAgcC5kYXRhID0ganNvbi5wYXJzZShzdHIpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiBlcnJvcigpO1xuICB9XG4gIHJldHVybiBwOyBcbn07XG5cbi8qKlxuICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgIHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBtYW5hZ2VyIG9mIGEgYmluYXJ5IGV2ZW50J3MgJ2J1ZmZlciBzZXF1ZW5jZScuIFNob3VsZFxuICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcbiAqIGRlY29kZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufVxuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cbiAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3JcbiAqICAgYSByZWNvbnN0cnVjdGVkIHBhY2tldCBvYmplY3QgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUudGFrZUJpbmFyeURhdGEgPSBmdW5jdGlvbihiaW5EYXRhKSB7XG4gIHRoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO1xuICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PSB0aGlzLnJlY29uUGFjay5hdHRhY2htZW50cykgeyAvLyBkb25lIHdpdGggYnVmZmVyIGxpc3RcbiAgICB2YXIgcGFja2V0ID0gYmluYXJ5LnJlY29uc3RydWN0UGFja2V0KHRoaXMucmVjb25QYWNrLCB0aGlzLmJ1ZmZlcnMpO1xuICAgIHRoaXMuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICAgIHJldHVybiBwYWNrZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBiaW5hcnkgcGFja2V0IHJlY29uc3RydWN0aW9uIHZhcmlhYmxlcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5CaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS5maW5pc2hlZFJlY29uc3RydWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVjb25QYWNrID0gbnVsbDtcbiAgdGhpcy5idWZmZXJzID0gW107XG59O1xuXG5mdW5jdGlvbiBlcnJvcihkYXRhKXtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBleHBvcnRzLkVSUk9SLFxuICAgIGRhdGE6ICdwYXJzZXIgZXJyb3InXG4gIH07XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6fba\n")},"720c":function(module,exports,__webpack_require__){eval("/**\n * Client side filtering using crossfilter\n * Due to limitation of crossfilter with array (or data that has no natrual ordering), this will not work as expected:\n * * dimension: `function (d) {return [d.x, d.y, d.z]}`\n * * group: `function (d) {return [d.x / 10 , d.y / 10, d.z / 10]}`\n *\n * Therefore, we preform grouping already in the dimension itself, and join the array to a string.\n * Strings have a natural ordering and thus can be used as dimension value.\n * * dimension: `function (d) -> \"d.x/10|d.y/10|d.z/10\"`\n * * group: `function (d) {return d;}`\n *\n * @module driver/client\n */\nvar moment = __webpack_require__(/*! moment-timezone */ \"6c9d\");\n\nvar utildx = __webpack_require__(/*! ../util/crossfilter */ \"adfa\");\nvar misval = __webpack_require__(/*! ../util/misval */ \"bff6\");\n\nvar grpIdxToName = {0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'e'};\nvar aggRankToName = {1: 'aa', 2: 'bb', 3: 'cc', 4: 'dd', 5: 'ee'};\n\n/**\n * setMinMax sets the range of a continuous or time facet\n *\n * @param {Dataset} dataset\n * @param {Facet} facet\n */\nfunction setMinMax (dataset, facet) {\n  // we need the value just before a transformation, so baseValueFn\n  var valFn = utildx.baseValueFn(facet);\n\n  // to be able to mark the value as missing we need it unprocessed, so rawValueFn\n  var rawValFn = utildx.rawValueFn(facet);\n\n  var lessFn;\n  var moreFn;\n  if (facet.isDatetime) {\n    lessFn = function (a, b) { return (b === misval || a.isBefore(b)); };\n    moreFn = function (a, b) { return (b === misval || b.isBefore(a)); };\n  } else {\n    lessFn = function (a, b) { return (b === misval || a < b); };\n    moreFn = function (a, b) { return (b === misval || a > b); };\n  }\n\n  var minval = misval;\n  var rawMin = misval;\n\n  var maxval = misval;\n  var rawMax = misval;\n\n  dataset.data.forEach(function (d) {\n    var rawV = rawValFn(d);\n    var v = valFn(d);\n\n    if (v !== misval) {\n      if (lessFn(v, minval)) {\n        minval = v;\n        rawMin = rawV;\n      }\n      if (moreFn(v, maxval)) {\n        maxval = v;\n        rawMax = rawV;\n      }\n    }\n  });\n\n  if (minval !== misval) {\n    if (facet.isContinuous) {\n      facet.minvalAsText = minval.toString();\n    } else if (facet.isDatetime) {\n      facet.minvalAsText = minval.toISOString();\n    } else if (facet.isDuration) {\n      facet.minvalAsText = minval.toISOString();\n    }\n    facet.rawMinval = rawMin;\n  } else {\n    facet.minvalAsText = '';\n    facet.rawMinval = misval;\n  }\n\n  if (maxval !== misval) {\n    if (facet.isContinuous) {\n      facet.maxvalAsText = maxval.toString();\n    } else if (facet.isDatetime) {\n      facet.maxvalAsText = maxval.toISOString();\n    } else if (facet.isDuration) {\n      facet.maxvalAsText = maxval.toISOString();\n    }\n    facet.rawMaxval = rawMax;\n  } else {\n    facet.maxvalAsText = '';\n    facet.rawMaxval = misval;\n  }\n}\n\n/**\n * setCategories finds finds all values on an ordinal (categorial) axis\n * Updates the categorialTransform of the facet\n *\n * @param {Dataset} dataset\n * @param {Facet} facet\n */\nfunction setCategories (dataset, facet) {\n  // we need the value just before a transformation, so baseValueFn\n  var valFn = utildx.baseValueFn(facet);\n\n  var p = {};\n  var Plength = 0;\n  dataset.data.forEach(function (d, i) {\n    var vals = valFn(d);\n    if (vals instanceof Array) {\n      vals.forEach(function (val) {\n        if (p.hasOwnProperty(val)) {\n          p[val]++;\n        } else {\n          if (Plength < 75) { // NOTE: limit to maximally 75 categories\n            p[val] = 1;\n            Plength++;\n          }\n        }\n      });\n    } else {\n      if (p.hasOwnProperty(vals)) {\n        p[vals]++;\n      } else {\n        if (Plength < 75) { // NOTE: limit to maximally 75 categories\n          p[vals] = 1;\n          Plength++;\n        }\n      }\n    }\n  });\n\n  facet.categorialTransform.reset();\n\n  Object.keys(p).forEach(function (key) {\n    // TODO: missing data should be mapped to a misval from misvalAsText\n    var keyAsString = key.toString();\n    var groupAsString = keyAsString;\n\n    facet.categorialTransform.rules.add({expression: keyAsString, count: p[key], group: groupAsString});\n  });\n}\n\n/**\n * Calculate 100 percentiles (ie. 1,2,3,4 etc.), and initialize the `facet.continuousTransform`\n * to an approximate percentile mapping.\n * Use the recommended method from [NIST](http://www.itl.nist.gov/div898/handbook/prc/section2/prc262.htm)\n * See also the discussion on [Wikipedia](https://en.wikipedia.org/wiki/Percentile)\n *\n * @param {Dataset} dataset\n * @param {Facet} facet\n */\nfunction setPercentiles (dataset, facet) {\n  // we need the value just before a transformation, so baseValueFn\n  var basevalueFn = utildx.baseValueFn(facet);\n  var data = dataset.data;\n\n  data.sort(function (a, b) {\n    var valA = basevalueFn(a);\n    var valB = basevalueFn(b);\n\n    if (valA === valB) {\n      return 0;\n    }\n    if (valA === misval) {\n      return -1;\n    }\n    if (valB === misval) {\n      return 1;\n    }\n\n    if (valA < valB) {\n      return -1;\n    } else {\n      return 1;\n    }\n  });\n\n  var tf = facet.continuousTransform;\n  var x, i;\n\n  // drop missing values, which should be sorted at the start of the array\n  i = 0;\n  while (basevalueFn(data[i]) === misval && i < data.length) {\n    i++;\n  }\n  data.splice(0, i);\n\n  // start clean\n  tf.reset();\n\n  // add minimum value as control points p0 and p1\n  tf.cps.add({x: basevalueFn(data[0]), fx: 0});\n  tf.cps.add({x: basevalueFn(data[0]), fx: 0});\n\n  var p, value;\n  for (p = 1; p < 100; p++) {\n    x = (p * 0.01) * (data.length + 1) - 1; // indexing starts at zero, not at one\n    i = Math.trunc(x);\n    value = (1 - x + i) * basevalueFn(data[i]) + (x - i) * basevalueFn(data[i + 1]);\n    tf.cps.add({x: value, fx: p});\n  }\n\n  // add maximum value as p101 and p102\n  tf.cps.add({x: basevalueFn(data[data.length - 1]), fx: 100});\n  tf.cps.add({x: basevalueFn(data[data.length - 1]), fx: 100});\n\n  tf.type = 'percentiles';\n}\n\n/**\n * Autoconfigure a dataset:\n * 1. pick 10 random elements\n * 2. create facets for their properties\n * 3. add facets' values over the sample to the facet.description\n * 4. set range or categories\n *\n * @param {Dataset} dataset\n */\nfunction scan (dataset) {\n  function facetExists (facets, path) {\n    var exists = false;\n    facets.forEach(function (f) {\n      if (f.accessor === path || f.accessor === path + '[]') {\n        exists = true;\n      }\n    });\n    return exists;\n  }\n\n  function addValue (values, v, missing) {\n    if (v === misval) {\n      v = missing;\n    }\n    if (values.indexOf(v) === -1) {\n      values.push(v);\n    }\n  }\n\n  function guessType (values) {\n    var mytype = {\n      continuous: 0,\n      text: 0,\n      datetime: 0,\n      duration: 0,\n      categorial: 0\n    };\n    values.forEach(function (value) {\n      if (moment(value, moment.ISO_8601).isValid()) {\n        // \"2016-08-17 17:25:00+01\"\n        mytype.datetime++;\n      } else if (\n          (moment.duration(value).asMilliseconds() !== 0) &&\n          (typeof value === 'string') &&\n          (value[0].toLowerCase() === 'p')) {\n        // \"P10Y\"\n        mytype.duration++;\n      } else if (value == +value) {  // eslint-disable-line eqeqeq\n        // \"10\" or 10\n        mytype.continuous++;\n      } else {\n        // \"hello world\"\n        mytype.categorial++;\n      }\n    });\n\n    // get facetType with highest count\n    var max = -1;\n    var facetType;\n    Object.keys(mytype).forEach(function (key) {\n      if (mytype[key] > max) {\n        facetType = key;\n        max = mytype[key];\n      }\n    });\n\n    return facetType;\n  }\n\n  function tryFacet (facets, data, path, value) {\n    // Check for existence\n    if (facetExists(facets, path)) {\n      return;\n    }\n\n    // Create a new facet\n    var facet = facets.add({\n      name: path,\n      accessor: path,\n      type: 'text'\n    });\n\n    // Sample values\n    var baseValueFn = utildx.baseValueFn(facet);\n    var values = [];\n    var isArray = false;\n\n    data.forEach(function (d) {\n      var value = baseValueFn(d);\n      if (value instanceof Array) {\n        isArray = true;\n        value.forEach(function (v) {\n          addValue(values, v, facet.misval[0]);\n        });\n      } else {\n        addValue(values, value, facet.misval[0]);\n      }\n    });\n\n    // Reconfigure facet\n    facet.accessor = isArray ? facet.accessor + '[]' : facet.accessor;\n    facet.type = guessType(values);\n    facet.description = values.join(', ').match('^.{0,40}') + '...';\n    facet.isActive = true;\n  }\n\n  function recurse (facets, data, path, tree) {\n    var props = Object.getOwnPropertyNames(tree);\n    props.forEach(function (name) {\n      var subpath;\n      if (path) {\n        subpath = path + '##' + name;\n      } else {\n        subpath = name;\n      }\n\n      if (tree[name] instanceof Array) {\n        // add an array as a itself as a facet, ie. labelset, to prevent adding each element as separate facet\n        // also add the array length as facet\n        tryFacet(facets, data, subpath, tree[name]);\n        tryFacet(facets, data, subpath + '.length', tree[name].length);\n      } else if (tree[name] instanceof Object) {\n        // recurse into objects\n        recurse(facets, data, subpath, tree[name]);\n      } else {\n        // add strings and numbers as facets\n        tryFacet(facets, data, subpath, tree[name]);\n      }\n    });\n  }\n\n  // Add facets\n  var data = dataset.data.slice(0, 10);\n  data.forEach(function (d) {\n    recurse(dataset.facets, data, '', d);\n  });\n\n  dataset.facets.forEach(function (facet) {\n    if (facet.isCategorial) {\n      setCategories(dataset, facet);\n    } else if (facet.isContinuous || facet.isDatetime) {\n      setMinMax(dataset, facet);\n    }\n  });\n  dataset.trigger('syncFacets');\n}\n\n/**\n * Initialize the data filter, and construct the getData callback function on the filter.\n * @param {Dataview} dataview\n * @param {Filter} filter\n */\nfunction initDataFilter (dataview, filter) {\n  var facet;\n\n  // use the partitions as groups:\n  var groupFns = [];\n  filter.partitions.forEach(function (partition) {\n    facet = dataview.facets.get(partition.facetName, 'name');\n    var valueFn = utildx.valueFn(facet);\n    var groupFn = utildx.groupFn(partition);\n\n    var rank = partition.rank;\n    groupFns[rank - 1] = function (d) {\n      return groupFn(valueFn(d));\n    };\n  });\n\n  // and then create keys from the group values\n  var groupsKeys = function (d) {\n    var keys = [];\n\n    groupFns.forEach(function (groupFn) {\n      var result = groupFn(d);\n      var newKeys = [];\n      if (keys.length === 0) {\n        if (result instanceof Array) {\n          newKeys = result;\n        } else {\n          newKeys = [result];\n        }\n      } else {\n        if (result instanceof Array) {\n          keys.forEach(function (oldKey) {\n            result.forEach(function (key) {\n              newKeys.push(oldKey + '|' + key);\n            });\n          });\n        } else {\n          keys.forEach(function (oldKey) {\n            newKeys.push(oldKey + '|' + result);\n          });\n        }\n      }\n      keys = newKeys;\n    });\n    return keys;\n  };\n\n  // set up the facet valueFns to aggregate over\n  // and the reduction functions for them\n  var aggregateFns = [];\n  var aggregateRanks = [];\n  var reduceFns = [];\n  filter.aggregates.forEach(function (aggregate) {\n    facet = dataview.facets.get(aggregate.facetName, 'name');\n    aggregateRanks.push(aggregate.rank);\n    aggregateFns.push(utildx.valueFn(facet));\n    reduceFns.push(utildx.reduceFn(aggregate));\n  });\n\n  // setup the crossfilter dimensions and groups\n  filter.dimension = dataview.crossfilter.dimension(function (d) {\n    return groupsKeys(d);\n  }, true);\n  var crossfilterGroup = filter.dimension.group(function (d) { return d; });\n\n  crossfilterGroup.reduce(\n    // add\n    function (p, d) {\n      if (aggregateFns.length === 0) {\n        p[0] = p[0] ? p[0] : {count: 0};\n        p[0].count += 1;\n      }\n\n      aggregateFns.forEach(function (aggregateFn, i) {\n        var val = aggregateFn(d);\n        if (val !== misval) {\n          val = parseFloat(val);\n          p[i] = p[i] || {count: 0, sum: 0, sumsquares: 0};\n          p[i].count += 1;\n          p[i].sum += val;\n          p[i].sumsquares += val * val;\n        }\n      });\n      return p;\n    },\n    // subtract\n    function (p, d) {\n      if (aggregateFns.length === 0) {\n        p[0] = p[0] ? p[0] : {count: 0};\n        p[0].count -= 1;\n      }\n\n      aggregateFns.forEach(function (aggregateFn, i) {\n        var val = aggregateFn(d);\n        if (val !== misval) {\n          val = parseFloat(val);\n          p[i] = p[i] || {count: 0, sum: 0, sumsquares: 0};\n          p[i].count -= 1;\n          p[i].sum -= val;\n          p[i].sumsquares -= val * val;\n        }\n      });\n      return p;\n    },\n    // initialize\n    function () {\n      return [];\n    }\n  );\n\n  filter.getData = function () {\n    filter.data = [];\n\n    // Get data from crossfilter\n    var groups = crossfilterGroup.all();\n\n    // { key: \"group1|group2|...\",\n    //   value: [ {count: agg1, sum: agg1}\n    //            {count: agg2, sum: agg2}\n    //            {count: agg3, sum: agg3}\n    //                    ...             ]}\n    groups.forEach(function (group) {\n      var item = {};\n\n      // turn the string back into individual group values\n      var groupsKeys;\n      if (typeof group.key === 'string') {\n        groupsKeys = group.key.split('|');\n      } else {\n        // shortcut for numeric non-partitioned case\n        groupsKeys = [group.key];\n      }\n\n      // add paritioning data to the item\n      groupsKeys.forEach(function (subkey, i) {\n        item[grpIdxToName[i]] = subkey;\n      });\n\n      // add aggregated data to the item\n      reduceFns.forEach(function (reduceFn, i) {\n        var name = aggRankToName[aggregateRanks[i]];\n        item[name] = reduceFn(group.value[i]);\n      });\n\n      // add an overall count\n      // becuase the filtering removes missing data points, this is the same as\n      // the count for any one of the aggregates\n      item.count = group.value[0] ? group.value[0].count : 0;\n\n      filter.data.push(item);\n    });\n  };\n}\n\n/**\n * The opposite or initDataFilter, it should remove the filter and deallocate other configuration\n * related to the filter.\n * @param {Dataview} dataview\n * @param {Filter} filter\n */\nfunction releaseDataFilter (dataview, filter) {\n  if (filter.dimension) {\n    filter.dimension.filterAll();\n    filter.dimension.dispose();\n    delete filter.dimension;\n    delete filter.getData;\n  }\n}\n\n/**\n * Change the filter parameters for an initialized filter\n * @param {Filter} filter\n */\nfunction updateDataFilter (filter) {\n  if (filter.dimension) {\n    filter.dimension.filterFunction(filter.filterFunction());\n  }\n}\n\n/**\n * Get data for every filter, and trigger a 'newData' event\n *\n * Returns a Promise that resolves to the dataview when all data and metadata has been updated\n *\n * @param {Dataview} dataview\n * @returns {Promise}\n */\nfunction getData (dataview) {\n  dataview.filters.forEach(function (filter) {\n    if (filter.isInitialized) {\n      filter.getData();\n      filter.trigger('newData');\n    }\n  });\n\n  // update counts\n  dataview.dataTotal = dataview.crossfilter.size();\n  dataview.dataSelected = dataview.countGroup.value();\n  dataview.trigger('newMetaData');\n\n  return Promise.resolve(dataview);\n}\n\nmodule.exports = {\n  driverType: 'client',\n  scan: scan,\n  setMinMax: setMinMax,\n  setCategories: setCategories,\n  setPercentiles: setPercentiles,\n  initDataFilter: initDataFilter,\n  releaseDataFilter: releaseDataFilter,\n  updateDataFilter: updateDataFilter,\n  getData: getData\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIwYy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZHJpdmVyL2NsaWVudC5qcz9kZjc3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2xpZW50IHNpZGUgZmlsdGVyaW5nIHVzaW5nIGNyb3NzZmlsdGVyXG4gKiBEdWUgdG8gbGltaXRhdGlvbiBvZiBjcm9zc2ZpbHRlciB3aXRoIGFycmF5IChvciBkYXRhIHRoYXQgaGFzIG5vIG5hdHJ1YWwgb3JkZXJpbmcpLCB0aGlzIHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQ6XG4gKiAqIGRpbWVuc2lvbjogYGZ1bmN0aW9uIChkKSB7cmV0dXJuIFtkLngsIGQueSwgZC56XX1gXG4gKiAqIGdyb3VwOiBgZnVuY3Rpb24gKGQpIHtyZXR1cm4gW2QueCAvIDEwICwgZC55IC8gMTAsIGQueiAvIDEwXX1gXG4gKlxuICogVGhlcmVmb3JlLCB3ZSBwcmVmb3JtIGdyb3VwaW5nIGFscmVhZHkgaW4gdGhlIGRpbWVuc2lvbiBpdHNlbGYsIGFuZCBqb2luIHRoZSBhcnJheSB0byBhIHN0cmluZy5cbiAqIFN0cmluZ3MgaGF2ZSBhIG5hdHVyYWwgb3JkZXJpbmcgYW5kIHRodXMgY2FuIGJlIHVzZWQgYXMgZGltZW5zaW9uIHZhbHVlLlxuICogKiBkaW1lbnNpb246IGBmdW5jdGlvbiAoZCkgLT4gXCJkLngvMTB8ZC55LzEwfGQuei8xMFwiYFxuICogKiBncm91cDogYGZ1bmN0aW9uIChkKSB7cmV0dXJuIGQ7fWBcbiAqXG4gKiBAbW9kdWxlIGRyaXZlci9jbGllbnRcbiAqL1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudC10aW1lem9uZScpO1xuXG52YXIgdXRpbGR4ID0gcmVxdWlyZSgnLi4vdXRpbC9jcm9zc2ZpbHRlcicpO1xudmFyIG1pc3ZhbCA9IHJlcXVpcmUoJy4uL3V0aWwvbWlzdmFsJyk7XG5cbnZhciBncnBJZHhUb05hbWUgPSB7MDogJ2EnLCAxOiAnYicsIDI6ICdjJywgMzogJ2QnLCA0OiAnZSd9O1xudmFyIGFnZ1JhbmtUb05hbWUgPSB7MTogJ2FhJywgMjogJ2JiJywgMzogJ2NjJywgNDogJ2RkJywgNTogJ2VlJ307XG5cbi8qKlxuICogc2V0TWluTWF4IHNldHMgdGhlIHJhbmdlIG9mIGEgY29udGludW91cyBvciB0aW1lIGZhY2V0XG4gKlxuICogQHBhcmFtIHtEYXRhc2V0fSBkYXRhc2V0XG4gKiBAcGFyYW0ge0ZhY2V0fSBmYWNldFxuICovXG5mdW5jdGlvbiBzZXRNaW5NYXggKGRhdGFzZXQsIGZhY2V0KSB7XG4gIC8vIHdlIG5lZWQgdGhlIHZhbHVlIGp1c3QgYmVmb3JlIGEgdHJhbnNmb3JtYXRpb24sIHNvIGJhc2VWYWx1ZUZuXG4gIHZhciB2YWxGbiA9IHV0aWxkeC5iYXNlVmFsdWVGbihmYWNldCk7XG5cbiAgLy8gdG8gYmUgYWJsZSB0byBtYXJrIHRoZSB2YWx1ZSBhcyBtaXNzaW5nIHdlIG5lZWQgaXQgdW5wcm9jZXNzZWQsIHNvIHJhd1ZhbHVlRm5cbiAgdmFyIHJhd1ZhbEZuID0gdXRpbGR4LnJhd1ZhbHVlRm4oZmFjZXQpO1xuXG4gIHZhciBsZXNzRm47XG4gIHZhciBtb3JlRm47XG4gIGlmIChmYWNldC5pc0RhdGV0aW1lKSB7XG4gICAgbGVzc0ZuID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChiID09PSBtaXN2YWwgfHwgYS5pc0JlZm9yZShiKSk7IH07XG4gICAgbW9yZUZuID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChiID09PSBtaXN2YWwgfHwgYi5pc0JlZm9yZShhKSk7IH07XG4gIH0gZWxzZSB7XG4gICAgbGVzc0ZuID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChiID09PSBtaXN2YWwgfHwgYSA8IGIpOyB9O1xuICAgIG1vcmVGbiA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAoYiA9PT0gbWlzdmFsIHx8IGEgPiBiKTsgfTtcbiAgfVxuXG4gIHZhciBtaW52YWwgPSBtaXN2YWw7XG4gIHZhciByYXdNaW4gPSBtaXN2YWw7XG5cbiAgdmFyIG1heHZhbCA9IG1pc3ZhbDtcbiAgdmFyIHJhd01heCA9IG1pc3ZhbDtcblxuICBkYXRhc2V0LmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgIHZhciByYXdWID0gcmF3VmFsRm4oZCk7XG4gICAgdmFyIHYgPSB2YWxGbihkKTtcblxuICAgIGlmICh2ICE9PSBtaXN2YWwpIHtcbiAgICAgIGlmIChsZXNzRm4odiwgbWludmFsKSkge1xuICAgICAgICBtaW52YWwgPSB2O1xuICAgICAgICByYXdNaW4gPSByYXdWO1xuICAgICAgfVxuICAgICAgaWYgKG1vcmVGbih2LCBtYXh2YWwpKSB7XG4gICAgICAgIG1heHZhbCA9IHY7XG4gICAgICAgIHJhd01heCA9IHJhd1Y7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAobWludmFsICE9PSBtaXN2YWwpIHtcbiAgICBpZiAoZmFjZXQuaXNDb250aW51b3VzKSB7XG4gICAgICBmYWNldC5taW52YWxBc1RleHQgPSBtaW52YWwudG9TdHJpbmcoKTtcbiAgICB9IGVsc2UgaWYgKGZhY2V0LmlzRGF0ZXRpbWUpIHtcbiAgICAgIGZhY2V0Lm1pbnZhbEFzVGV4dCA9IG1pbnZhbC50b0lTT1N0cmluZygpO1xuICAgIH0gZWxzZSBpZiAoZmFjZXQuaXNEdXJhdGlvbikge1xuICAgICAgZmFjZXQubWludmFsQXNUZXh0ID0gbWludmFsLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIGZhY2V0LnJhd01pbnZhbCA9IHJhd01pbjtcbiAgfSBlbHNlIHtcbiAgICBmYWNldC5taW52YWxBc1RleHQgPSAnJztcbiAgICBmYWNldC5yYXdNaW52YWwgPSBtaXN2YWw7XG4gIH1cblxuICBpZiAobWF4dmFsICE9PSBtaXN2YWwpIHtcbiAgICBpZiAoZmFjZXQuaXNDb250aW51b3VzKSB7XG4gICAgICBmYWNldC5tYXh2YWxBc1RleHQgPSBtYXh2YWwudG9TdHJpbmcoKTtcbiAgICB9IGVsc2UgaWYgKGZhY2V0LmlzRGF0ZXRpbWUpIHtcbiAgICAgIGZhY2V0Lm1heHZhbEFzVGV4dCA9IG1heHZhbC50b0lTT1N0cmluZygpO1xuICAgIH0gZWxzZSBpZiAoZmFjZXQuaXNEdXJhdGlvbikge1xuICAgICAgZmFjZXQubWF4dmFsQXNUZXh0ID0gbWF4dmFsLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIGZhY2V0LnJhd01heHZhbCA9IHJhd01heDtcbiAgfSBlbHNlIHtcbiAgICBmYWNldC5tYXh2YWxBc1RleHQgPSAnJztcbiAgICBmYWNldC5yYXdNYXh2YWwgPSBtaXN2YWw7XG4gIH1cbn1cblxuLyoqXG4gKiBzZXRDYXRlZ29yaWVzIGZpbmRzIGZpbmRzIGFsbCB2YWx1ZXMgb24gYW4gb3JkaW5hbCAoY2F0ZWdvcmlhbCkgYXhpc1xuICogVXBkYXRlcyB0aGUgY2F0ZWdvcmlhbFRyYW5zZm9ybSBvZiB0aGUgZmFjZXRcbiAqXG4gKiBAcGFyYW0ge0RhdGFzZXR9IGRhdGFzZXRcbiAqIEBwYXJhbSB7RmFjZXR9IGZhY2V0XG4gKi9cbmZ1bmN0aW9uIHNldENhdGVnb3JpZXMgKGRhdGFzZXQsIGZhY2V0KSB7XG4gIC8vIHdlIG5lZWQgdGhlIHZhbHVlIGp1c3QgYmVmb3JlIGEgdHJhbnNmb3JtYXRpb24sIHNvIGJhc2VWYWx1ZUZuXG4gIHZhciB2YWxGbiA9IHV0aWxkeC5iYXNlVmFsdWVGbihmYWNldCk7XG5cbiAgdmFyIHAgPSB7fTtcbiAgdmFyIFBsZW5ndGggPSAwO1xuICBkYXRhc2V0LmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHZhciB2YWxzID0gdmFsRm4oZCk7XG4gICAgaWYgKHZhbHMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdmFscy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgaWYgKHAuaGFzT3duUHJvcGVydHkodmFsKSkge1xuICAgICAgICAgIHBbdmFsXSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChQbGVuZ3RoIDwgNzUpIHsgLy8gTk9URTogbGltaXQgdG8gbWF4aW1hbGx5IDc1IGNhdGVnb3JpZXNcbiAgICAgICAgICAgIHBbdmFsXSA9IDE7XG4gICAgICAgICAgICBQbGVuZ3RoKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHAuaGFzT3duUHJvcGVydHkodmFscykpIHtcbiAgICAgICAgcFt2YWxzXSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKFBsZW5ndGggPCA3NSkgeyAvLyBOT1RFOiBsaW1pdCB0byBtYXhpbWFsbHkgNzUgY2F0ZWdvcmllc1xuICAgICAgICAgIHBbdmFsc10gPSAxO1xuICAgICAgICAgIFBsZW5ndGgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgZmFjZXQuY2F0ZWdvcmlhbFRyYW5zZm9ybS5yZXNldCgpO1xuXG4gIE9iamVjdC5rZXlzKHApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIC8vIFRPRE86IG1pc3NpbmcgZGF0YSBzaG91bGQgYmUgbWFwcGVkIHRvIGEgbWlzdmFsIGZyb20gbWlzdmFsQXNUZXh0XG4gICAgdmFyIGtleUFzU3RyaW5nID0ga2V5LnRvU3RyaW5nKCk7XG4gICAgdmFyIGdyb3VwQXNTdHJpbmcgPSBrZXlBc1N0cmluZztcblxuICAgIGZhY2V0LmNhdGVnb3JpYWxUcmFuc2Zvcm0ucnVsZXMuYWRkKHtleHByZXNzaW9uOiBrZXlBc1N0cmluZywgY291bnQ6IHBba2V5XSwgZ3JvdXA6IGdyb3VwQXNTdHJpbmd9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIDEwMCBwZXJjZW50aWxlcyAoaWUuIDEsMiwzLDQgZXRjLiksIGFuZCBpbml0aWFsaXplIHRoZSBgZmFjZXQuY29udGludW91c1RyYW5zZm9ybWBcbiAqIHRvIGFuIGFwcHJveGltYXRlIHBlcmNlbnRpbGUgbWFwcGluZy5cbiAqIFVzZSB0aGUgcmVjb21tZW5kZWQgbWV0aG9kIGZyb20gW05JU1RdKGh0dHA6Ly93d3cuaXRsLm5pc3QuZ292L2Rpdjg5OC9oYW5kYm9vay9wcmMvc2VjdGlvbjIvcHJjMjYyLmh0bSlcbiAqIFNlZSBhbHNvIHRoZSBkaXNjdXNzaW9uIG9uIFtXaWtpcGVkaWFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BlcmNlbnRpbGUpXG4gKlxuICogQHBhcmFtIHtEYXRhc2V0fSBkYXRhc2V0XG4gKiBAcGFyYW0ge0ZhY2V0fSBmYWNldFxuICovXG5mdW5jdGlvbiBzZXRQZXJjZW50aWxlcyAoZGF0YXNldCwgZmFjZXQpIHtcbiAgLy8gd2UgbmVlZCB0aGUgdmFsdWUganVzdCBiZWZvcmUgYSB0cmFuc2Zvcm1hdGlvbiwgc28gYmFzZVZhbHVlRm5cbiAgdmFyIGJhc2V2YWx1ZUZuID0gdXRpbGR4LmJhc2VWYWx1ZUZuKGZhY2V0KTtcbiAgdmFyIGRhdGEgPSBkYXRhc2V0LmRhdGE7XG5cbiAgZGF0YS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIHZhbEEgPSBiYXNldmFsdWVGbihhKTtcbiAgICB2YXIgdmFsQiA9IGJhc2V2YWx1ZUZuKGIpO1xuXG4gICAgaWYgKHZhbEEgPT09IHZhbEIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAodmFsQSA9PT0gbWlzdmFsKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmICh2YWxCID09PSBtaXN2YWwpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICh2YWxBIDwgdmFsQikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciB0ZiA9IGZhY2V0LmNvbnRpbnVvdXNUcmFuc2Zvcm07XG4gIHZhciB4LCBpO1xuXG4gIC8vIGRyb3AgbWlzc2luZyB2YWx1ZXMsIHdoaWNoIHNob3VsZCBiZSBzb3J0ZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBhcnJheVxuICBpID0gMDtcbiAgd2hpbGUgKGJhc2V2YWx1ZUZuKGRhdGFbaV0pID09PSBtaXN2YWwgJiYgaSA8IGRhdGEubGVuZ3RoKSB7XG4gICAgaSsrO1xuICB9XG4gIGRhdGEuc3BsaWNlKDAsIGkpO1xuXG4gIC8vIHN0YXJ0IGNsZWFuXG4gIHRmLnJlc2V0KCk7XG5cbiAgLy8gYWRkIG1pbmltdW0gdmFsdWUgYXMgY29udHJvbCBwb2ludHMgcDAgYW5kIHAxXG4gIHRmLmNwcy5hZGQoe3g6IGJhc2V2YWx1ZUZuKGRhdGFbMF0pLCBmeDogMH0pO1xuICB0Zi5jcHMuYWRkKHt4OiBiYXNldmFsdWVGbihkYXRhWzBdKSwgZng6IDB9KTtcblxuICB2YXIgcCwgdmFsdWU7XG4gIGZvciAocCA9IDE7IHAgPCAxMDA7IHArKykge1xuICAgIHggPSAocCAqIDAuMDEpICogKGRhdGEubGVuZ3RoICsgMSkgLSAxOyAvLyBpbmRleGluZyBzdGFydHMgYXQgemVybywgbm90IGF0IG9uZVxuICAgIGkgPSBNYXRoLnRydW5jKHgpO1xuICAgIHZhbHVlID0gKDEgLSB4ICsgaSkgKiBiYXNldmFsdWVGbihkYXRhW2ldKSArICh4IC0gaSkgKiBiYXNldmFsdWVGbihkYXRhW2kgKyAxXSk7XG4gICAgdGYuY3BzLmFkZCh7eDogdmFsdWUsIGZ4OiBwfSk7XG4gIH1cblxuICAvLyBhZGQgbWF4aW11bSB2YWx1ZSBhcyBwMTAxIGFuZCBwMTAyXG4gIHRmLmNwcy5hZGQoe3g6IGJhc2V2YWx1ZUZuKGRhdGFbZGF0YS5sZW5ndGggLSAxXSksIGZ4OiAxMDB9KTtcbiAgdGYuY3BzLmFkZCh7eDogYmFzZXZhbHVlRm4oZGF0YVtkYXRhLmxlbmd0aCAtIDFdKSwgZng6IDEwMH0pO1xuXG4gIHRmLnR5cGUgPSAncGVyY2VudGlsZXMnO1xufVxuXG4vKipcbiAqIEF1dG9jb25maWd1cmUgYSBkYXRhc2V0OlxuICogMS4gcGljayAxMCByYW5kb20gZWxlbWVudHNcbiAqIDIuIGNyZWF0ZSBmYWNldHMgZm9yIHRoZWlyIHByb3BlcnRpZXNcbiAqIDMuIGFkZCBmYWNldHMnIHZhbHVlcyBvdmVyIHRoZSBzYW1wbGUgdG8gdGhlIGZhY2V0LmRlc2NyaXB0aW9uXG4gKiA0LiBzZXQgcmFuZ2Ugb3IgY2F0ZWdvcmllc1xuICpcbiAqIEBwYXJhbSB7RGF0YXNldH0gZGF0YXNldFxuICovXG5mdW5jdGlvbiBzY2FuIChkYXRhc2V0KSB7XG4gIGZ1bmN0aW9uIGZhY2V0RXhpc3RzIChmYWNldHMsIHBhdGgpIHtcbiAgICB2YXIgZXhpc3RzID0gZmFsc2U7XG4gICAgZmFjZXRzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgIGlmIChmLmFjY2Vzc29yID09PSBwYXRoIHx8IGYuYWNjZXNzb3IgPT09IHBhdGggKyAnW10nKSB7XG4gICAgICAgIGV4aXN0cyA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGV4aXN0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZhbHVlICh2YWx1ZXMsIHYsIG1pc3NpbmcpIHtcbiAgICBpZiAodiA9PT0gbWlzdmFsKSB7XG4gICAgICB2ID0gbWlzc2luZztcbiAgICB9XG4gICAgaWYgKHZhbHVlcy5pbmRleE9mKHYpID09PSAtMSkge1xuICAgICAgdmFsdWVzLnB1c2godik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ3Vlc3NUeXBlICh2YWx1ZXMpIHtcbiAgICB2YXIgbXl0eXBlID0ge1xuICAgICAgY29udGludW91czogMCxcbiAgICAgIHRleHQ6IDAsXG4gICAgICBkYXRldGltZTogMCxcbiAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgY2F0ZWdvcmlhbDogMFxuICAgIH07XG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAobW9tZW50KHZhbHVlLCBtb21lbnQuSVNPXzg2MDEpLmlzVmFsaWQoKSkge1xuICAgICAgICAvLyBcIjIwMTYtMDgtMTcgMTc6MjU6MDArMDFcIlxuICAgICAgICBteXR5cGUuZGF0ZXRpbWUrKztcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgKG1vbWVudC5kdXJhdGlvbih2YWx1ZSkuYXNNaWxsaXNlY29uZHMoKSAhPT0gMCkgJiZcbiAgICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgJiZcbiAgICAgICAgICAodmFsdWVbMF0udG9Mb3dlckNhc2UoKSA9PT0gJ3AnKSkge1xuICAgICAgICAvLyBcIlAxMFlcIlxuICAgICAgICBteXR5cGUuZHVyYXRpb24rKztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gK3ZhbHVlKSB7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgICAvLyBcIjEwXCIgb3IgMTBcbiAgICAgICAgbXl0eXBlLmNvbnRpbnVvdXMrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFwiaGVsbG8gd29ybGRcIlxuICAgICAgICBteXR5cGUuY2F0ZWdvcmlhbCsrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZ2V0IGZhY2V0VHlwZSB3aXRoIGhpZ2hlc3QgY291bnRcbiAgICB2YXIgbWF4ID0gLTE7XG4gICAgdmFyIGZhY2V0VHlwZTtcbiAgICBPYmplY3Qua2V5cyhteXR5cGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKG15dHlwZVtrZXldID4gbWF4KSB7XG4gICAgICAgIGZhY2V0VHlwZSA9IGtleTtcbiAgICAgICAgbWF4ID0gbXl0eXBlW2tleV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZmFjZXRUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5RmFjZXQgKGZhY2V0cywgZGF0YSwgcGF0aCwgdmFsdWUpIHtcbiAgICAvLyBDaGVjayBmb3IgZXhpc3RlbmNlXG4gICAgaWYgKGZhY2V0RXhpc3RzKGZhY2V0cywgcGF0aCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgZmFjZXRcbiAgICB2YXIgZmFjZXQgPSBmYWNldHMuYWRkKHtcbiAgICAgIG5hbWU6IHBhdGgsXG4gICAgICBhY2Nlc3NvcjogcGF0aCxcbiAgICAgIHR5cGU6ICd0ZXh0J1xuICAgIH0pO1xuXG4gICAgLy8gU2FtcGxlIHZhbHVlc1xuICAgIHZhciBiYXNlVmFsdWVGbiA9IHV0aWxkeC5iYXNlVmFsdWVGbihmYWNldCk7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIHZhciBpc0FycmF5ID0gZmFsc2U7XG5cbiAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGJhc2VWYWx1ZUZuKGQpO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgaXNBcnJheSA9IHRydWU7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICBhZGRWYWx1ZSh2YWx1ZXMsIHYsIGZhY2V0Lm1pc3ZhbFswXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkVmFsdWUodmFsdWVzLCB2YWx1ZSwgZmFjZXQubWlzdmFsWzBdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJlY29uZmlndXJlIGZhY2V0XG4gICAgZmFjZXQuYWNjZXNzb3IgPSBpc0FycmF5ID8gZmFjZXQuYWNjZXNzb3IgKyAnW10nIDogZmFjZXQuYWNjZXNzb3I7XG4gICAgZmFjZXQudHlwZSA9IGd1ZXNzVHlwZSh2YWx1ZXMpO1xuICAgIGZhY2V0LmRlc2NyaXB0aW9uID0gdmFsdWVzLmpvaW4oJywgJykubWF0Y2goJ14uezAsNDB9JykgKyAnLi4uJztcbiAgICBmYWNldC5pc0FjdGl2ZSA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiByZWN1cnNlIChmYWNldHMsIGRhdGEsIHBhdGgsIHRyZWUpIHtcbiAgICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0cmVlKTtcbiAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgc3VicGF0aDtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHN1YnBhdGggPSBwYXRoICsgJyMjJyArIG5hbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJwYXRoID0gbmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyZWVbbmFtZV0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAvLyBhZGQgYW4gYXJyYXkgYXMgYSBpdHNlbGYgYXMgYSBmYWNldCwgaWUuIGxhYmVsc2V0LCB0byBwcmV2ZW50IGFkZGluZyBlYWNoIGVsZW1lbnQgYXMgc2VwYXJhdGUgZmFjZXRcbiAgICAgICAgLy8gYWxzbyBhZGQgdGhlIGFycmF5IGxlbmd0aCBhcyBmYWNldFxuICAgICAgICB0cnlGYWNldChmYWNldHMsIGRhdGEsIHN1YnBhdGgsIHRyZWVbbmFtZV0pO1xuICAgICAgICB0cnlGYWNldChmYWNldHMsIGRhdGEsIHN1YnBhdGggKyAnLmxlbmd0aCcsIHRyZWVbbmFtZV0ubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSBpZiAodHJlZVtuYW1lXSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAvLyByZWN1cnNlIGludG8gb2JqZWN0c1xuICAgICAgICByZWN1cnNlKGZhY2V0cywgZGF0YSwgc3VicGF0aCwgdHJlZVtuYW1lXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhZGQgc3RyaW5ncyBhbmQgbnVtYmVycyBhcyBmYWNldHNcbiAgICAgICAgdHJ5RmFjZXQoZmFjZXRzLCBkYXRhLCBzdWJwYXRoLCB0cmVlW25hbWVdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIEFkZCBmYWNldHNcbiAgdmFyIGRhdGEgPSBkYXRhc2V0LmRhdGEuc2xpY2UoMCwgMTApO1xuICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICByZWN1cnNlKGRhdGFzZXQuZmFjZXRzLCBkYXRhLCAnJywgZCk7XG4gIH0pO1xuXG4gIGRhdGFzZXQuZmFjZXRzLmZvckVhY2goZnVuY3Rpb24gKGZhY2V0KSB7XG4gICAgaWYgKGZhY2V0LmlzQ2F0ZWdvcmlhbCkge1xuICAgICAgc2V0Q2F0ZWdvcmllcyhkYXRhc2V0LCBmYWNldCk7XG4gICAgfSBlbHNlIGlmIChmYWNldC5pc0NvbnRpbnVvdXMgfHwgZmFjZXQuaXNEYXRldGltZSkge1xuICAgICAgc2V0TWluTWF4KGRhdGFzZXQsIGZhY2V0KTtcbiAgICB9XG4gIH0pO1xuICBkYXRhc2V0LnRyaWdnZXIoJ3N5bmNGYWNldHMnKTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBkYXRhIGZpbHRlciwgYW5kIGNvbnN0cnVjdCB0aGUgZ2V0RGF0YSBjYWxsYmFjayBmdW5jdGlvbiBvbiB0aGUgZmlsdGVyLlxuICogQHBhcmFtIHtEYXRhdmlld30gZGF0YXZpZXdcbiAqIEBwYXJhbSB7RmlsdGVyfSBmaWx0ZXJcbiAqL1xuZnVuY3Rpb24gaW5pdERhdGFGaWx0ZXIgKGRhdGF2aWV3LCBmaWx0ZXIpIHtcbiAgdmFyIGZhY2V0O1xuXG4gIC8vIHVzZSB0aGUgcGFydGl0aW9ucyBhcyBncm91cHM6XG4gIHZhciBncm91cEZucyA9IFtdO1xuICBmaWx0ZXIucGFydGl0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0aXRpb24pIHtcbiAgICBmYWNldCA9IGRhdGF2aWV3LmZhY2V0cy5nZXQocGFydGl0aW9uLmZhY2V0TmFtZSwgJ25hbWUnKTtcbiAgICB2YXIgdmFsdWVGbiA9IHV0aWxkeC52YWx1ZUZuKGZhY2V0KTtcbiAgICB2YXIgZ3JvdXBGbiA9IHV0aWxkeC5ncm91cEZuKHBhcnRpdGlvbik7XG5cbiAgICB2YXIgcmFuayA9IHBhcnRpdGlvbi5yYW5rO1xuICAgIGdyb3VwRm5zW3JhbmsgLSAxXSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZ3JvdXBGbih2YWx1ZUZuKGQpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBhbmQgdGhlbiBjcmVhdGUga2V5cyBmcm9tIHRoZSBncm91cCB2YWx1ZXNcbiAgdmFyIGdyb3Vwc0tleXMgPSBmdW5jdGlvbiAoZCkge1xuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBncm91cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cEZuKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZ3JvdXBGbihkKTtcbiAgICAgIHZhciBuZXdLZXlzID0gW107XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgbmV3S2V5cyA9IHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdLZXlzID0gW3Jlc3VsdF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAob2xkS2V5KSB7XG4gICAgICAgICAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgIG5ld0tleXMucHVzaChvbGRLZXkgKyAnfCcgKyBrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChvbGRLZXkpIHtcbiAgICAgICAgICAgIG5ld0tleXMucHVzaChvbGRLZXkgKyAnfCcgKyByZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBrZXlzID0gbmV3S2V5cztcbiAgICB9KTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBzZXQgdXAgdGhlIGZhY2V0IHZhbHVlRm5zIHRvIGFnZ3JlZ2F0ZSBvdmVyXG4gIC8vIGFuZCB0aGUgcmVkdWN0aW9uIGZ1bmN0aW9ucyBmb3IgdGhlbVxuICB2YXIgYWdncmVnYXRlRm5zID0gW107XG4gIHZhciBhZ2dyZWdhdGVSYW5rcyA9IFtdO1xuICB2YXIgcmVkdWNlRm5zID0gW107XG4gIGZpbHRlci5hZ2dyZWdhdGVzLmZvckVhY2goZnVuY3Rpb24gKGFnZ3JlZ2F0ZSkge1xuICAgIGZhY2V0ID0gZGF0YXZpZXcuZmFjZXRzLmdldChhZ2dyZWdhdGUuZmFjZXROYW1lLCAnbmFtZScpO1xuICAgIGFnZ3JlZ2F0ZVJhbmtzLnB1c2goYWdncmVnYXRlLnJhbmspO1xuICAgIGFnZ3JlZ2F0ZUZucy5wdXNoKHV0aWxkeC52YWx1ZUZuKGZhY2V0KSk7XG4gICAgcmVkdWNlRm5zLnB1c2godXRpbGR4LnJlZHVjZUZuKGFnZ3JlZ2F0ZSkpO1xuICB9KTtcblxuICAvLyBzZXR1cCB0aGUgY3Jvc3NmaWx0ZXIgZGltZW5zaW9ucyBhbmQgZ3JvdXBzXG4gIGZpbHRlci5kaW1lbnNpb24gPSBkYXRhdmlldy5jcm9zc2ZpbHRlci5kaW1lbnNpb24oZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZ3JvdXBzS2V5cyhkKTtcbiAgfSwgdHJ1ZSk7XG4gIHZhciBjcm9zc2ZpbHRlckdyb3VwID0gZmlsdGVyLmRpbWVuc2lvbi5ncm91cChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZDsgfSk7XG5cbiAgY3Jvc3NmaWx0ZXJHcm91cC5yZWR1Y2UoXG4gICAgLy8gYWRkXG4gICAgZnVuY3Rpb24gKHAsIGQpIHtcbiAgICAgIGlmIChhZ2dyZWdhdGVGbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHBbMF0gPSBwWzBdID8gcFswXSA6IHtjb3VudDogMH07XG4gICAgICAgIHBbMF0uY291bnQgKz0gMTtcbiAgICAgIH1cblxuICAgICAgYWdncmVnYXRlRm5zLmZvckVhY2goZnVuY3Rpb24gKGFnZ3JlZ2F0ZUZuLCBpKSB7XG4gICAgICAgIHZhciB2YWwgPSBhZ2dyZWdhdGVGbihkKTtcbiAgICAgICAgaWYgKHZhbCAhPT0gbWlzdmFsKSB7XG4gICAgICAgICAgdmFsID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgICAgICAgIHBbaV0gPSBwW2ldIHx8IHtjb3VudDogMCwgc3VtOiAwLCBzdW1zcXVhcmVzOiAwfTtcbiAgICAgICAgICBwW2ldLmNvdW50ICs9IDE7XG4gICAgICAgICAgcFtpXS5zdW0gKz0gdmFsO1xuICAgICAgICAgIHBbaV0uc3Vtc3F1YXJlcyArPSB2YWwgKiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcbiAgICAvLyBzdWJ0cmFjdFxuICAgIGZ1bmN0aW9uIChwLCBkKSB7XG4gICAgICBpZiAoYWdncmVnYXRlRm5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBwWzBdID0gcFswXSA/IHBbMF0gOiB7Y291bnQ6IDB9O1xuICAgICAgICBwWzBdLmNvdW50IC09IDE7XG4gICAgICB9XG5cbiAgICAgIGFnZ3JlZ2F0ZUZucy5mb3JFYWNoKGZ1bmN0aW9uIChhZ2dyZWdhdGVGbiwgaSkge1xuICAgICAgICB2YXIgdmFsID0gYWdncmVnYXRlRm4oZCk7XG4gICAgICAgIGlmICh2YWwgIT09IG1pc3ZhbCkge1xuICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICAgICAgICBwW2ldID0gcFtpXSB8fCB7Y291bnQ6IDAsIHN1bTogMCwgc3Vtc3F1YXJlczogMH07XG4gICAgICAgICAgcFtpXS5jb3VudCAtPSAxO1xuICAgICAgICAgIHBbaV0uc3VtIC09IHZhbDtcbiAgICAgICAgICBwW2ldLnN1bXNxdWFyZXMgLT0gdmFsICogdmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgLy8gaW5pdGlhbGl6ZVxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICk7XG5cbiAgZmlsdGVyLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgZmlsdGVyLmRhdGEgPSBbXTtcblxuICAgIC8vIEdldCBkYXRhIGZyb20gY3Jvc3NmaWx0ZXJcbiAgICB2YXIgZ3JvdXBzID0gY3Jvc3NmaWx0ZXJHcm91cC5hbGwoKTtcblxuICAgIC8vIHsga2V5OiBcImdyb3VwMXxncm91cDJ8Li4uXCIsXG4gICAgLy8gICB2YWx1ZTogWyB7Y291bnQ6IGFnZzEsIHN1bTogYWdnMX1cbiAgICAvLyAgICAgICAgICAgIHtjb3VudDogYWdnMiwgc3VtOiBhZ2cyfVxuICAgIC8vICAgICAgICAgICAge2NvdW50OiBhZ2czLCBzdW06IGFnZzN9XG4gICAgLy8gICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgICBdfVxuICAgIGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgdmFyIGl0ZW0gPSB7fTtcblxuICAgICAgLy8gdHVybiB0aGUgc3RyaW5nIGJhY2sgaW50byBpbmRpdmlkdWFsIGdyb3VwIHZhbHVlc1xuICAgICAgdmFyIGdyb3Vwc0tleXM7XG4gICAgICBpZiAodHlwZW9mIGdyb3VwLmtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZ3JvdXBzS2V5cyA9IGdyb3VwLmtleS5zcGxpdCgnfCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2hvcnRjdXQgZm9yIG51bWVyaWMgbm9uLXBhcnRpdGlvbmVkIGNhc2VcbiAgICAgICAgZ3JvdXBzS2V5cyA9IFtncm91cC5rZXldO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgcGFyaXRpb25pbmcgZGF0YSB0byB0aGUgaXRlbVxuICAgICAgZ3JvdXBzS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJrZXksIGkpIHtcbiAgICAgICAgaXRlbVtncnBJZHhUb05hbWVbaV1dID0gc3Via2V5O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGFkZCBhZ2dyZWdhdGVkIGRhdGEgdG8gdGhlIGl0ZW1cbiAgICAgIHJlZHVjZUZucy5mb3JFYWNoKGZ1bmN0aW9uIChyZWR1Y2VGbiwgaSkge1xuICAgICAgICB2YXIgbmFtZSA9IGFnZ1JhbmtUb05hbWVbYWdncmVnYXRlUmFua3NbaV1dO1xuICAgICAgICBpdGVtW25hbWVdID0gcmVkdWNlRm4oZ3JvdXAudmFsdWVbaV0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGFkZCBhbiBvdmVyYWxsIGNvdW50XG4gICAgICAvLyBiZWN1YXNlIHRoZSBmaWx0ZXJpbmcgcmVtb3ZlcyBtaXNzaW5nIGRhdGEgcG9pbnRzLCB0aGlzIGlzIHRoZSBzYW1lIGFzXG4gICAgICAvLyB0aGUgY291bnQgZm9yIGFueSBvbmUgb2YgdGhlIGFnZ3JlZ2F0ZXNcbiAgICAgIGl0ZW0uY291bnQgPSBncm91cC52YWx1ZVswXSA/IGdyb3VwLnZhbHVlWzBdLmNvdW50IDogMDtcblxuICAgICAgZmlsdGVyLmRhdGEucHVzaChpdGVtKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgb3Bwb3NpdGUgb3IgaW5pdERhdGFGaWx0ZXIsIGl0IHNob3VsZCByZW1vdmUgdGhlIGZpbHRlciBhbmQgZGVhbGxvY2F0ZSBvdGhlciBjb25maWd1cmF0aW9uXG4gKiByZWxhdGVkIHRvIHRoZSBmaWx0ZXIuXG4gKiBAcGFyYW0ge0RhdGF2aWV3fSBkYXRhdmlld1xuICogQHBhcmFtIHtGaWx0ZXJ9IGZpbHRlclxuICovXG5mdW5jdGlvbiByZWxlYXNlRGF0YUZpbHRlciAoZGF0YXZpZXcsIGZpbHRlcikge1xuICBpZiAoZmlsdGVyLmRpbWVuc2lvbikge1xuICAgIGZpbHRlci5kaW1lbnNpb24uZmlsdGVyQWxsKCk7XG4gICAgZmlsdGVyLmRpbWVuc2lvbi5kaXNwb3NlKCk7XG4gICAgZGVsZXRlIGZpbHRlci5kaW1lbnNpb247XG4gICAgZGVsZXRlIGZpbHRlci5nZXREYXRhO1xuICB9XG59XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBmaWx0ZXIgcGFyYW1ldGVycyBmb3IgYW4gaW5pdGlhbGl6ZWQgZmlsdGVyXG4gKiBAcGFyYW0ge0ZpbHRlcn0gZmlsdGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZURhdGFGaWx0ZXIgKGZpbHRlcikge1xuICBpZiAoZmlsdGVyLmRpbWVuc2lvbikge1xuICAgIGZpbHRlci5kaW1lbnNpb24uZmlsdGVyRnVuY3Rpb24oZmlsdGVyLmZpbHRlckZ1bmN0aW9uKCkpO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGRhdGEgZm9yIGV2ZXJ5IGZpbHRlciwgYW5kIHRyaWdnZXIgYSAnbmV3RGF0YScgZXZlbnRcbiAqXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkYXRhdmlldyB3aGVuIGFsbCBkYXRhIGFuZCBtZXRhZGF0YSBoYXMgYmVlbiB1cGRhdGVkXG4gKlxuICogQHBhcmFtIHtEYXRhdmlld30gZGF0YXZpZXdcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhdmlldykge1xuICBkYXRhdmlldy5maWx0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIuaXNJbml0aWFsaXplZCkge1xuICAgICAgZmlsdGVyLmdldERhdGEoKTtcbiAgICAgIGZpbHRlci50cmlnZ2VyKCduZXdEYXRhJyk7XG4gICAgfVxuICB9KTtcblxuICAvLyB1cGRhdGUgY291bnRzXG4gIGRhdGF2aWV3LmRhdGFUb3RhbCA9IGRhdGF2aWV3LmNyb3NzZmlsdGVyLnNpemUoKTtcbiAgZGF0YXZpZXcuZGF0YVNlbGVjdGVkID0gZGF0YXZpZXcuY291bnRHcm91cC52YWx1ZSgpO1xuICBkYXRhdmlldy50cmlnZ2VyKCduZXdNZXRhRGF0YScpO1xuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YXZpZXcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZHJpdmVyVHlwZTogJ2NsaWVudCcsXG4gIHNjYW46IHNjYW4sXG4gIHNldE1pbk1heDogc2V0TWluTWF4LFxuICBzZXRDYXRlZ29yaWVzOiBzZXRDYXRlZ29yaWVzLFxuICBzZXRQZXJjZW50aWxlczogc2V0UGVyY2VudGlsZXMsXG4gIGluaXREYXRhRmlsdGVyOiBpbml0RGF0YUZpbHRlcixcbiAgcmVsZWFzZURhdGFGaWx0ZXI6IHJlbGVhc2VEYXRhRmlsdGVyLFxuICB1cGRhdGVEYXRhRmlsdGVyOiB1cGRhdGVEYXRhRmlsdGVyLFxuICBnZXREYXRhOiBnZXREYXRhXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///720c\n")},"780f":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * Module dependencies.\n */\n\nvar parseuri = __webpack_require__(/*! parseuri */ \"64a0\");\nvar debug = __webpack_require__(/*! debug */ \"433b\")('socket.io-client:url');\n\n/**\n * Module exports.\n */\n\nmodule.exports = url;\n\n/**\n * URL parser.\n *\n * @param {String} url\n * @param {Object} An object meant to mimic window.location.\n *                 Defaults to window.location.\n * @api public\n */\n\nfunction url (uri, loc) {\n  var obj = uri;\n\n  // default to window.location\n  loc = loc || global.location;\n  if (null == uri) uri = loc.protocol + '//' + loc.host;\n\n  // relative path support\n  if ('string' === typeof uri) {\n    if ('/' === uri.charAt(0)) {\n      if ('/' === uri.charAt(1)) {\n        uri = loc.protocol + uri;\n      } else {\n        uri = loc.host + uri;\n      }\n    }\n\n    if (!/^(https?|wss?):\\/\\//.test(uri)) {\n      debug('protocol-less url %s', uri);\n      if ('undefined' !== typeof loc) {\n        uri = loc.protocol + '//' + uri;\n      } else {\n        uri = 'https://' + uri;\n      }\n    }\n\n    // parse\n    debug('parse %s', uri);\n    obj = parseuri(uri);\n  }\n\n  // make sure we treat `localhost:80` and `localhost` equally\n  if (!obj.port) {\n    if (/^(http|ws)$/.test(obj.protocol)) {\n      obj.port = '80';\n    } else if (/^(http|ws)s$/.test(obj.protocol)) {\n      obj.port = '443';\n    }\n  }\n\n  obj.path = obj.path || '/';\n\n  var ipv6 = obj.host.indexOf(':') !== -1;\n  var host = ipv6 ? '[' + obj.host + ']' : obj.host;\n\n  // define unique id\n  obj.id = obj.protocol + '://' + host + ':' + obj.port;\n  // define href\n  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));\n\n  return obj;\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"698d\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzgwZi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvdXJsLmpzPzAwMGMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNldXJpID0gcmVxdWlyZSgncGFyc2V1cmknKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6dXJsJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB1cmw7XG5cbi8qKlxuICogVVJMIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gQW4gb2JqZWN0IG1lYW50IHRvIG1pbWljIHdpbmRvdy5sb2NhdGlvbi5cbiAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byB3aW5kb3cubG9jYXRpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHVybCAodXJpLCBsb2MpIHtcbiAgdmFyIG9iaiA9IHVyaTtcblxuICAvLyBkZWZhdWx0IHRvIHdpbmRvdy5sb2NhdGlvblxuICBsb2MgPSBsb2MgfHwgZ2xvYmFsLmxvY2F0aW9uO1xuICBpZiAobnVsbCA9PSB1cmkpIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyBsb2MuaG9zdDtcblxuICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcbiAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdXJpKSB7XG4gICAgaWYgKCcvJyA9PT0gdXJpLmNoYXJBdCgwKSkge1xuICAgICAgaWYgKCcvJyA9PT0gdXJpLmNoYXJBdCgxKSkge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSBsb2MuaG9zdCArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIS9eKGh0dHBzP3x3c3M/KTpcXC9cXC8vLnRlc3QodXJpKSkge1xuICAgICAgZGVidWcoJ3Byb3RvY29sLWxlc3MgdXJsICVzJywgdXJpKTtcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGxvYykge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gJ2h0dHBzOi8vJyArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwYXJzZVxuICAgIGRlYnVnKCdwYXJzZSAlcycsIHVyaSk7XG4gICAgb2JqID0gcGFyc2V1cmkodXJpKTtcbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSB3ZSB0cmVhdCBgbG9jYWxob3N0OjgwYCBhbmQgYGxvY2FsaG9zdGAgZXF1YWxseVxuICBpZiAoIW9iai5wb3J0KSB7XG4gICAgaWYgKC9eKGh0dHB8d3MpJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc4MCc7XG4gICAgfSBlbHNlIGlmICgvXihodHRwfHdzKXMkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzQ0Myc7XG4gICAgfVxuICB9XG5cbiAgb2JqLnBhdGggPSBvYmoucGF0aCB8fCAnLyc7XG5cbiAgdmFyIGlwdjYgPSBvYmouaG9zdC5pbmRleE9mKCc6JykgIT09IC0xO1xuICB2YXIgaG9zdCA9IGlwdjYgPyAnWycgKyBvYmouaG9zdCArICddJyA6IG9iai5ob3N0O1xuXG4gIC8vIGRlZmluZSB1bmlxdWUgaWRcbiAgb2JqLmlkID0gb2JqLnByb3RvY29sICsgJzovLycgKyBob3N0ICsgJzonICsgb2JqLnBvcnQ7XG4gIC8vIGRlZmluZSBocmVmXG4gIG9iai5ocmVmID0gb2JqLnByb3RvY29sICsgJzovLycgKyBob3N0ICsgKGxvYyAmJiBsb2MucG9ydCA9PT0gb2JqLnBvcnQgPyAnJyA6ICgnOicgKyBvYmoucG9ydCkpO1xuXG4gIHJldHVybiBvYmo7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///780f\n")},"7d91":function(module,exports){eval("\n/**\n * Gets the keys for an object.\n *\n * @return {Array} keys\n * @api private\n */\n\nmodule.exports = Object.keys || function keys (obj){\n  var arr = [];\n  var has = Object.prototype.hasOwnProperty;\n\n  for (var i in obj) {\n    if (has.call(obj, i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiN2Q5MS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qcz83NTljIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGtleXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKXtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG4gICAgICBhcnIucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7d91\n")},"7fa4":function(module,exports,__webpack_require__){eval('var Collection = __webpack_require__(/*! ampersand-collection */ "7bd3");\nvar Filter = __webpack_require__(/*! ../filter */ "9476");\n\nmodule.exports = Collection.extend({\n  mainIndex: \'id\',\n  model: Filter,\n  comparator: function (a, b) {\n    if (a.row > b.row || a.row === b.row && a.col > b.col) {\n      return 1;\n    }\n    if (a.col === b.col) {\n      return 0;\n    }\n    return -1;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiN2ZhNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmlsdGVyL2NvbGxlY3Rpb24uanM/ODgyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ2FtcGVyc2FuZC1jb2xsZWN0aW9uJyk7XG52YXIgRmlsdGVyID0gcmVxdWlyZSgnLi4vZmlsdGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGlvbi5leHRlbmQoe1xuICBtYWluSW5kZXg6ICdpZCcsXG4gIG1vZGVsOiBGaWx0ZXIsXG4gIGNvbXBhcmF0b3I6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEucm93ID4gYi5yb3cgfHwgYS5yb3cgPT09IGIucm93ICYmIGEuY29sID4gYi5jb2wpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoYS5jb2wgPT09IGIuY29sKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7fa4\n')},8191:function(module,exports,__webpack_require__){eval("/**\n * Partition\n *\n * Describes a partitioning of the data, based on the values a Facet can take.\n *\n * @class Partition\n * @extends Base\n */\nvar BaseModel = __webpack_require__(/*! ./util/base */ \"3902\");\nvar Groups = __webpack_require__(/*! ./partition/group-collection */ \"0056\");\nvar moment = __webpack_require__(/*! moment-timezone */ \"6c9d\");\nvar selection = __webpack_require__(/*! ./util/selection */ \"1278\");\nvar util = __webpack_require__(/*! ./util/time */ \"d45b\");\n\n/*\n * @param {Partition} partition\n * @param {Group[]} groups\n * @memberof! Partition\n */\nfunction setDatetimeGroups (partition, groups) {\n  var timeStart = partition.minval;\n  var timeEnd = partition.maxval;\n  var timeRes = util.getDatetimeResolution(timeStart, timeEnd);\n  var timeZone = partition.zone;\n\n  var current = moment(timeStart);\n  while ((!current.isAfter(timeEnd)) && groups.length < 500) {\n    groups.add({\n      min: moment(current).tz(timeZone).startOf(timeRes),\n      max: moment(current).tz(timeZone).endOf(timeRes),\n      value: moment(current).tz(timeZone).startOf(timeRes).format(),\n      label: moment(current).tz(timeZone).startOf(timeRes).format()\n    });\n    current.add(1, timeRes);\n  }\n}\n\n/*\n * @param {Partition} partition\n * @param {Group[]} groups\n * @memberof! Partition\n */\nfunction setDurationGroups (partition, groups) {\n  var dStart = partition.minval;\n  var dEnd = partition.maxval;\n  var dRes = util.getDurationResolution(dStart, dEnd);\n\n  var current = Math.floor(parseFloat(dStart.as(dRes)));\n  var last = Math.floor(parseFloat(dEnd.as(dRes)));\n\n  while (current < last) {\n    groups.add({\n      min: moment.duration(current, dRes),\n      max: moment.duration(current + 1, dRes),\n      value: moment.duration(current, dRes).toISOString(),\n      label: moment.duration(current, dRes).toISOString()\n    });\n\n    current = current + 1;\n  }\n}\n\n/*\n * Setup a grouping based on the `partition.groupingContinuous`, `partition.minval`,\n * `partition.maxval`, and the `partition.groupingParam`.\n * @memberof! Partition\n * @param {Partition} partition\n * @param {Group[]} groups\n */\nfunction setContinuousGroups (partition, groups) {\n  var param = partition.groupingParam;\n  var x0, x1, size, nbins;\n\n  if (partition.groupFixedN) {\n    // A fixed number of equally sized bins\n    nbins = param;\n    x0 = partition.minval;\n    x1 = partition.maxval;\n    size = (x1 - x0) / nbins;\n  } else if (partition.groupFixedS) {\n    // A fixed bin size\n    size = param;\n    x0 = Math.floor(partition.minval / size) * size;\n    x1 = Math.ceil(partition.maxval / size) * size;\n    nbins = (x1 - x0) / size;\n  } else if (partition.groupFixedSC) {\n    // A fixed bin size, centered on 0\n    size = param;\n    x0 = (Math.floor(partition.minval / size) - 0.5) * size;\n    x1 = (Math.ceil(partition.maxval / size) + 0.5) * size;\n    nbins = (x1 - x0) / size;\n  } else if (partition.groupLog) {\n    // Fixed number of logarithmically (base 10) sized bins\n    nbins = param;\n    x0 = Math.log(partition.minval) / Math.log(10.0);\n    x1 = Math.log(partition.maxval) / Math.log(10.0);\n    size = (x1 - x0) / nbins;\n  }\n\n  function unlog (x) {\n    return Math.exp(x * Math.log(10));\n  }\n\n  var i;\n  for (i = 0; i < nbins; i++) {\n    var start = x0 + i * size;\n    var end = x0 + (i + 1) * size;\n    var mid = 0.5 * (start + end);\n\n    if (partition.groupLog) {\n      groups.add({\n        min: unlog(start),\n        max: unlog(end),\n        value: unlog(start),\n        label: unlog(end).toPrecision(5)\n      });\n    } else {\n      groups.add({\n        min: start,\n        max: end,\n        value: mid,\n        label: mid.toPrecision(5)\n      });\n    }\n  }\n}\n\n/*\n * Setup a grouping based on the `partition.categorialTransform`\n * @memberof! Partition\n * @param {Partition} partition\n * @param {Group[]} groups\n */\nfunction setCategorialGroups (partition, groups) {\n  // dataview -> filters -> filter -> partitions -> partition\n  //          -> facets\n\n  var dataview;\n  var facet;\n  try {\n    dataview = partition.collection.parent.collection.parent;\n    facet = dataview.facets.get(partition.facetName, 'name');\n  } catch (e) {\n    console.error('setCategorialGroups: cannot locate facet for this partition');\n    return;\n  }\n\n  if (facet.isCategorial) {\n    // default: a categorial facet, with a categorial parittion\n    facet.categorialTransform.rules.forEach(function (rule, i) {\n      groups.add({\n        value: rule.group,\n        label: rule.group,\n        count: rule.count\n      });\n    });\n  } else if (facet.isDatetime) {\n    var format = facet.datetimeTransform.transformedFormat;\n    var timePart = util.timeParts.get(format, 'description');\n\n    timePart.groups.forEach(function (g, i) {\n      groups.add({\n        value: g,\n        label: g,\n        count: 0\n      });\n    });\n  } else {\n    console.warn('Not implemented');\n  }\n}\n\n/**\n * Reset type, minimum and maximum values\n * @params {Partition} partition\n * @params {Object} Options - silent do not trigger change events\n * @memberof! Partition\n */\nfunction reset (options) {\n  var partition = this;\n  // partition -> partitions -> filter -> filters -> dataview\n  var filter = partition.collection.parent;\n  var dataview = filter.collection.parent;\n  var facet = dataview.facets.get(partition.facetName, 'name');\n  options = options || {};\n\n  partition.set({\n    type: facet.transform.transformedType,\n    minval: facet.transform.transformedMin,\n    maxval: facet.transform.transformedMax\n  }, options);\n}\n\nmodule.exports = BaseModel.extend({\n  dataTypes: {\n    'numberDatetimeOrDuration': {\n      set: function (value) {\n        var newValue;\n\n        // check for momentjs objects\n        if (moment.isDuration(value)) {\n          return {\n            val: moment.duration(value),\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n        if (moment.isMoment(value)) {\n          return {\n            val: value.clone(),\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n\n        // try to create momentjs objects\n        newValue = moment(value, moment.ISO_8601);\n        if (newValue.isValid()) {\n          return {\n            val: newValue,\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n        if (typeof value === 'string' && value[0].toLowerCase() === 'p') {\n          newValue = moment.duration(value);\n          return {\n            val: newValue,\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n\n        // try to set a number\n        if (value === +value) {\n          return {\n            val: +value,\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n\n        // failed..\n        return {\n          val: value,\n          type: typeof value\n        };\n      },\n      compare: function (currentVal, newVal) {\n        if (currentVal instanceof moment) {\n          return currentVal.isSame(newVal);\n        } else {\n          return +currentVal === +newVal;\n        }\n      }\n    }\n  },\n  props: {\n    /**\n     * Label for displaying on plots\n     * @memberof! Partition\n     * @type {string}\n     */\n    label: {\n      type: 'string',\n      required: true,\n      default: ''\n    },\n    /**\n     * Show a legend for this partition\n     * @memberof! Partition\n     * @type {string}\n     */\n    showLegend: {\n      type: 'boolean',\n      required: false,\n      default: true\n    },\n    /**\n     * Show an axis label for this partition\n     * @memberof! Partition\n     * @type {string}\n     */\n    showLabel: {\n      type: 'boolean',\n      required: false,\n      default: true\n    },\n\n    /**\n     * Timezone for partitioning\n     * @memberof! DatetimeTransform\n     * @type {string}\n     */\n    zone: {\n      type: 'string',\n      required: 'true',\n      default: function () {\n        return moment.tz.guess();\n      }\n    },\n\n    /**\n     * Type of this partition\n     * @memberof! Partition\n     * @type {string}\n     */\n    type: {\n      type: 'string',\n      required: true,\n      default: 'categorial',\n      values: ['constant', 'continuous', 'categorial', 'datetime', 'duration', 'text']\n    },\n\n    /**\n     * The name of the facet to partition over\n     * @memberof! Partition\n     * @type {string}\n     */\n    facetName: 'string',\n\n    /**\n     * When part of a partitioning, this deterimines the ordering\n     * @memberof! Partition\n     * @type {number}\n     */\n    rank: {\n      type: 'number',\n      required: true\n    },\n\n    /**\n     * For categorial and text Facets, the ordering can be alfabetical or by count\n     * @memberof! Partition\n     */\n    ordering: {\n      type: 'string',\n      values: ['count', 'value'],\n      required: true,\n      default: 'value'\n    },\n\n    /**\n     * For continuous or datetime Facets, the minimum value. Values lower than this are grouped to 'missing'\n     * @memberof! Partition\n     * @type {number|moment}\n     */\n    minval: 'numberDatetimeOrDuration',\n\n    /**\n     * For continuous or datetime Facets, the maximum value. Values higher than this are grouped to 'missing'\n     * @memberof! Partition\n     * @type {number|moment}\n     */\n    maxval: 'numberDatetimeOrDuration',\n\n    /**\n     * Extra parameter used in the grouping strategy: either the number of bins, or the bin size.\n     * @memberof! Partition\n     * @type {number}\n     */\n    groupingParam: ['number', true, 20],\n\n    /**\n     * Grouping strategy:\n     *  * `fixedn`  fixed number of bins in the interval [minval, maxval]\n     *  * `fixedsc` a fixed binsize, centered on zero\n     *  * `fixeds`  a fixed binsize, starting at zero\n     *  * `log`     fixed number of bins but on a logarithmic scale\n     * Don't use directly but check grouping via the groupFixedN, groupFixedSC,\n     * groupFixedS, and groupLog properties\n     * @memberof! Partition\n     * @type {number}\n     */\n    groupingContinuous: {\n      type: 'string',\n      required: true,\n      default: 'fixedn',\n      values: ['fixedn', 'fixedsc', 'fixeds', 'log']\n    },\n\n    /**\n     * Depending on the type of partition, this can be an array of the selected groups,\n     * or a numberic interval [start, end]\n     * @memberof! Partition\n     * @type {array}\n     */\n    // NOTE: for categorial facets, contains rule.group\n    selected: {\n      type: 'array',\n      required: true,\n      default: function () {\n        return [];\n      }\n    }\n  },\n  derived: {\n    // properties for: type\n    isConstant: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'constant';\n      }\n    },\n    isContinuous: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'continuous';\n      }\n    },\n    isCategorial: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'categorial';\n      }\n    },\n    isDatetime: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'datetime';\n      }\n    },\n    isDuration: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'duration';\n      }\n    },\n    isText: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'text';\n      }\n    },\n    // properties for grouping-continuous\n    groupFixedN: {\n      deps: ['groupingContinuous'],\n      fn: function () {\n        return this.groupingContinuous === 'fixedn';\n      }\n    },\n    groupFixedSC: {\n      deps: ['groupingContinuous'],\n      fn: function () {\n        return this.groupingContinuous === 'fixedsc';\n      }\n    },\n    groupFixedS: {\n      deps: ['groupingContinuous'],\n      fn: function () {\n        return this.groupingContinuous === 'fixeds';\n      }\n    },\n    groupLog: {\n      deps: ['groupingContinuous'],\n      fn: function () {\n        return this.groupingContinuous === 'log';\n      }\n    },\n    /**\n     * The (ordered) set of groups this Partition can take, making up this partition.\n     * The list is recalculated when any of the partition's properties change:\n     * 'groupingContinuous', 'groupingParam', 'minval', 'maxval', 'type', 'zone' change\n     * The list keeps itself sorted according to the partition.ordering\n     *\n     * Can be used for plotting etc.\n     * @memberof! Partition\n     * @type {Group[]}\n     */\n    groups: {\n      deps: ['groupingContinuous', 'groupingParam', 'minval', 'maxval', 'type', 'zone'],\n      fn: function () {\n        var partition = this;\n        var groups = new Groups([], {\n          parent: partition\n        });\n\n        if (partition.isCategorial) {\n          setCategorialGroups(partition, groups);\n        } else if (partition.isContinuous) {\n          setContinuousGroups(partition, groups);\n        } else if (partition.isDatetime) {\n          setDatetimeGroups(partition, groups);\n        } else if (partition.isDuration) {\n          setDurationGroups(partition, groups);\n        } else if (partition.isText) {\n          // no-op\n        } else {\n          console.error('Cannot set groups for partition', partition.getId());\n        }\n\n        return groups;\n      }\n    }\n  },\n  updateSelection: function (group) {\n    selection.updateSelection(this, group);\n  },\n  filterFunction: function () {\n    return selection.filterFunction(this);\n  },\n  reset: reset\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE5MS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvcGFydGl0aW9uLmpzPzUzODciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQYXJ0aXRpb25cbiAqXG4gKiBEZXNjcmliZXMgYSBwYXJ0aXRpb25pbmcgb2YgdGhlIGRhdGEsIGJhc2VkIG9uIHRoZSB2YWx1ZXMgYSBGYWNldCBjYW4gdGFrZS5cbiAqXG4gKiBAY2xhc3MgUGFydGl0aW9uXG4gKiBAZXh0ZW5kcyBCYXNlXG4gKi9cbnZhciBCYXNlTW9kZWwgPSByZXF1aXJlKCcuL3V0aWwvYmFzZScpO1xudmFyIEdyb3VwcyA9IHJlcXVpcmUoJy4vcGFydGl0aW9uL2dyb3VwLWNvbGxlY3Rpb24nKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQtdGltZXpvbmUnKTtcbnZhciBzZWxlY3Rpb24gPSByZXF1aXJlKCcuL3V0aWwvc2VsZWN0aW9uJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbC90aW1lJyk7XG5cbi8qXG4gKiBAcGFyYW0ge1BhcnRpdGlvbn0gcGFydGl0aW9uXG4gKiBAcGFyYW0ge0dyb3VwW119IGdyb3Vwc1xuICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAqL1xuZnVuY3Rpb24gc2V0RGF0ZXRpbWVHcm91cHMgKHBhcnRpdGlvbiwgZ3JvdXBzKSB7XG4gIHZhciB0aW1lU3RhcnQgPSBwYXJ0aXRpb24ubWludmFsO1xuICB2YXIgdGltZUVuZCA9IHBhcnRpdGlvbi5tYXh2YWw7XG4gIHZhciB0aW1lUmVzID0gdXRpbC5nZXREYXRldGltZVJlc29sdXRpb24odGltZVN0YXJ0LCB0aW1lRW5kKTtcbiAgdmFyIHRpbWVab25lID0gcGFydGl0aW9uLnpvbmU7XG5cbiAgdmFyIGN1cnJlbnQgPSBtb21lbnQodGltZVN0YXJ0KTtcbiAgd2hpbGUgKCghY3VycmVudC5pc0FmdGVyKHRpbWVFbmQpKSAmJiBncm91cHMubGVuZ3RoIDwgNTAwKSB7XG4gICAgZ3JvdXBzLmFkZCh7XG4gICAgICBtaW46IG1vbWVudChjdXJyZW50KS50eih0aW1lWm9uZSkuc3RhcnRPZih0aW1lUmVzKSxcbiAgICAgIG1heDogbW9tZW50KGN1cnJlbnQpLnR6KHRpbWVab25lKS5lbmRPZih0aW1lUmVzKSxcbiAgICAgIHZhbHVlOiBtb21lbnQoY3VycmVudCkudHoodGltZVpvbmUpLnN0YXJ0T2YodGltZVJlcykuZm9ybWF0KCksXG4gICAgICBsYWJlbDogbW9tZW50KGN1cnJlbnQpLnR6KHRpbWVab25lKS5zdGFydE9mKHRpbWVSZXMpLmZvcm1hdCgpXG4gICAgfSk7XG4gICAgY3VycmVudC5hZGQoMSwgdGltZVJlcyk7XG4gIH1cbn1cblxuLypcbiAqIEBwYXJhbSB7UGFydGl0aW9ufSBwYXJ0aXRpb25cbiAqIEBwYXJhbSB7R3JvdXBbXX0gZ3JvdXBzXG4gKiBAbWVtYmVyb2YhIFBhcnRpdGlvblxuICovXG5mdW5jdGlvbiBzZXREdXJhdGlvbkdyb3VwcyAocGFydGl0aW9uLCBncm91cHMpIHtcbiAgdmFyIGRTdGFydCA9IHBhcnRpdGlvbi5taW52YWw7XG4gIHZhciBkRW5kID0gcGFydGl0aW9uLm1heHZhbDtcbiAgdmFyIGRSZXMgPSB1dGlsLmdldER1cmF0aW9uUmVzb2x1dGlvbihkU3RhcnQsIGRFbmQpO1xuXG4gIHZhciBjdXJyZW50ID0gTWF0aC5mbG9vcihwYXJzZUZsb2F0KGRTdGFydC5hcyhkUmVzKSkpO1xuICB2YXIgbGFzdCA9IE1hdGguZmxvb3IocGFyc2VGbG9hdChkRW5kLmFzKGRSZXMpKSk7XG5cbiAgd2hpbGUgKGN1cnJlbnQgPCBsYXN0KSB7XG4gICAgZ3JvdXBzLmFkZCh7XG4gICAgICBtaW46IG1vbWVudC5kdXJhdGlvbihjdXJyZW50LCBkUmVzKSxcbiAgICAgIG1heDogbW9tZW50LmR1cmF0aW9uKGN1cnJlbnQgKyAxLCBkUmVzKSxcbiAgICAgIHZhbHVlOiBtb21lbnQuZHVyYXRpb24oY3VycmVudCwgZFJlcykudG9JU09TdHJpbmcoKSxcbiAgICAgIGxhYmVsOiBtb21lbnQuZHVyYXRpb24oY3VycmVudCwgZFJlcykudG9JU09TdHJpbmcoKVxuICAgIH0pO1xuXG4gICAgY3VycmVudCA9IGN1cnJlbnQgKyAxO1xuICB9XG59XG5cbi8qXG4gKiBTZXR1cCBhIGdyb3VwaW5nIGJhc2VkIG9uIHRoZSBgcGFydGl0aW9uLmdyb3VwaW5nQ29udGludW91c2AsIGBwYXJ0aXRpb24ubWludmFsYCxcbiAqIGBwYXJ0aXRpb24ubWF4dmFsYCwgYW5kIHRoZSBgcGFydGl0aW9uLmdyb3VwaW5nUGFyYW1gLlxuICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAqIEBwYXJhbSB7UGFydGl0aW9ufSBwYXJ0aXRpb25cbiAqIEBwYXJhbSB7R3JvdXBbXX0gZ3JvdXBzXG4gKi9cbmZ1bmN0aW9uIHNldENvbnRpbnVvdXNHcm91cHMgKHBhcnRpdGlvbiwgZ3JvdXBzKSB7XG4gIHZhciBwYXJhbSA9IHBhcnRpdGlvbi5ncm91cGluZ1BhcmFtO1xuICB2YXIgeDAsIHgxLCBzaXplLCBuYmlucztcblxuICBpZiAocGFydGl0aW9uLmdyb3VwRml4ZWROKSB7XG4gICAgLy8gQSBmaXhlZCBudW1iZXIgb2YgZXF1YWxseSBzaXplZCBiaW5zXG4gICAgbmJpbnMgPSBwYXJhbTtcbiAgICB4MCA9IHBhcnRpdGlvbi5taW52YWw7XG4gICAgeDEgPSBwYXJ0aXRpb24ubWF4dmFsO1xuICAgIHNpemUgPSAoeDEgLSB4MCkgLyBuYmlucztcbiAgfSBlbHNlIGlmIChwYXJ0aXRpb24uZ3JvdXBGaXhlZFMpIHtcbiAgICAvLyBBIGZpeGVkIGJpbiBzaXplXG4gICAgc2l6ZSA9IHBhcmFtO1xuICAgIHgwID0gTWF0aC5mbG9vcihwYXJ0aXRpb24ubWludmFsIC8gc2l6ZSkgKiBzaXplO1xuICAgIHgxID0gTWF0aC5jZWlsKHBhcnRpdGlvbi5tYXh2YWwgLyBzaXplKSAqIHNpemU7XG4gICAgbmJpbnMgPSAoeDEgLSB4MCkgLyBzaXplO1xuICB9IGVsc2UgaWYgKHBhcnRpdGlvbi5ncm91cEZpeGVkU0MpIHtcbiAgICAvLyBBIGZpeGVkIGJpbiBzaXplLCBjZW50ZXJlZCBvbiAwXG4gICAgc2l6ZSA9IHBhcmFtO1xuICAgIHgwID0gKE1hdGguZmxvb3IocGFydGl0aW9uLm1pbnZhbCAvIHNpemUpIC0gMC41KSAqIHNpemU7XG4gICAgeDEgPSAoTWF0aC5jZWlsKHBhcnRpdGlvbi5tYXh2YWwgLyBzaXplKSArIDAuNSkgKiBzaXplO1xuICAgIG5iaW5zID0gKHgxIC0geDApIC8gc2l6ZTtcbiAgfSBlbHNlIGlmIChwYXJ0aXRpb24uZ3JvdXBMb2cpIHtcbiAgICAvLyBGaXhlZCBudW1iZXIgb2YgbG9nYXJpdGhtaWNhbGx5IChiYXNlIDEwKSBzaXplZCBiaW5zXG4gICAgbmJpbnMgPSBwYXJhbTtcbiAgICB4MCA9IE1hdGgubG9nKHBhcnRpdGlvbi5taW52YWwpIC8gTWF0aC5sb2coMTAuMCk7XG4gICAgeDEgPSBNYXRoLmxvZyhwYXJ0aXRpb24ubWF4dmFsKSAvIE1hdGgubG9nKDEwLjApO1xuICAgIHNpemUgPSAoeDEgLSB4MCkgLyBuYmlucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHVubG9nICh4KSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKHggKiBNYXRoLmxvZygxMCkpO1xuICB9XG5cbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBuYmluczsgaSsrKSB7XG4gICAgdmFyIHN0YXJ0ID0geDAgKyBpICogc2l6ZTtcbiAgICB2YXIgZW5kID0geDAgKyAoaSArIDEpICogc2l6ZTtcbiAgICB2YXIgbWlkID0gMC41ICogKHN0YXJ0ICsgZW5kKTtcblxuICAgIGlmIChwYXJ0aXRpb24uZ3JvdXBMb2cpIHtcbiAgICAgIGdyb3Vwcy5hZGQoe1xuICAgICAgICBtaW46IHVubG9nKHN0YXJ0KSxcbiAgICAgICAgbWF4OiB1bmxvZyhlbmQpLFxuICAgICAgICB2YWx1ZTogdW5sb2coc3RhcnQpLFxuICAgICAgICBsYWJlbDogdW5sb2coZW5kKS50b1ByZWNpc2lvbig1KVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3Vwcy5hZGQoe1xuICAgICAgICBtaW46IHN0YXJ0LFxuICAgICAgICBtYXg6IGVuZCxcbiAgICAgICAgdmFsdWU6IG1pZCxcbiAgICAgICAgbGFiZWw6IG1pZC50b1ByZWNpc2lvbig1KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qXG4gKiBTZXR1cCBhIGdyb3VwaW5nIGJhc2VkIG9uIHRoZSBgcGFydGl0aW9uLmNhdGVnb3JpYWxUcmFuc2Zvcm1gXG4gKiBAbWVtYmVyb2YhIFBhcnRpdGlvblxuICogQHBhcmFtIHtQYXJ0aXRpb259IHBhcnRpdGlvblxuICogQHBhcmFtIHtHcm91cFtdfSBncm91cHNcbiAqL1xuZnVuY3Rpb24gc2V0Q2F0ZWdvcmlhbEdyb3VwcyAocGFydGl0aW9uLCBncm91cHMpIHtcbiAgLy8gZGF0YXZpZXcgLT4gZmlsdGVycyAtPiBmaWx0ZXIgLT4gcGFydGl0aW9ucyAtPiBwYXJ0aXRpb25cbiAgLy8gICAgICAgICAgLT4gZmFjZXRzXG5cbiAgdmFyIGRhdGF2aWV3O1xuICB2YXIgZmFjZXQ7XG4gIHRyeSB7XG4gICAgZGF0YXZpZXcgPSBwYXJ0aXRpb24uY29sbGVjdGlvbi5wYXJlbnQuY29sbGVjdGlvbi5wYXJlbnQ7XG4gICAgZmFjZXQgPSBkYXRhdmlldy5mYWNldHMuZ2V0KHBhcnRpdGlvbi5mYWNldE5hbWUsICduYW1lJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKCdzZXRDYXRlZ29yaWFsR3JvdXBzOiBjYW5ub3QgbG9jYXRlIGZhY2V0IGZvciB0aGlzIHBhcnRpdGlvbicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChmYWNldC5pc0NhdGVnb3JpYWwpIHtcbiAgICAvLyBkZWZhdWx0OiBhIGNhdGVnb3JpYWwgZmFjZXQsIHdpdGggYSBjYXRlZ29yaWFsIHBhcml0dGlvblxuICAgIGZhY2V0LmNhdGVnb3JpYWxUcmFuc2Zvcm0ucnVsZXMuZm9yRWFjaChmdW5jdGlvbiAocnVsZSwgaSkge1xuICAgICAgZ3JvdXBzLmFkZCh7XG4gICAgICAgIHZhbHVlOiBydWxlLmdyb3VwLFxuICAgICAgICBsYWJlbDogcnVsZS5ncm91cCxcbiAgICAgICAgY291bnQ6IHJ1bGUuY291bnRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGZhY2V0LmlzRGF0ZXRpbWUpIHtcbiAgICB2YXIgZm9ybWF0ID0gZmFjZXQuZGF0ZXRpbWVUcmFuc2Zvcm0udHJhbnNmb3JtZWRGb3JtYXQ7XG4gICAgdmFyIHRpbWVQYXJ0ID0gdXRpbC50aW1lUGFydHMuZ2V0KGZvcm1hdCwgJ2Rlc2NyaXB0aW9uJyk7XG5cbiAgICB0aW1lUGFydC5ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZywgaSkge1xuICAgICAgZ3JvdXBzLmFkZCh7XG4gICAgICAgIHZhbHVlOiBnLFxuICAgICAgICBsYWJlbDogZyxcbiAgICAgICAgY291bnQ6IDBcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybignTm90IGltcGxlbWVudGVkJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldCB0eXBlLCBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlc1xuICogQHBhcmFtcyB7UGFydGl0aW9ufSBwYXJ0aXRpb25cbiAqIEBwYXJhbXMge09iamVjdH0gT3B0aW9ucyAtIHNpbGVudCBkbyBub3QgdHJpZ2dlciBjaGFuZ2UgZXZlbnRzXG4gKiBAbWVtYmVyb2YhIFBhcnRpdGlvblxuICovXG5mdW5jdGlvbiByZXNldCAob3B0aW9ucykge1xuICB2YXIgcGFydGl0aW9uID0gdGhpcztcbiAgLy8gcGFydGl0aW9uIC0+IHBhcnRpdGlvbnMgLT4gZmlsdGVyIC0+IGZpbHRlcnMgLT4gZGF0YXZpZXdcbiAgdmFyIGZpbHRlciA9IHBhcnRpdGlvbi5jb2xsZWN0aW9uLnBhcmVudDtcbiAgdmFyIGRhdGF2aWV3ID0gZmlsdGVyLmNvbGxlY3Rpb24ucGFyZW50O1xuICB2YXIgZmFjZXQgPSBkYXRhdmlldy5mYWNldHMuZ2V0KHBhcnRpdGlvbi5mYWNldE5hbWUsICduYW1lJyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHBhcnRpdGlvbi5zZXQoe1xuICAgIHR5cGU6IGZhY2V0LnRyYW5zZm9ybS50cmFuc2Zvcm1lZFR5cGUsXG4gICAgbWludmFsOiBmYWNldC50cmFuc2Zvcm0udHJhbnNmb3JtZWRNaW4sXG4gICAgbWF4dmFsOiBmYWNldC50cmFuc2Zvcm0udHJhbnNmb3JtZWRNYXhcbiAgfSwgb3B0aW9ucyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZU1vZGVsLmV4dGVuZCh7XG4gIGRhdGFUeXBlczoge1xuICAgICdudW1iZXJEYXRldGltZU9yRHVyYXRpb24nOiB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbmV3VmFsdWU7XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIG1vbWVudGpzIG9iamVjdHNcbiAgICAgICAgaWYgKG1vbWVudC5pc0R1cmF0aW9uKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWw6IG1vbWVudC5kdXJhdGlvbih2YWx1ZSksXG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyRGF0ZXRpbWVPckR1cmF0aW9uJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vbWVudC5pc01vbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsOiB2YWx1ZS5jbG9uZSgpLFxuICAgICAgICAgICAgdHlwZTogJ251bWJlckRhdGV0aW1lT3JEdXJhdGlvbidcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIGNyZWF0ZSBtb21lbnRqcyBvYmplY3RzXG4gICAgICAgIG5ld1ZhbHVlID0gbW9tZW50KHZhbHVlLCBtb21lbnQuSVNPXzg2MDEpO1xuICAgICAgICBpZiAobmV3VmFsdWUuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbDogbmV3VmFsdWUsXG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyRGF0ZXRpbWVPckR1cmF0aW9uJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWVbMF0udG9Mb3dlckNhc2UoKSA9PT0gJ3AnKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBtb21lbnQuZHVyYXRpb24odmFsdWUpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWw6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgdHlwZTogJ251bWJlckRhdGV0aW1lT3JEdXJhdGlvbidcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIHNldCBhIG51bWJlclxuICAgICAgICBpZiAodmFsdWUgPT09ICt2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWw6ICt2YWx1ZSxcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXJEYXRldGltZU9yRHVyYXRpb24nXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZhaWxlZC4uXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsOiB2YWx1ZSxcbiAgICAgICAgICB0eXBlOiB0eXBlb2YgdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbiAoY3VycmVudFZhbCwgbmV3VmFsKSB7XG4gICAgICAgIGlmIChjdXJyZW50VmFsIGluc3RhbmNlb2YgbW9tZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWwuaXNTYW1lKG5ld1ZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICtjdXJyZW50VmFsID09PSArbmV3VmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwcm9wczoge1xuICAgIC8qKlxuICAgICAqIExhYmVsIGZvciBkaXNwbGF5aW5nIG9uIHBsb3RzXG4gICAgICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGxhYmVsOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZGVmYXVsdDogJydcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNob3cgYSBsZWdlbmQgZm9yIHRoaXMgcGFydGl0aW9uXG4gICAgICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHNob3dMZWdlbmQ6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNob3cgYW4gYXhpcyBsYWJlbCBmb3IgdGhpcyBwYXJ0aXRpb25cbiAgICAgKiBAbWVtYmVyb2YhIFBhcnRpdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgc2hvd0xhYmVsOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRpbWV6b25lIGZvciBwYXJ0aXRpb25pbmdcbiAgICAgKiBAbWVtYmVyb2YhIERhdGV0aW1lVHJhbnNmb3JtXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB6b25lOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJlcXVpcmVkOiAndHJ1ZScsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtb21lbnQudHouZ3Vlc3MoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiB0aGlzIHBhcnRpdGlvblxuICAgICAqIEBtZW1iZXJvZiEgUGFydGl0aW9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZGVmYXVsdDogJ2NhdGVnb3JpYWwnLFxuICAgICAgdmFsdWVzOiBbJ2NvbnN0YW50JywgJ2NvbnRpbnVvdXMnLCAnY2F0ZWdvcmlhbCcsICdkYXRldGltZScsICdkdXJhdGlvbicsICd0ZXh0J11cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZhY2V0IHRvIHBhcnRpdGlvbiBvdmVyXG4gICAgICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZhY2V0TmFtZTogJ3N0cmluZycsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHBhcnQgb2YgYSBwYXJ0aXRpb25pbmcsIHRoaXMgZGV0ZXJpbWluZXMgdGhlIG9yZGVyaW5nXG4gICAgICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHJhbms6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9yIGNhdGVnb3JpYWwgYW5kIHRleHQgRmFjZXRzLCB0aGUgb3JkZXJpbmcgY2FuIGJlIGFsZmFiZXRpY2FsIG9yIGJ5IGNvdW50XG4gICAgICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAgICAgKi9cbiAgICBvcmRlcmluZzoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICB2YWx1ZXM6IFsnY291bnQnLCAndmFsdWUnXSxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZGVmYXVsdDogJ3ZhbHVlJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb3IgY29udGludW91cyBvciBkYXRldGltZSBGYWNldHMsIHRoZSBtaW5pbXVtIHZhbHVlLiBWYWx1ZXMgbG93ZXIgdGhhbiB0aGlzIGFyZSBncm91cGVkIHRvICdtaXNzaW5nJ1xuICAgICAqIEBtZW1iZXJvZiEgUGFydGl0aW9uXG4gICAgICogQHR5cGUge251bWJlcnxtb21lbnR9XG4gICAgICovXG4gICAgbWludmFsOiAnbnVtYmVyRGF0ZXRpbWVPckR1cmF0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIEZvciBjb250aW51b3VzIG9yIGRhdGV0aW1lIEZhY2V0cywgdGhlIG1heGltdW0gdmFsdWUuIFZhbHVlcyBoaWdoZXIgdGhhbiB0aGlzIGFyZSBncm91cGVkIHRvICdtaXNzaW5nJ1xuICAgICAqIEBtZW1iZXJvZiEgUGFydGl0aW9uXG4gICAgICogQHR5cGUge251bWJlcnxtb21lbnR9XG4gICAgICovXG4gICAgbWF4dmFsOiAnbnVtYmVyRGF0ZXRpbWVPckR1cmF0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIEV4dHJhIHBhcmFtZXRlciB1c2VkIGluIHRoZSBncm91cGluZyBzdHJhdGVneTogZWl0aGVyIHRoZSBudW1iZXIgb2YgYmlucywgb3IgdGhlIGJpbiBzaXplLlxuICAgICAqIEBtZW1iZXJvZiEgUGFydGl0aW9uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBncm91cGluZ1BhcmFtOiBbJ251bWJlcicsIHRydWUsIDIwXSxcblxuICAgIC8qKlxuICAgICAqIEdyb3VwaW5nIHN0cmF0ZWd5OlxuICAgICAqICAqIGBmaXhlZG5gICBmaXhlZCBudW1iZXIgb2YgYmlucyBpbiB0aGUgaW50ZXJ2YWwgW21pbnZhbCwgbWF4dmFsXVxuICAgICAqICAqIGBmaXhlZHNjYCBhIGZpeGVkIGJpbnNpemUsIGNlbnRlcmVkIG9uIHplcm9cbiAgICAgKiAgKiBgZml4ZWRzYCAgYSBmaXhlZCBiaW5zaXplLCBzdGFydGluZyBhdCB6ZXJvXG4gICAgICogICogYGxvZ2AgICAgIGZpeGVkIG51bWJlciBvZiBiaW5zIGJ1dCBvbiBhIGxvZ2FyaXRobWljIHNjYWxlXG4gICAgICogRG9uJ3QgdXNlIGRpcmVjdGx5IGJ1dCBjaGVjayBncm91cGluZyB2aWEgdGhlIGdyb3VwRml4ZWROLCBncm91cEZpeGVkU0MsXG4gICAgICogZ3JvdXBGaXhlZFMsIGFuZCBncm91cExvZyBwcm9wZXJ0aWVzXG4gICAgICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdyb3VwaW5nQ29udGludW91czoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6ICdmaXhlZG4nLFxuICAgICAgdmFsdWVzOiBbJ2ZpeGVkbicsICdmaXhlZHNjJywgJ2ZpeGVkcycsICdsb2cnXVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgcGFydGl0aW9uLCB0aGlzIGNhbiBiZSBhbiBhcnJheSBvZiB0aGUgc2VsZWN0ZWQgZ3JvdXBzLFxuICAgICAqIG9yIGEgbnVtYmVyaWMgaW50ZXJ2YWwgW3N0YXJ0LCBlbmRdXG4gICAgICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAgICAgKiBAdHlwZSB7YXJyYXl9XG4gICAgICovXG4gICAgLy8gTk9URTogZm9yIGNhdGVnb3JpYWwgZmFjZXRzLCBjb250YWlucyBydWxlLmdyb3VwXG4gICAgc2VsZWN0ZWQ6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGVyaXZlZDoge1xuICAgIC8vIHByb3BlcnRpZXMgZm9yOiB0eXBlXG4gICAgaXNDb25zdGFudDoge1xuICAgICAgZGVwczogWyd0eXBlJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAnY29uc3RhbnQnO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNDb250aW51b3VzOiB7XG4gICAgICBkZXBzOiBbJ3R5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdjb250aW51b3VzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzQ2F0ZWdvcmlhbDoge1xuICAgICAgZGVwczogWyd0eXBlJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAnY2F0ZWdvcmlhbCc7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc0RhdGV0aW1lOiB7XG4gICAgICBkZXBzOiBbJ3R5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdkYXRldGltZSc7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc0R1cmF0aW9uOiB7XG4gICAgICBkZXBzOiBbJ3R5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdkdXJhdGlvbic7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc1RleHQ6IHtcbiAgICAgIGRlcHM6IFsndHlwZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ3RleHQnO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gcHJvcGVydGllcyBmb3IgZ3JvdXBpbmctY29udGludW91c1xuICAgIGdyb3VwRml4ZWROOiB7XG4gICAgICBkZXBzOiBbJ2dyb3VwaW5nQ29udGludW91cyddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBpbmdDb250aW51b3VzID09PSAnZml4ZWRuJztcbiAgICAgIH1cbiAgICB9LFxuICAgIGdyb3VwRml4ZWRTQzoge1xuICAgICAgZGVwczogWydncm91cGluZ0NvbnRpbnVvdXMnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwaW5nQ29udGludW91cyA9PT0gJ2ZpeGVkc2MnO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ3JvdXBGaXhlZFM6IHtcbiAgICAgIGRlcHM6IFsnZ3JvdXBpbmdDb250aW51b3VzJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cGluZ0NvbnRpbnVvdXMgPT09ICdmaXhlZHMnO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ3JvdXBMb2c6IHtcbiAgICAgIGRlcHM6IFsnZ3JvdXBpbmdDb250aW51b3VzJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cGluZ0NvbnRpbnVvdXMgPT09ICdsb2cnO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIChvcmRlcmVkKSBzZXQgb2YgZ3JvdXBzIHRoaXMgUGFydGl0aW9uIGNhbiB0YWtlLCBtYWtpbmcgdXAgdGhpcyBwYXJ0aXRpb24uXG4gICAgICogVGhlIGxpc3QgaXMgcmVjYWxjdWxhdGVkIHdoZW4gYW55IG9mIHRoZSBwYXJ0aXRpb24ncyBwcm9wZXJ0aWVzIGNoYW5nZTpcbiAgICAgKiAnZ3JvdXBpbmdDb250aW51b3VzJywgJ2dyb3VwaW5nUGFyYW0nLCAnbWludmFsJywgJ21heHZhbCcsICd0eXBlJywgJ3pvbmUnIGNoYW5nZVxuICAgICAqIFRoZSBsaXN0IGtlZXBzIGl0c2VsZiBzb3J0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwYXJ0aXRpb24ub3JkZXJpbmdcbiAgICAgKlxuICAgICAqIENhbiBiZSB1c2VkIGZvciBwbG90dGluZyBldGMuXG4gICAgICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAgICAgKiBAdHlwZSB7R3JvdXBbXX1cbiAgICAgKi9cbiAgICBncm91cHM6IHtcbiAgICAgIGRlcHM6IFsnZ3JvdXBpbmdDb250aW51b3VzJywgJ2dyb3VwaW5nUGFyYW0nLCAnbWludmFsJywgJ21heHZhbCcsICd0eXBlJywgJ3pvbmUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJ0aXRpb24gPSB0aGlzO1xuICAgICAgICB2YXIgZ3JvdXBzID0gbmV3IEdyb3VwcyhbXSwge1xuICAgICAgICAgIHBhcmVudDogcGFydGl0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwYXJ0aXRpb24uaXNDYXRlZ29yaWFsKSB7XG4gICAgICAgICAgc2V0Q2F0ZWdvcmlhbEdyb3VwcyhwYXJ0aXRpb24sIGdyb3Vwcyk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFydGl0aW9uLmlzQ29udGludW91cykge1xuICAgICAgICAgIHNldENvbnRpbnVvdXNHcm91cHMocGFydGl0aW9uLCBncm91cHMpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnRpdGlvbi5pc0RhdGV0aW1lKSB7XG4gICAgICAgICAgc2V0RGF0ZXRpbWVHcm91cHMocGFydGl0aW9uLCBncm91cHMpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnRpdGlvbi5pc0R1cmF0aW9uKSB7XG4gICAgICAgICAgc2V0RHVyYXRpb25Hcm91cHMocGFydGl0aW9uLCBncm91cHMpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnRpdGlvbi5pc1RleHQpIHtcbiAgICAgICAgICAvLyBuby1vcFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBzZXQgZ3JvdXBzIGZvciBwYXJ0aXRpb24nLCBwYXJ0aXRpb24uZ2V0SWQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JvdXBzO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgdXBkYXRlU2VsZWN0aW9uOiBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICBzZWxlY3Rpb24udXBkYXRlU2VsZWN0aW9uKHRoaXMsIGdyb3VwKTtcbiAgfSxcbiAgZmlsdGVyRnVuY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uLmZpbHRlckZ1bmN0aW9uKHRoaXMpO1xuICB9LFxuICByZXNldDogcmVzZXRcbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8191\n")},8233:function(module,exports,__webpack_require__){eval("\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"bb16\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODIzMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvZGVidWcvYnJvd3Nlci5qcz80ZDVhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgcmV0dXJuICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAod2luZG93LmNvbnNvbGUgJiYgKGNvbnNvbGUuZmlyZWJ1ZyB8fCAoY29uc29sZS5leGNlcHRpb24gJiYgY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybiBhcmdzO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncyA9IFthcmdzWzBdLCBjLCAnY29sb3I6IGluaGVyaXQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuICByZXR1cm4gYXJncztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8233\n")},"834b":function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {/**\n * Module dependencies\n */\n\nvar XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ "86e3");\nvar XHR = __webpack_require__(/*! ./polling-xhr */ "108d");\nvar JSONP = __webpack_require__(/*! ./polling-jsonp */ "2dce");\nvar websocket = __webpack_require__(/*! ./websocket */ "6b20");\n\n/**\n * Export transports.\n */\n\nexports.polling = polling;\nexports.websocket = websocket;\n\n/**\n * Polling transport polymorphic constructor.\n * Decides on xhr vs jsonp based on feature detection.\n *\n * @api private\n */\n\nfunction polling (opts) {\n  var xhr;\n  var xd = false;\n  var xs = false;\n  var jsonp = false !== opts.jsonp;\n\n  if (global.location) {\n    var isSSL = \'https:\' === location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    xd = opts.hostname !== location.hostname || port !== opts.port;\n    xs = opts.secure !== isSSL;\n  }\n\n  opts.xdomain = xd;\n  opts.xscheme = xs;\n  xhr = new XMLHttpRequest(opts);\n\n  if (\'open\' in xhr && !opts.forceJSONP) {\n    return new XHR(opts);\n  } else {\n    if (!jsonp) throw new Error(\'JSONP disabled\');\n    return new JSONP(opts);\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "698d")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODM0Yi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qcz84OTk2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xudmFyIFhIUiA9IHJlcXVpcmUoJy4vcG9sbGluZy14aHInKTtcbnZhciBKU09OUCA9IHJlcXVpcmUoJy4vcG9sbGluZy1qc29ucCcpO1xudmFyIHdlYnNvY2tldCA9IHJlcXVpcmUoJy4vd2Vic29ja2V0Jyk7XG5cbi8qKlxuICogRXhwb3J0IHRyYW5zcG9ydHMuXG4gKi9cblxuZXhwb3J0cy5wb2xsaW5nID0gcG9sbGluZztcbmV4cG9ydHMud2Vic29ja2V0ID0gd2Vic29ja2V0O1xuXG4vKipcbiAqIFBvbGxpbmcgdHJhbnNwb3J0IHBvbHltb3JwaGljIGNvbnN0cnVjdG9yLlxuICogRGVjaWRlcyBvbiB4aHIgdnMganNvbnAgYmFzZWQgb24gZmVhdHVyZSBkZXRlY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcG9sbGluZyAob3B0cykge1xuICB2YXIgeGhyO1xuICB2YXIgeGQgPSBmYWxzZTtcbiAgdmFyIHhzID0gZmFsc2U7XG4gIHZhciBqc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuXG4gIGlmIChnbG9iYWwubG9jYXRpb24pIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgeGQgPSBvcHRzLmhvc3RuYW1lICE9PSBsb2NhdGlvbi5ob3N0bmFtZSB8fCBwb3J0ICE9PSBvcHRzLnBvcnQ7XG4gICAgeHMgPSBvcHRzLnNlY3VyZSAhPT0gaXNTU0w7XG4gIH1cblxuICBvcHRzLnhkb21haW4gPSB4ZDtcbiAgb3B0cy54c2NoZW1lID0geHM7XG4gIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcblxuICBpZiAoJ29wZW4nIGluIHhociAmJiAhb3B0cy5mb3JjZUpTT05QKSB7XG4gICAgcmV0dXJuIG5ldyBYSFIob3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFqc29ucCkgdGhyb3cgbmV3IEVycm9yKCdKU09OUCBkaXNhYmxlZCcpO1xuICAgIHJldHVybiBuZXcgSlNPTlAob3B0cyk7XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///834b\n')},"86e3":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {// browser shim for xmlhttprequest module\n\nvar hasCORS = __webpack_require__(/*! has-cors */ \"0392\");\n\nmodule.exports = function (opts) {\n  var xdomain = opts.xdomain;\n\n  // scheme must be same when usign XDomainRequest\n  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n  var xscheme = opts.xscheme;\n\n  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.\n  // https://github.com/Automattic/engine.io-client/pull/217\n  var enablesXDR = opts.enablesXDR;\n\n  // XMLHttpRequest can be disabled on IE\n  try {\n    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n      return new XMLHttpRequest();\n    }\n  } catch (e) { }\n\n  // Use XDomainRequest for IE8 if enablesXDR is true\n  // because loading bar keeps flashing when using jsonp-polling\n  // https://github.com/yujiosaka/socke.io-ie8-loading-example\n  try {\n    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {\n      return new XDomainRequest();\n    }\n  } catch (e) { }\n\n  if (!xdomain) {\n    try {\n      return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');\n    } catch (e) { }\n  }\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"698d\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODZlMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanM/NzY2NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBicm93c2VyIHNoaW0gZm9yIHhtbGh0dHByZXF1ZXN0IG1vZHVsZVxuXG52YXIgaGFzQ09SUyA9IHJlcXVpcmUoJ2hhcy1jb3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHhkb21haW4gPSBvcHRzLnhkb21haW47XG5cbiAgLy8gc2NoZW1lIG11c3QgYmUgc2FtZSB3aGVuIHVzaWduIFhEb21haW5SZXF1ZXN0XG4gIC8vIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llaW50ZXJuYWxzL2FyY2hpdmUvMjAxMC8wNS8xMy94ZG9tYWlucmVxdWVzdC1yZXN0cmljdGlvbnMtbGltaXRhdGlvbnMtYW5kLXdvcmthcm91bmRzLmFzcHhcbiAgdmFyIHhzY2hlbWUgPSBvcHRzLnhzY2hlbWU7XG5cbiAgLy8gWERvbWFpblJlcXVlc3QgaGFzIGEgZmxvdyBvZiBub3Qgc2VuZGluZyBjb29raWUsIHRoZXJlZm9yZSBpdCBzaG91bGQgYmUgZGlzYWJsZWQgYXMgYSBkZWZhdWx0LlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9lbmdpbmUuaW8tY2xpZW50L3B1bGwvMjE3XG4gIHZhciBlbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICYmICgheGRvbWFpbiB8fCBoYXNDT1JTKSkge1xuICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgLy8gVXNlIFhEb21haW5SZXF1ZXN0IGZvciBJRTggaWYgZW5hYmxlc1hEUiBpcyB0cnVlXG4gIC8vIGJlY2F1c2UgbG9hZGluZyBiYXIga2VlcHMgZmxhc2hpbmcgd2hlbiB1c2luZyBqc29ucC1wb2xsaW5nXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95dWppb3Nha2Evc29ja2UuaW8taWU4LWxvYWRpbmctZXhhbXBsZVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICYmICF4c2NoZW1lICYmIGVuYWJsZXNYRFIpIHtcbiAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIGlmICgheGRvbWFpbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IGdsb2JhbFtbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoIChlKSB7IH1cbiAgfVxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///86e3\n")},9083:function(module,exports,__webpack_require__){eval("/**\n * A `Group` represents a value a `Facet` can take using a partitioning.\n * For continuous or time facets, it represents an interval.\n * For categorial facets, it is a single label.\n *\n * The `Facet.groups` collection is used for plotting, to deterime the postion along the axis.\n * Selections can be updated using a `Group`.\n *\n * @extends Base\n * @class Group\n */\nvar Base = __webpack_require__(/*! ../util/base */ \"3902\");\nvar moment = __webpack_require__(/*! moment */ \"da01\");\n\nmodule.exports = Base.extend({\n  dataTypes: {\n    'numberDatetimeOrDuration': {\n      set: function (value) {\n        var newValue;\n\n        // check for momentjs objects\n        if (moment.isDuration(value)) {\n          return {\n            val: moment.duration(value),\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n        if (moment.isMoment(value)) {\n          return {\n            val: moment(value),\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n\n        // try to create momentjs objects\n        newValue = moment(value, moment.ISO_8601);\n        if (newValue.isValid()) {\n          return {\n            val: newValue,\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n        if (typeof value === 'string' && value[0].toLowerCase() === 'p') {\n          newValue = moment.duration(value);\n          return {\n            val: newValue,\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n\n        // try to set a number\n        if (value === +value) {\n          return {\n            val: +value,\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n\n        // failed..\n        return {\n          val: value,\n          type: typeof value\n        };\n      },\n      compare: function (currentVal, newVal) {\n        if (currentVal instanceof moment) {\n          return currentVal.isSame(newVal);\n        } else {\n          return +currentVal === +newVal;\n        }\n      }\n    }\n  },\n  props: {\n    /**\n     * For continuous, datetime, or duration facets. Lower limit of interval\n     * @type {number|moment}\n     * @memberof! Group\n     */\n    min: 'numberDatetimeOrDuration',\n\n    /**\n     * For continuous, datetime, or duration facets. Upper limit of interval\n     * @type {number|moment}\n     * @memberof! Group\n     */\n    max: 'numberDatetimeOrDuration',\n\n    /**\n     * Number of times this transform is used\n     * @type {number}\n     * @memberof! Group\n     */\n    count: ['number', true, 0],\n\n    /**\n     * Label for display\n     * @type {string}\n     * @memberof! Group\n     */\n    label: ['string', true, 'label'],\n\n    /**\n     * A value guaranteed to be in this group, used to check if this group is currently selected.\n     * moments and durations should be stored as moment.format() and duration.toISOString()\n     * @type {string|number}\n     * @memberof! Group\n     */\n    value: 'any',\n\n    /**\n     * Index, cached version of groups.models.indexOf(group)\n     * @type {number}\n     * @memberof! Group\n     */\n    groupIndex: 'number'\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTA4My5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvcGFydGl0aW9uL2dyb3VwLmpzPzEwNGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIGBHcm91cGAgcmVwcmVzZW50cyBhIHZhbHVlIGEgYEZhY2V0YCBjYW4gdGFrZSB1c2luZyBhIHBhcnRpdGlvbmluZy5cbiAqIEZvciBjb250aW51b3VzIG9yIHRpbWUgZmFjZXRzLCBpdCByZXByZXNlbnRzIGFuIGludGVydmFsLlxuICogRm9yIGNhdGVnb3JpYWwgZmFjZXRzLCBpdCBpcyBhIHNpbmdsZSBsYWJlbC5cbiAqXG4gKiBUaGUgYEZhY2V0Lmdyb3Vwc2AgY29sbGVjdGlvbiBpcyB1c2VkIGZvciBwbG90dGluZywgdG8gZGV0ZXJpbWUgdGhlIHBvc3Rpb24gYWxvbmcgdGhlIGF4aXMuXG4gKiBTZWxlY3Rpb25zIGNhbiBiZSB1cGRhdGVkIHVzaW5nIGEgYEdyb3VwYC5cbiAqXG4gKiBAZXh0ZW5kcyBCYXNlXG4gKiBAY2xhc3MgR3JvdXBcbiAqL1xudmFyIEJhc2UgPSByZXF1aXJlKCcuLi91dGlsL2Jhc2UnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlLmV4dGVuZCh7XG4gIGRhdGFUeXBlczoge1xuICAgICdudW1iZXJEYXRldGltZU9yRHVyYXRpb24nOiB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbmV3VmFsdWU7XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIG1vbWVudGpzIG9iamVjdHNcbiAgICAgICAgaWYgKG1vbWVudC5pc0R1cmF0aW9uKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWw6IG1vbWVudC5kdXJhdGlvbih2YWx1ZSksXG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyRGF0ZXRpbWVPckR1cmF0aW9uJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vbWVudC5pc01vbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsOiBtb21lbnQodmFsdWUpLFxuICAgICAgICAgICAgdHlwZTogJ251bWJlckRhdGV0aW1lT3JEdXJhdGlvbidcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIGNyZWF0ZSBtb21lbnRqcyBvYmplY3RzXG4gICAgICAgIG5ld1ZhbHVlID0gbW9tZW50KHZhbHVlLCBtb21lbnQuSVNPXzg2MDEpO1xuICAgICAgICBpZiAobmV3VmFsdWUuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbDogbmV3VmFsdWUsXG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyRGF0ZXRpbWVPckR1cmF0aW9uJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWVbMF0udG9Mb3dlckNhc2UoKSA9PT0gJ3AnKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBtb21lbnQuZHVyYXRpb24odmFsdWUpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWw6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgdHlwZTogJ251bWJlckRhdGV0aW1lT3JEdXJhdGlvbidcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIHNldCBhIG51bWJlclxuICAgICAgICBpZiAodmFsdWUgPT09ICt2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWw6ICt2YWx1ZSxcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXJEYXRldGltZU9yRHVyYXRpb24nXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZhaWxlZC4uXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsOiB2YWx1ZSxcbiAgICAgICAgICB0eXBlOiB0eXBlb2YgdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbiAoY3VycmVudFZhbCwgbmV3VmFsKSB7XG4gICAgICAgIGlmIChjdXJyZW50VmFsIGluc3RhbmNlb2YgbW9tZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWwuaXNTYW1lKG5ld1ZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICtjdXJyZW50VmFsID09PSArbmV3VmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwcm9wczoge1xuICAgIC8qKlxuICAgICAqIEZvciBjb250aW51b3VzLCBkYXRldGltZSwgb3IgZHVyYXRpb24gZmFjZXRzLiBMb3dlciBsaW1pdCBvZiBpbnRlcnZhbFxuICAgICAqIEB0eXBlIHtudW1iZXJ8bW9tZW50fVxuICAgICAqIEBtZW1iZXJvZiEgR3JvdXBcbiAgICAgKi9cbiAgICBtaW46ICdudW1iZXJEYXRldGltZU9yRHVyYXRpb24nLFxuXG4gICAgLyoqXG4gICAgICogRm9yIGNvbnRpbnVvdXMsIGRhdGV0aW1lLCBvciBkdXJhdGlvbiBmYWNldHMuIFVwcGVyIGxpbWl0IG9mIGludGVydmFsXG4gICAgICogQHR5cGUge251bWJlcnxtb21lbnR9XG4gICAgICogQG1lbWJlcm9mISBHcm91cFxuICAgICAqL1xuICAgIG1heDogJ251bWJlckRhdGV0aW1lT3JEdXJhdGlvbicsXG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgdGltZXMgdGhpcyB0cmFuc2Zvcm0gaXMgdXNlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mISBHcm91cFxuICAgICAqL1xuICAgIGNvdW50OiBbJ251bWJlcicsIHRydWUsIDBdLFxuXG4gICAgLyoqXG4gICAgICogTGFiZWwgZm9yIGRpc3BsYXlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJvZiEgR3JvdXBcbiAgICAgKi9cbiAgICBsYWJlbDogWydzdHJpbmcnLCB0cnVlLCAnbGFiZWwnXSxcblxuICAgIC8qKlxuICAgICAqIEEgdmFsdWUgZ3VhcmFudGVlZCB0byBiZSBpbiB0aGlzIGdyb3VwLCB1c2VkIHRvIGNoZWNrIGlmIHRoaXMgZ3JvdXAgaXMgY3VycmVudGx5IHNlbGVjdGVkLlxuICAgICAqIG1vbWVudHMgYW5kIGR1cmF0aW9ucyBzaG91bGQgYmUgc3RvcmVkIGFzIG1vbWVudC5mb3JtYXQoKSBhbmQgZHVyYXRpb24udG9JU09TdHJpbmcoKVxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiEgR3JvdXBcbiAgICAgKi9cbiAgICB2YWx1ZTogJ2FueScsXG5cbiAgICAvKipcbiAgICAgKiBJbmRleCwgY2FjaGVkIHZlcnNpb24gb2YgZ3JvdXBzLm1vZGVscy5pbmRleE9mKGdyb3VwKVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mISBHcm91cFxuICAgICAqL1xuICAgIGdyb3VwSW5kZXg6ICdudW1iZXInXG4gIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9083\n")},"939f":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Create a blob builder even when vendor prefixes exist\n */\n\nvar BlobBuilder = global.BlobBuilder\n  || global.WebKitBlobBuilder\n  || global.MSBlobBuilder\n  || global.MozBlobBuilder;\n\n/**\n * Check if Blob constructor is supported\n */\n\nvar blobSupported = (function() {\n  try {\n    var a = new Blob(['hi']);\n    return a.size === 2;\n  } catch(e) {\n    return false;\n  }\n})();\n\n/**\n * Check if Blob constructor supports ArrayBufferViews\n * Fails in Safari 6, so we need to map to ArrayBuffers there.\n */\n\nvar blobSupportsArrayBufferView = blobSupported && (function() {\n  try {\n    var b = new Blob([new Uint8Array([1,2])]);\n    return b.size === 2;\n  } catch(e) {\n    return false;\n  }\n})();\n\n/**\n * Check if BlobBuilder is supported\n */\n\nvar blobBuilderSupported = BlobBuilder\n  && BlobBuilder.prototype.append\n  && BlobBuilder.prototype.getBlob;\n\n/**\n * Helper function that maps ArrayBufferViews to ArrayBuffers\n * Used by BlobBuilder constructor and old browsers that didn't\n * support it in the Blob constructor.\n */\n\nfunction mapArrayBufferViews(ary) {\n  for (var i = 0; i < ary.length; i++) {\n    var chunk = ary[i];\n    if (chunk.buffer instanceof ArrayBuffer) {\n      var buf = chunk.buffer;\n\n      // if this is a subarray, make a copy so we only\n      // include the subarray region from the underlying buffer\n      if (chunk.byteLength !== buf.byteLength) {\n        var copy = new Uint8Array(chunk.byteLength);\n        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));\n        buf = copy.buffer;\n      }\n\n      ary[i] = buf;\n    }\n  }\n}\n\nfunction BlobBuilderConstructor(ary, options) {\n  options = options || {};\n\n  var bb = new BlobBuilder();\n  mapArrayBufferViews(ary);\n\n  for (var i = 0; i < ary.length; i++) {\n    bb.append(ary[i]);\n  }\n\n  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();\n};\n\nfunction BlobConstructor(ary, options) {\n  mapArrayBufferViews(ary);\n  return new Blob(ary, options || {});\n};\n\nmodule.exports = (function() {\n  if (blobSupported) {\n    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;\n  } else if (blobBuilderSupported) {\n    return BlobBuilderConstructor;\n  } else {\n    return undefined;\n  }\n})();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"698d\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTM5Zi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvYmxvYi9pbmRleC5qcz8yMTA3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYkJ1aWxkZXIgPSBnbG9iYWwuQmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLldlYktpdEJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5NU0Jsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5Nb3pCbG9iQnVpbGRlcjtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iU3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBhID0gbmV3IEJsb2IoWydoaSddKTtcbiAgICByZXR1cm4gYS5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBzdXBwb3J0cyBBcnJheUJ1ZmZlclZpZXdzXG4gKiBGYWlscyBpbiBTYWZhcmkgNiwgc28gd2UgbmVlZCB0byBtYXAgdG8gQXJyYXlCdWZmZXJzIHRoZXJlLlxuICovXG5cbnZhciBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPSBibG9iU3VwcG9ydGVkICYmIChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShbMSwyXSldKTtcbiAgICByZXR1cm4gYi5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXG4gKi9cblxudmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZFxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuZ2V0QmxvYjtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBtYXBzIEFycmF5QnVmZmVyVmlld3MgdG8gQXJyYXlCdWZmZXJzXG4gKiBVc2VkIGJ5IEJsb2JCdWlsZGVyIGNvbnN0cnVjdG9yIGFuZCBvbGQgYnJvd3NlcnMgdGhhdCBkaWRuJ3RcbiAqIHN1cHBvcnQgaXQgaW4gdGhlIEJsb2IgY29uc3RydWN0b3IuXG4gKi9cblxuZnVuY3Rpb24gbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2h1bmsgPSBhcnlbaV07XG4gICAgaWYgKGNodW5rLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgYnVmID0gY2h1bmsuYnVmZmVyO1xuXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgc3ViYXJyYXksIG1ha2UgYSBjb3B5IHNvIHdlIG9ubHlcbiAgICAgIC8vIGluY2x1ZGUgdGhlIHN1YmFycmF5IHJlZ2lvbiBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlclxuICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggIT09IGJ1Zi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvcHkuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZiwgY2h1bmsuYnl0ZU9mZnNldCwgY2h1bmsuYnl0ZUxlbmd0aCkpO1xuICAgICAgICBidWYgPSBjb3B5LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgYXJ5W2ldID0gYnVmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYmIuYXBwZW5kKGFyeVtpXSk7XG4gIH1cblxuICByZXR1cm4gKG9wdGlvbnMudHlwZSkgPyBiYi5nZXRCbG9iKG9wdGlvbnMudHlwZSkgOiBiYi5nZXRCbG9iKCk7XG59O1xuXG5mdW5jdGlvbiBCbG9iQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcbiAgcmV0dXJuIG5ldyBCbG9iKGFyeSwgb3B0aW9ucyB8fCB7fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgaWYgKGJsb2JTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID8gZ2xvYmFsLkJsb2IgOiBCbG9iQ29uc3RydWN0b3I7XG4gIH0gZWxzZSBpZiAoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59KSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///939f\n")},9476:function(module,exports,__webpack_require__){eval("/**\n * A filter provides a chart with an interface to the data.\n * The filter contains a number of `Partition`s and `Aggregate`s.\n * It takes care of calling the relevant functions provided by a `Dataset`.\n *\n * @class Filter\n * @extends Base\n */\n\n/**\n * @typedef {Object} DataRecord - Object holding the plot data, partitions are labelled with a single small letter, aggregates with a double small letter\n * @property {string} DataRecord.a Value of first partition\n * @property {string} DataRecord.b Value of second partition\n * @property {string} DataRecord.c Value of third partition, etc.\n * @property {string} DataRecord.aa Value of first aggregate\n * @property {string} DataRecord.bb Value of second aggregate, etc.\n */\n\n/**\n * @typedef {DataRecord[]} Data - Array of DataRecords\n */\n\nvar Base = __webpack_require__(/*! ./util/base */ \"3902\");\nvar Aggregates = __webpack_require__(/*! ./aggregate/collection */ \"fbef\");\nvar Partitions = __webpack_require__(/*! ./partition/collection */ \"e59a\");\n\nmodule.exports = Base.extend({\n  props: {\n    /**\n     * Hint for the client (website) how to visualize this filter\n     * @memberof! Filter\n     * @type {string}\n     */\n    chartType: {\n      type: 'string',\n      required: true,\n      default: 'barchart',\n      values: ['piechart', 'horizontalbarchart', 'barchart', 'linechart', 'radarchart', 'polarareachart', 'bubbleplot', 'scatterchart', 'networkchart']\n    },\n    /**\n     * Title for displaying purposes\n     * @memberof! Filter\n     * @type {string}\n     */\n    title: ['string', true, ''],\n    /**\n     * Hint for the client (website) how to position the chart for this filter\n     * position (col, row) and size (size_x, size_y) of chart\n     */\n    col: 'number',\n    row: 'number',\n    size_x: 'number',\n    size_y: 'number'\n  },\n  collections: {\n    /**\n     * @memberof! Filter\n     * @type {Partitions[]}\n     */\n    partitions: Partitions,\n    /**\n     * @memberof! Filter\n     * @type {Aggregate[]}\n     */\n    aggregates: Aggregates\n  },\n  // Session properties are not typically persisted to the server,\n  // and are not returned by calls to toJSON() or serialize().\n  session: {\n    /**\n     * Array containing the data to plot\n     * @memberof! Filter\n     * @type {Data}\n     */\n    data: {\n      type: 'array',\n      default: function () {\n        return [];\n      }\n    },\n    /*\n     * Call this function to request new data.\n     * The dataset backing the facet will copy the data to Filter.data.\n     * A newData event is fired when the data is ready to be plotted.\n     *\n     * @function\n     * @virtual\n     * @private\n     * @memberof! Filter\n     * @emits newData\n     */\n    getData: {\n      type: 'any'\n    },\n    /**\n     * A history of the current drill-down (ie. partitions.toJSON())\n     */\n    zoomHistory: {\n      type: 'array',\n      default: function () {\n        return [];\n      }\n    },\n    /**\n     * Boolean indicating if the filter is initialized\n     */\n    isInitialized: {\n      type: 'boolean',\n      required: true,\n      default: false\n    }\n  },\n  initialize: function () {\n    // set up callback to free internal state on remove\n    this.on('remove', function () {\n      this.releaseDataFilter();\n    });\n  },\n  zoomIn: function () {\n    this.releaseDataFilter();\n\n    // save current state\n    this.zoomHistory.push(JSON.stringify(this.partitions.toJSON()));\n\n    this.partitions.forEach(function (partition) {\n      if ((partition.selected.length === 2) && (partition.isDatetime || partition.isContinuous)) {\n        if (partition.groupFixedS || partition.groupFixedSC) {\n          // scale down binsize\n          var newSize = partition.selected[1] - partition.selected[0];\n          var oldSize = partition.maxval - partition.minval;\n          partition.groupingParam = partition.groupingParam * newSize / oldSize;\n        }\n        // zoom to selected range, if possible\n        partition.set({\n          minval: partition.selected[0],\n          maxval: partition.selected[1]\n        });\n      } else if (partition.selected.length > 0 && (partition.isCategorial)) {\n        // zoom to selected categories, if possible\n        partition.groups.reset();\n        partition.selected.forEach(function (value) {\n          partition.groups.add({\n            value: value,\n            label: value,\n            count: 0,\n            isSelected: true\n          });\n        });\n      }\n      // select all\n      partition.updateSelection();\n    });\n    this.initDataFilter();\n    this.updateDataFilter(); // also triggers a getAllData()\n  },\n  zoomOut: function () {\n    var doReset = true;\n\n    // clear current selection\n    this.partitions.forEach(function (partition) {\n      if (partition.selected.length > 0) {\n        partition.updateSelection();\n        doReset = false;\n      }\n    });\n\n    if (doReset) {\n      this.releaseDataFilter();\n      if (this.zoomHistory.length > 0) {\n        // nothing was selected and we have drilled down: go up\n        var state = JSON.parse(this.zoomHistory.pop());\n        this.partitions.reset(state);\n      } else {\n        // nothing was selected and no drill down: reset partitioning\n        this.partitions.forEach(function (partition) {\n          if (partition.isDatetime || partition.isContinuous) {\n            partition.reset();\n          }\n        });\n      }\n      this.initDataFilter();\n    }\n    this.updateDataFilter(); // also triggers a getAllData()\n  },\n  // Apply the separate filterFunctions from each partition in a single function\n  filterFunction: function () {\n    var fs = [];\n    this.partitions.forEach(function (partition) {\n      fs.push(partition.filterFunction());\n    });\n    return function (d) {\n      if (typeof d === 'string') {\n        var groups = d.split('|');\n        return fs.every(function (f, i) { return f(groups[i]); });\n      } else {\n        // shortcut for non-partitioned numeric data\n        return fs[0](d);\n      }\n    };\n  },\n  /**\n   * Initialize the data filter, and construct the getData callback function on the filter.\n   *\n   * @memberof! Filter\n   */\n  initDataFilter: function () {\n    var dataview = this.collection.parent;\n    var spot = dataview.parent;\n\n    spot.driver.releaseDataFilter(dataview, this);\n    spot.driver.initDataFilter(dataview, this);\n    spot.driver.updateDataFilter(this);\n\n    this.isInitialized = true;\n  },\n  /**\n   * The opposite or initDataFilter, it should remove the filter and deallocate other configuration\n   * related to the filter.\n   *\n   * @memberof! Filter\n   */\n  releaseDataFilter: function () {\n    var dataview = this.collection.parent;\n    var spot = dataview.parent;\n\n    spot.driver.releaseDataFilter(dataview, this);\n\n    this.isInitialized = false;\n  },\n  /**\n   * Apply changes to the filter (like selecting groups)\n   *\n   * @memberof! Filter\n   */\n  updateDataFilter: function () {\n    var dataview = this.collection.parent;\n    var spot = dataview.parent;\n\n    spot.driver.updateDataFilter(this);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQ3Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmlsdGVyLmpzPzM4ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIGZpbHRlciBwcm92aWRlcyBhIGNoYXJ0IHdpdGggYW4gaW50ZXJmYWNlIHRvIHRoZSBkYXRhLlxuICogVGhlIGZpbHRlciBjb250YWlucyBhIG51bWJlciBvZiBgUGFydGl0aW9uYHMgYW5kIGBBZ2dyZWdhdGVgcy5cbiAqIEl0IHRha2VzIGNhcmUgb2YgY2FsbGluZyB0aGUgcmVsZXZhbnQgZnVuY3Rpb25zIHByb3ZpZGVkIGJ5IGEgYERhdGFzZXRgLlxuICpcbiAqIEBjbGFzcyBGaWx0ZXJcbiAqIEBleHRlbmRzIEJhc2VcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERhdGFSZWNvcmQgLSBPYmplY3QgaG9sZGluZyB0aGUgcGxvdCBkYXRhLCBwYXJ0aXRpb25zIGFyZSBsYWJlbGxlZCB3aXRoIGEgc2luZ2xlIHNtYWxsIGxldHRlciwgYWdncmVnYXRlcyB3aXRoIGEgZG91YmxlIHNtYWxsIGxldHRlclxuICogQHByb3BlcnR5IHtzdHJpbmd9IERhdGFSZWNvcmQuYSBWYWx1ZSBvZiBmaXJzdCBwYXJ0aXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBEYXRhUmVjb3JkLmIgVmFsdWUgb2Ygc2Vjb25kIHBhcnRpdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IERhdGFSZWNvcmQuYyBWYWx1ZSBvZiB0aGlyZCBwYXJ0aXRpb24sIGV0Yy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBEYXRhUmVjb3JkLmFhIFZhbHVlIG9mIGZpcnN0IGFnZ3JlZ2F0ZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IERhdGFSZWNvcmQuYmIgVmFsdWUgb2Ygc2Vjb25kIGFnZ3JlZ2F0ZSwgZXRjLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0RhdGFSZWNvcmRbXX0gRGF0YSAtIEFycmF5IG9mIERhdGFSZWNvcmRzXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL3V0aWwvYmFzZScpO1xudmFyIEFnZ3JlZ2F0ZXMgPSByZXF1aXJlKCcuL2FnZ3JlZ2F0ZS9jb2xsZWN0aW9uJyk7XG52YXIgUGFydGl0aW9ucyA9IHJlcXVpcmUoJy4vcGFydGl0aW9uL2NvbGxlY3Rpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlLmV4dGVuZCh7XG4gIHByb3BzOiB7XG4gICAgLyoqXG4gICAgICogSGludCBmb3IgdGhlIGNsaWVudCAod2Vic2l0ZSkgaG93IHRvIHZpc3VhbGl6ZSB0aGlzIGZpbHRlclxuICAgICAqIEBtZW1iZXJvZiEgRmlsdGVyXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBjaGFydFR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiAnYmFyY2hhcnQnLFxuICAgICAgdmFsdWVzOiBbJ3BpZWNoYXJ0JywgJ2hvcml6b250YWxiYXJjaGFydCcsICdiYXJjaGFydCcsICdsaW5lY2hhcnQnLCAncmFkYXJjaGFydCcsICdwb2xhcmFyZWFjaGFydCcsICdidWJibGVwbG90JywgJ3NjYXR0ZXJjaGFydCcsICduZXR3b3JrY2hhcnQnXVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGl0bGUgZm9yIGRpc3BsYXlpbmcgcHVycG9zZXNcbiAgICAgKiBAbWVtYmVyb2YhIEZpbHRlclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGl0bGU6IFsnc3RyaW5nJywgdHJ1ZSwgJyddLFxuICAgIC8qKlxuICAgICAqIEhpbnQgZm9yIHRoZSBjbGllbnQgKHdlYnNpdGUpIGhvdyB0byBwb3NpdGlvbiB0aGUgY2hhcnQgZm9yIHRoaXMgZmlsdGVyXG4gICAgICogcG9zaXRpb24gKGNvbCwgcm93KSBhbmQgc2l6ZSAoc2l6ZV94LCBzaXplX3kpIG9mIGNoYXJ0XG4gICAgICovXG4gICAgY29sOiAnbnVtYmVyJyxcbiAgICByb3c6ICdudW1iZXInLFxuICAgIHNpemVfeDogJ251bWJlcicsXG4gICAgc2l6ZV95OiAnbnVtYmVyJ1xuICB9LFxuICBjb2xsZWN0aW9uczoge1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiEgRmlsdGVyXG4gICAgICogQHR5cGUge1BhcnRpdGlvbnNbXX1cbiAgICAgKi9cbiAgICBwYXJ0aXRpb25zOiBQYXJ0aXRpb25zLFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiEgRmlsdGVyXG4gICAgICogQHR5cGUge0FnZ3JlZ2F0ZVtdfVxuICAgICAqL1xuICAgIGFnZ3JlZ2F0ZXM6IEFnZ3JlZ2F0ZXNcbiAgfSxcbiAgLy8gU2Vzc2lvbiBwcm9wZXJ0aWVzIGFyZSBub3QgdHlwaWNhbGx5IHBlcnNpc3RlZCB0byB0aGUgc2VydmVyLFxuICAvLyBhbmQgYXJlIG5vdCByZXR1cm5lZCBieSBjYWxscyB0byB0b0pTT04oKSBvciBzZXJpYWxpemUoKS5cbiAgc2Vzc2lvbjoge1xuICAgIC8qKlxuICAgICAqIEFycmF5IGNvbnRhaW5pbmcgdGhlIGRhdGEgdG8gcGxvdFxuICAgICAqIEBtZW1iZXJvZiEgRmlsdGVyXG4gICAgICogQHR5cGUge0RhdGF9XG4gICAgICovXG4gICAgZGF0YToge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG4gICAgLypcbiAgICAgKiBDYWxsIHRoaXMgZnVuY3Rpb24gdG8gcmVxdWVzdCBuZXcgZGF0YS5cbiAgICAgKiBUaGUgZGF0YXNldCBiYWNraW5nIHRoZSBmYWNldCB3aWxsIGNvcHkgdGhlIGRhdGEgdG8gRmlsdGVyLmRhdGEuXG4gICAgICogQSBuZXdEYXRhIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIGRhdGEgaXMgcmVhZHkgdG8gYmUgcGxvdHRlZC5cbiAgICAgKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyb2YhIEZpbHRlclxuICAgICAqIEBlbWl0cyBuZXdEYXRhXG4gICAgICovXG4gICAgZ2V0RGF0YToge1xuICAgICAgdHlwZTogJ2FueSdcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEEgaGlzdG9yeSBvZiB0aGUgY3VycmVudCBkcmlsbC1kb3duIChpZS4gcGFydGl0aW9ucy50b0pTT04oKSlcbiAgICAgKi9cbiAgICB6b29tSGlzdG9yeToge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBmaWx0ZXIgaXMgaW5pdGlhbGl6ZWRcbiAgICAgKi9cbiAgICBpc0luaXRpYWxpemVkOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LFxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc2V0IHVwIGNhbGxiYWNrIHRvIGZyZWUgaW50ZXJuYWwgc3RhdGUgb24gcmVtb3ZlXG4gICAgdGhpcy5vbigncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5yZWxlYXNlRGF0YUZpbHRlcigpO1xuICAgIH0pO1xuICB9LFxuICB6b29tSW46IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlbGVhc2VEYXRhRmlsdGVyKCk7XG5cbiAgICAvLyBzYXZlIGN1cnJlbnQgc3RhdGVcbiAgICB0aGlzLnpvb21IaXN0b3J5LnB1c2goSlNPTi5zdHJpbmdpZnkodGhpcy5wYXJ0aXRpb25zLnRvSlNPTigpKSk7XG5cbiAgICB0aGlzLnBhcnRpdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocGFydGl0aW9uKSB7XG4gICAgICBpZiAoKHBhcnRpdGlvbi5zZWxlY3RlZC5sZW5ndGggPT09IDIpICYmIChwYXJ0aXRpb24uaXNEYXRldGltZSB8fCBwYXJ0aXRpb24uaXNDb250aW51b3VzKSkge1xuICAgICAgICBpZiAocGFydGl0aW9uLmdyb3VwRml4ZWRTIHx8IHBhcnRpdGlvbi5ncm91cEZpeGVkU0MpIHtcbiAgICAgICAgICAvLyBzY2FsZSBkb3duIGJpbnNpemVcbiAgICAgICAgICB2YXIgbmV3U2l6ZSA9IHBhcnRpdGlvbi5zZWxlY3RlZFsxXSAtIHBhcnRpdGlvbi5zZWxlY3RlZFswXTtcbiAgICAgICAgICB2YXIgb2xkU2l6ZSA9IHBhcnRpdGlvbi5tYXh2YWwgLSBwYXJ0aXRpb24ubWludmFsO1xuICAgICAgICAgIHBhcnRpdGlvbi5ncm91cGluZ1BhcmFtID0gcGFydGl0aW9uLmdyb3VwaW5nUGFyYW0gKiBuZXdTaXplIC8gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB6b29tIHRvIHNlbGVjdGVkIHJhbmdlLCBpZiBwb3NzaWJsZVxuICAgICAgICBwYXJ0aXRpb24uc2V0KHtcbiAgICAgICAgICBtaW52YWw6IHBhcnRpdGlvbi5zZWxlY3RlZFswXSxcbiAgICAgICAgICBtYXh2YWw6IHBhcnRpdGlvbi5zZWxlY3RlZFsxXVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAocGFydGl0aW9uLnNlbGVjdGVkLmxlbmd0aCA+IDAgJiYgKHBhcnRpdGlvbi5pc0NhdGVnb3JpYWwpKSB7XG4gICAgICAgIC8vIHpvb20gdG8gc2VsZWN0ZWQgY2F0ZWdvcmllcywgaWYgcG9zc2libGVcbiAgICAgICAgcGFydGl0aW9uLmdyb3Vwcy5yZXNldCgpO1xuICAgICAgICBwYXJ0aXRpb24uc2VsZWN0ZWQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBwYXJ0aXRpb24uZ3JvdXBzLmFkZCh7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBsYWJlbDogdmFsdWUsXG4gICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBzZWxlY3QgYWxsXG4gICAgICBwYXJ0aXRpb24udXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgfSk7XG4gICAgdGhpcy5pbml0RGF0YUZpbHRlcigpO1xuICAgIHRoaXMudXBkYXRlRGF0YUZpbHRlcigpOyAvLyBhbHNvIHRyaWdnZXJzIGEgZ2V0QWxsRGF0YSgpXG4gIH0sXG4gIHpvb21PdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZG9SZXNldCA9IHRydWU7XG5cbiAgICAvLyBjbGVhciBjdXJyZW50IHNlbGVjdGlvblxuICAgIHRoaXMucGFydGl0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0aXRpb24pIHtcbiAgICAgIGlmIChwYXJ0aXRpb24uc2VsZWN0ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXJ0aXRpb24udXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICAgIGRvUmVzZXQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChkb1Jlc2V0KSB7XG4gICAgICB0aGlzLnJlbGVhc2VEYXRhRmlsdGVyKCk7XG4gICAgICBpZiAodGhpcy56b29tSGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgd2FzIHNlbGVjdGVkIGFuZCB3ZSBoYXZlIGRyaWxsZWQgZG93bjogZ28gdXBcbiAgICAgICAgdmFyIHN0YXRlID0gSlNPTi5wYXJzZSh0aGlzLnpvb21IaXN0b3J5LnBvcCgpKTtcbiAgICAgICAgdGhpcy5wYXJ0aXRpb25zLnJlc2V0KHN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgd2FzIHNlbGVjdGVkIGFuZCBubyBkcmlsbCBkb3duOiByZXNldCBwYXJ0aXRpb25pbmdcbiAgICAgICAgdGhpcy5wYXJ0aXRpb25zLmZvckVhY2goZnVuY3Rpb24gKHBhcnRpdGlvbikge1xuICAgICAgICAgIGlmIChwYXJ0aXRpb24uaXNEYXRldGltZSB8fCBwYXJ0aXRpb24uaXNDb250aW51b3VzKSB7XG4gICAgICAgICAgICBwYXJ0aXRpb24ucmVzZXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5pbml0RGF0YUZpbHRlcigpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZURhdGFGaWx0ZXIoKTsgLy8gYWxzbyB0cmlnZ2VycyBhIGdldEFsbERhdGEoKVxuICB9LFxuICAvLyBBcHBseSB0aGUgc2VwYXJhdGUgZmlsdGVyRnVuY3Rpb25zIGZyb20gZWFjaCBwYXJ0aXRpb24gaW4gYSBzaW5nbGUgZnVuY3Rpb25cbiAgZmlsdGVyRnVuY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZnMgPSBbXTtcbiAgICB0aGlzLnBhcnRpdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocGFydGl0aW9uKSB7XG4gICAgICBmcy5wdXNoKHBhcnRpdGlvbi5maWx0ZXJGdW5jdGlvbigpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIGlmICh0eXBlb2YgZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGdyb3VwcyA9IGQuc3BsaXQoJ3wnKTtcbiAgICAgICAgcmV0dXJuIGZzLmV2ZXJ5KGZ1bmN0aW9uIChmLCBpKSB7IHJldHVybiBmKGdyb3Vwc1tpXSk7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2hvcnRjdXQgZm9yIG5vbi1wYXJ0aXRpb25lZCBudW1lcmljIGRhdGFcbiAgICAgICAgcmV0dXJuIGZzWzBdKGQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBkYXRhIGZpbHRlciwgYW5kIGNvbnN0cnVjdCB0aGUgZ2V0RGF0YSBjYWxsYmFjayBmdW5jdGlvbiBvbiB0aGUgZmlsdGVyLlxuICAgKlxuICAgKiBAbWVtYmVyb2YhIEZpbHRlclxuICAgKi9cbiAgaW5pdERhdGFGaWx0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YXZpZXcgPSB0aGlzLmNvbGxlY3Rpb24ucGFyZW50O1xuICAgIHZhciBzcG90ID0gZGF0YXZpZXcucGFyZW50O1xuXG4gICAgc3BvdC5kcml2ZXIucmVsZWFzZURhdGFGaWx0ZXIoZGF0YXZpZXcsIHRoaXMpO1xuICAgIHNwb3QuZHJpdmVyLmluaXREYXRhRmlsdGVyKGRhdGF2aWV3LCB0aGlzKTtcbiAgICBzcG90LmRyaXZlci51cGRhdGVEYXRhRmlsdGVyKHRoaXMpO1xuXG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBvcHBvc2l0ZSBvciBpbml0RGF0YUZpbHRlciwgaXQgc2hvdWxkIHJlbW92ZSB0aGUgZmlsdGVyIGFuZCBkZWFsbG9jYXRlIG90aGVyIGNvbmZpZ3VyYXRpb25cbiAgICogcmVsYXRlZCB0byB0aGUgZmlsdGVyLlxuICAgKlxuICAgKiBAbWVtYmVyb2YhIEZpbHRlclxuICAgKi9cbiAgcmVsZWFzZURhdGFGaWx0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YXZpZXcgPSB0aGlzLmNvbGxlY3Rpb24ucGFyZW50O1xuICAgIHZhciBzcG90ID0gZGF0YXZpZXcucGFyZW50O1xuXG4gICAgc3BvdC5kcml2ZXIucmVsZWFzZURhdGFGaWx0ZXIoZGF0YXZpZXcsIHRoaXMpO1xuXG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gIH0sXG4gIC8qKlxuICAgKiBBcHBseSBjaGFuZ2VzIHRvIHRoZSBmaWx0ZXIgKGxpa2Ugc2VsZWN0aW5nIGdyb3VwcylcbiAgICpcbiAgICogQG1lbWJlcm9mISBGaWx0ZXJcbiAgICovXG4gIHVwZGF0ZURhdGFGaWx0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YXZpZXcgPSB0aGlzLmNvbGxlY3Rpb24ucGFyZW50O1xuICAgIHZhciBzcG90ID0gZGF0YXZpZXcucGFyZW50O1xuXG4gICAgc3BvdC5kcml2ZXIudXBkYXRlRGF0YUZpbHRlcih0aGlzKTtcbiAgfVxufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9476\n")},"9b75":function(module,exports,__webpack_require__){eval("/**\n * CategorialTransfrom defines a transformation on categorial and textual data,\n * and is implemented as a collection of rules.\n *\n * @class CategorialTransform\n */\nvar Model = __webpack_require__(/*! ampersand-model */ \"3bfc\");\nvar Collection = __webpack_require__(/*! ampersand-collection */ \"7bd3\");\n\nvar Rule = __webpack_require__(/*! ./categorial-rule */ \"ba23\");\nvar Rules = Collection.extend({\n  indexes: ['expression'],\n  model: Rule\n});\n\n/**\n * Apply the first applicable transformation rule.\n * When no matching rule is found, return 'Other'\n *\n * @function\n * @memberof! CategorialTransform\n * @param {string} text\n * @returns {string} text The transformed text\n */\nfunction transform (rules, text) {\n  var i;\n  for (i = 0; i < rules.length; i++) {\n    var group = rules.models[i].match(text);\n    if (group) {\n      return group;\n    }\n  }\n  return 'Other';\n}\n\nmodule.exports = Model.extend({\n  props: {\n    transformedType: {\n      type: 'string',\n      required: true,\n      default: 'categorial',\n      values: ['categorial']\n    },\n    transformedMin: {\n      type: 'number',\n      required: true,\n      default: 0\n    },\n    transformedMax: {\n      type: 'number',\n      required: true,\n      default: 100\n    },\n    transformedMinAsText: {\n      type: 'string',\n      required: true,\n      default: '0'\n    },\n    transformedMaxAsText: {\n      type: 'string',\n      required: true,\n      default: '100'\n    }\n  },\n  collections: {\n    rules: Rules\n  },\n  transform: function (labels) {\n    if (!this.rules) {\n      return labels;\n    }\n    if (labels instanceof Array) {\n      labels.forEach(function (label, i) {\n        labels[i] = transform(this.rules, label);\n      }, this);\n    } else {\n      labels = transform(this.rules, labels);\n    }\n    return labels;\n  },\n  reset: function () {\n    this.rules.reset();\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOWI3NS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmFjZXQvY2F0ZWdvcmlhbC10cmFuc2Zvcm0uanM/MzBlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENhdGVnb3JpYWxUcmFuc2Zyb20gZGVmaW5lcyBhIHRyYW5zZm9ybWF0aW9uIG9uIGNhdGVnb3JpYWwgYW5kIHRleHR1YWwgZGF0YSxcbiAqIGFuZCBpcyBpbXBsZW1lbnRlZCBhcyBhIGNvbGxlY3Rpb24gb2YgcnVsZXMuXG4gKlxuICogQGNsYXNzIENhdGVnb3JpYWxUcmFuc2Zvcm1cbiAqL1xudmFyIE1vZGVsID0gcmVxdWlyZSgnYW1wZXJzYW5kLW1vZGVsJyk7XG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ2FtcGVyc2FuZC1jb2xsZWN0aW9uJyk7XG5cbnZhciBSdWxlID0gcmVxdWlyZSgnLi9jYXRlZ29yaWFsLXJ1bGUnKTtcbnZhciBSdWxlcyA9IENvbGxlY3Rpb24uZXh0ZW5kKHtcbiAgaW5kZXhlczogWydleHByZXNzaW9uJ10sXG4gIG1vZGVsOiBSdWxlXG59KTtcblxuLyoqXG4gKiBBcHBseSB0aGUgZmlyc3QgYXBwbGljYWJsZSB0cmFuc2Zvcm1hdGlvbiBydWxlLlxuICogV2hlbiBubyBtYXRjaGluZyBydWxlIGlzIGZvdW5kLCByZXR1cm4gJ090aGVyJ1xuICpcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mISBDYXRlZ29yaWFsVHJhbnNmb3JtXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHJldHVybnMge3N0cmluZ30gdGV4dCBUaGUgdHJhbnNmb3JtZWQgdGV4dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm0gKHJ1bGVzLCB0ZXh0KSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZ3JvdXAgPSBydWxlcy5tb2RlbHNbaV0ubWF0Y2godGV4dCk7XG4gICAgaWYgKGdyb3VwKSB7XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICB9XG4gIHJldHVybiAnT3RoZXInO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsLmV4dGVuZCh7XG4gIHByb3BzOiB7XG4gICAgdHJhbnNmb3JtZWRUeXBlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZGVmYXVsdDogJ2NhdGVnb3JpYWwnLFxuICAgICAgdmFsdWVzOiBbJ2NhdGVnb3JpYWwnXVxuICAgIH0sXG4gICAgdHJhbnNmb3JtZWRNaW46IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiAwXG4gICAgfSxcbiAgICB0cmFuc2Zvcm1lZE1heDoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6IDEwMFxuICAgIH0sXG4gICAgdHJhbnNmb3JtZWRNaW5Bc1RleHQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiAnMCdcbiAgICB9LFxuICAgIHRyYW5zZm9ybWVkTWF4QXNUZXh0OiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZGVmYXVsdDogJzEwMCdcbiAgICB9XG4gIH0sXG4gIGNvbGxlY3Rpb25zOiB7XG4gICAgcnVsZXM6IFJ1bGVzXG4gIH0sXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gKGxhYmVscykge1xuICAgIGlmICghdGhpcy5ydWxlcykge1xuICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9XG4gICAgaWYgKGxhYmVscyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBsYWJlbHMuZm9yRWFjaChmdW5jdGlvbiAobGFiZWwsIGkpIHtcbiAgICAgICAgbGFiZWxzW2ldID0gdHJhbnNmb3JtKHRoaXMucnVsZXMsIGxhYmVsKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYWJlbHMgPSB0cmFuc2Zvcm0odGhpcy5ydWxlcywgbGFiZWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVscztcbiAgfSxcbiAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJ1bGVzLnJlc2V0KCk7XG4gIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9b75\n")},"9d63":function(module,exports,__webpack_require__){eval("/**\n * The Aggregate class describes how to aggregate data, as described by a `Facet` into a single value.\n * For example, you can sum or average over numbers, or count the number of different labels.\n *\n * @class Aggregate\n * @extends Base\n */\nvar BaseModel = __webpack_require__(/*! ./util/base */ \"3902\");\n\nmodule.exports = BaseModel.extend({\n  props: {\n    /**\n     * The name of the facet to aggregate over\n     * @memberof! Aggregate\n     * @type {string}\n     */\n    facetName: 'string',\n\n    /**\n     * Label for displaying on plots\n     * @memberof! Aggregate\n     * @type {string}\n     */\n    label: {\n      type: 'string',\n      required: true,\n      default: ''\n    },\n\n    /**\n     * When part of a aggregates, this deterimines the ordering\n     * @memberof! Aggregate\n     * @type {number}\n     */\n    rank: {\n      type: 'number',\n      required: true\n    },\n\n    /**\n     * Operation:\n     *  * `count`  count the number of elements in the group\n     *  * `sum`    sum the elements in the group\n     *  * `avg`    take the average of the elements in the group\n     *  * `stddev`  take the sample\n     *  * `min`    minum value of the elements in the group\n     *  * `max`    maximum value of the elements in the group\n     * @memberof! Aggregate\n     * @type {string}\n     */\n    operation: {\n      type: 'string',\n      required: true,\n      default: 'avg',\n      values: ['count', 'avg', 'sum', 'stddev', 'min', 'max']\n    },\n    // NOTE: properties for reduction, should be a valid SQL aggregation function\n\n    /**\n     * Normalization: TODO\n     *  * `none`      data in same units as the original data\n     *  * `relative`  data is in percentages of the total; for subgroups in percentage of the parent group\n     * @memberof! Aggregate\n     * @type {string}\n     */\n    normalization: {\n      type: 'string',\n      required: true,\n      default: 'none',\n      values: ['none', 'percentage']\n    }\n  },\n  derived: {\n    // operation values\n    doSum: {\n      deps: ['operation'],\n      fn: function () {\n        return this.operation === 'sum';\n      }\n    },\n    doCount: {\n      deps: ['operation'],\n      fn: function () {\n        return this.operation === 'count';\n      }\n    },\n    doAverage: {\n      deps: ['operation'],\n      fn: function () {\n        return this.operation === 'avg';\n      }\n    },\n    doStddev: {\n      deps: ['operation'],\n      fn: function () {\n        return this.operation === 'stddev';\n      }\n    },\n    doMin: {\n      deps: ['operation'],\n      fn: function () {\n        return this.operation === 'min';\n      }\n    },\n    doMax: {\n      deps: ['operation'],\n      fn: function () {\n        return this.operation === 'max';\n      }\n    },\n\n    // normalization values\n    normalizeNone: {\n      deps: ['normalization'],\n      fn: function () {\n        return this.normalization === 'absolute';\n      }\n    },\n    normalizePercentage: {\n      deps: ['normalization'],\n      fn: function () {\n        return this.normalization === 'percentage';\n      }\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOWQ2My5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvYWdncmVnYXRlLmpzP2JkNmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGUgQWdncmVnYXRlIGNsYXNzIGRlc2NyaWJlcyBob3cgdG8gYWdncmVnYXRlIGRhdGEsIGFzIGRlc2NyaWJlZCBieSBhIGBGYWNldGAgaW50byBhIHNpbmdsZSB2YWx1ZS5cbiAqIEZvciBleGFtcGxlLCB5b3UgY2FuIHN1bSBvciBhdmVyYWdlIG92ZXIgbnVtYmVycywgb3IgY291bnQgdGhlIG51bWJlciBvZiBkaWZmZXJlbnQgbGFiZWxzLlxuICpcbiAqIEBjbGFzcyBBZ2dyZWdhdGVcbiAqIEBleHRlbmRzIEJhc2VcbiAqL1xudmFyIEJhc2VNb2RlbCA9IHJlcXVpcmUoJy4vdXRpbC9iYXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZU1vZGVsLmV4dGVuZCh7XG4gIHByb3BzOiB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZhY2V0IHRvIGFnZ3JlZ2F0ZSBvdmVyXG4gICAgICogQG1lbWJlcm9mISBBZ2dyZWdhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZhY2V0TmFtZTogJ3N0cmluZycsXG5cbiAgICAvKipcbiAgICAgKiBMYWJlbCBmb3IgZGlzcGxheWluZyBvbiBwbG90c1xuICAgICAqIEBtZW1iZXJvZiEgQWdncmVnYXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBsYWJlbDoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6ICcnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gcGFydCBvZiBhIGFnZ3JlZ2F0ZXMsIHRoaXMgZGV0ZXJpbWluZXMgdGhlIG9yZGVyaW5nXG4gICAgICogQG1lbWJlcm9mISBBZ2dyZWdhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHJhbms6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9uOlxuICAgICAqICAqIGBjb3VudGAgIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGdyb3VwXG4gICAgICogICogYHN1bWAgICAgc3VtIHRoZSBlbGVtZW50cyBpbiB0aGUgZ3JvdXBcbiAgICAgKiAgKiBgYXZnYCAgICB0YWtlIHRoZSBhdmVyYWdlIG9mIHRoZSBlbGVtZW50cyBpbiB0aGUgZ3JvdXBcbiAgICAgKiAgKiBgc3RkZGV2YCAgdGFrZSB0aGUgc2FtcGxlXG4gICAgICogICogYG1pbmAgICAgbWludW0gdmFsdWUgb2YgdGhlIGVsZW1lbnRzIGluIHRoZSBncm91cFxuICAgICAqICAqIGBtYXhgICAgIG1heGltdW0gdmFsdWUgb2YgdGhlIGVsZW1lbnRzIGluIHRoZSBncm91cFxuICAgICAqIEBtZW1iZXJvZiEgQWdncmVnYXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBvcGVyYXRpb246IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiAnYXZnJyxcbiAgICAgIHZhbHVlczogWydjb3VudCcsICdhdmcnLCAnc3VtJywgJ3N0ZGRldicsICdtaW4nLCAnbWF4J11cbiAgICB9LFxuICAgIC8vIE5PVEU6IHByb3BlcnRpZXMgZm9yIHJlZHVjdGlvbiwgc2hvdWxkIGJlIGEgdmFsaWQgU1FMIGFnZ3JlZ2F0aW9uIGZ1bmN0aW9uXG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemF0aW9uOiBUT0RPXG4gICAgICogICogYG5vbmVgICAgICAgZGF0YSBpbiBzYW1lIHVuaXRzIGFzIHRoZSBvcmlnaW5hbCBkYXRhXG4gICAgICogICogYHJlbGF0aXZlYCAgZGF0YSBpcyBpbiBwZXJjZW50YWdlcyBvZiB0aGUgdG90YWw7IGZvciBzdWJncm91cHMgaW4gcGVyY2VudGFnZSBvZiB0aGUgcGFyZW50IGdyb3VwXG4gICAgICogQG1lbWJlcm9mISBBZ2dyZWdhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIG5vcm1hbGl6YXRpb246IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiAnbm9uZScsXG4gICAgICB2YWx1ZXM6IFsnbm9uZScsICdwZXJjZW50YWdlJ11cbiAgICB9XG4gIH0sXG4gIGRlcml2ZWQ6IHtcbiAgICAvLyBvcGVyYXRpb24gdmFsdWVzXG4gICAgZG9TdW06IHtcbiAgICAgIGRlcHM6IFsnb3BlcmF0aW9uJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRpb24gPT09ICdzdW0nO1xuICAgICAgfVxuICAgIH0sXG4gICAgZG9Db3VudDoge1xuICAgICAgZGVwczogWydvcGVyYXRpb24nXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbiA9PT0gJ2NvdW50JztcbiAgICAgIH1cbiAgICB9LFxuICAgIGRvQXZlcmFnZToge1xuICAgICAgZGVwczogWydvcGVyYXRpb24nXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbiA9PT0gJ2F2Zyc7XG4gICAgICB9XG4gICAgfSxcbiAgICBkb1N0ZGRldjoge1xuICAgICAgZGVwczogWydvcGVyYXRpb24nXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbiA9PT0gJ3N0ZGRldic7XG4gICAgICB9XG4gICAgfSxcbiAgICBkb01pbjoge1xuICAgICAgZGVwczogWydvcGVyYXRpb24nXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbiA9PT0gJ21pbic7XG4gICAgICB9XG4gICAgfSxcbiAgICBkb01heDoge1xuICAgICAgZGVwczogWydvcGVyYXRpb24nXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbiA9PT0gJ21heCc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIG5vcm1hbGl6YXRpb24gdmFsdWVzXG4gICAgbm9ybWFsaXplTm9uZToge1xuICAgICAgZGVwczogWydub3JtYWxpemF0aW9uJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemF0aW9uID09PSAnYWJzb2x1dGUnO1xuICAgICAgfVxuICAgIH0sXG4gICAgbm9ybWFsaXplUGVyY2VudGFnZToge1xuICAgICAgZGVwczogWydub3JtYWxpemF0aW9uJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemF0aW9uID09PSAncGVyY2VudGFnZSc7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9d63\n")},a0ca:function(module,exports,__webpack_require__){eval("/**\n * DatetimeTransform defines a transformation on time or dates with timezones\n *\n * @class DatetimeTransform\n */\nvar AmpersandModel = __webpack_require__(/*! ampersand-model */ \"3bfc\");\nvar moment = __webpack_require__(/*! moment-timezone */ \"6c9d\");\nvar util = __webpack_require__(/*! ../util/time */ \"d45b\");\nvar misval = __webpack_require__(/*! ../util/misval */ \"bff6\");\n\nmodule.exports = AmpersandModel.extend({\n  props: {\n    /**\n     * Timezone to use when parsing, for when timezone information is absent or incorrect.\n     * @memberof! DatetimeTransform\n     * @type {string}\n     */\n    zone: ['string', true, 'ISO8601'],\n\n    /**\n     * Format indentifier to use when parsing, when not in ISO8601 format\n     * Mappings are defined in util/time.js => timeParts.description\n     * @memberof! DatetimeTransform\n     * @type {string}\n     */\n    format: ['string', true, 'ISO8601'],\n\n    /**\n     * Reformats to a string using the momentjs or postgreSQL format specifiers.\n     * This allows a transformation to day of the year, or day of week etc.\n     * @memberof! DatetimeTransform\n     * @type {string}\n     */\n    transformedFormat: ['string', true, 'ISO8601'],\n\n    /**\n     * Controls conversion to duration by subtracting this date\n     * @memberof! DatetimeTransform\n     * @type {string}\n     */\n    transformedReference: 'string',\n\n    /**\n     * Reference timezone for conversion from datetime to duration\n     * @memberof! DatetimeTransform\n     * @type {string}\n     */\n    transformedZone: ['string', true, 'ISO8601']\n\n  },\n  derived: {\n    // reference momentjs for duration <-> datetime conversion\n    referenceMoment: {\n      deps: ['transformedReference', 'transformedZone'],\n      fn: function () {\n        var tz;\n        if (this.transformedZone === 'ISO8601') {\n          tz = moment.tz.guess();\n        } else {\n          var timeZone = util.timeZones.get(this.transformedZone, 'description');\n          if (timeZone && timeZone.format) {\n            tz = timeZone.format;\n          } else {\n            tz = moment.tz.guess();\n          }\n        }\n        if (this.transformedReference) {\n          return moment.tz(this.transformedReference, tz);\n        }\n        return null;\n      }\n    },\n    /**\n     * The type of the facet after the transformation has been applied\n     * @memberof! DatetimeTransform\n     */\n    transformedType: {\n      deps: ['transformedFormat', 'transformedReference'],\n      fn: function () {\n        if (this.transformedReference) {\n          // datetime -> duration\n          return 'duration';\n        } else if (this.transformedFormat === 'ISO8601') {\n          // datetime -> datetime\n          return 'datetime';\n        } else {\n          // datetime -> time part\n          var timePart = util.timeParts.get(this.transformedFormat, 'description');\n          if (timePart && timePart.type) {\n            return timePart.type;\n          }\n        }\n        return 'datetime';\n      },\n      cache: false\n    },\n    /**\n     * The minium value this facet can take, after the transformation has been applied\n     * @type {number}\n     * @memberof! DatetimeTransform\n     */\n    transformedMin: {\n      deps: ['transformedType'],\n      fn: function () {\n        var timePart;\n        if (this.transformedType === 'datetime' || this.transformedType === 'duration') {\n          return this.transform(this.parent.minval);\n        }\n        timePart = util.timeParts.get(this.transformedFormat, 'description');\n        if (timePart.calcualte) {\n          return this.transform(this.parent.minval);\n        } else {\n          return timePart.min;\n        }\n      },\n      cache: false\n    },\n    /**\n     * The maximum value this facet can take, after the transformation has been applied\n     * @type {number}\n     * @memberof! DatetimeTransform\n     */\n    transformedMax: {\n      deps: ['transformedType'],\n      fn: function () {\n        var timePart;\n        if (this.transformedType === 'datetime' || this.transformedType === 'duration') {\n          return this.transform(this.parent.maxval);\n        }\n        timePart = util.timeParts.get(this.transformedFormat, 'description');\n        if (timePart.calcualte) {\n          return this.transform(this.parent.maxval);\n        } else {\n          return timePart.max;\n        }\n      },\n      cache: false\n    },\n    /**\n     * The minimum value this facet can take, after the transformation has been applied\n     *\n     * @type {string}\n     * @memberof! DatetimeTransform\n     */\n    transformedMinAsText: {\n      deps: ['transformedMin', 'transformedType'],\n      fn: function () {\n        var minval = this.transformedMin;\n        if (this.transformedType === 'datetime') {\n          return minval.format();\n        } else {\n          return minval.toString();\n        }\n      },\n      cache: false\n    },\n    /**\n     * The maximum value this facet can take, after the transformation has been applied\n     *\n     * @type {string}\n     * @memberof! DatetimeTransform\n     */\n    transformedMaxAsText: {\n      deps: ['transformedMax', 'transformedType'],\n      fn: function () {\n        var maxval = this.transformedMax;\n        if (this.transformedType === 'datetime') {\n          return maxval.format();\n        } else {\n          return maxval.toString();\n        }\n      },\n      cache: false\n    }\n  },\n\n  /**\n   * @function\n   * @memberof! DatetimeTransform\n   * @param {Object} momentjs\n   * @returns {Object} momentjs\n   */\n  transform: function transform (inval) {\n    if (typeof inval === 'undefined') {\n      return misval;\n    }\n\n    var d = inval.clone();\n    var timePart;\n\n    if (this.referenceMoment) {\n      // datetime -> duration\n      return moment.duration(d.diff(this.referenceMoment, 'milliseconds', true), 'milliseconds');\n    } else if (this.transformedFormat !== 'ISO8601') {\n      timePart = util.timeParts.get(this.transformedFormat, 'description');\n      if (timePart && timePart.momentFormat) {\n        return d.format(timePart.momentFormat);\n      }\n      return d;\n    } else {\n      return d;\n    }\n  },\n  reset: function () {\n    this.unset(['zone', 'transformedFormat', 'transformedZone', 'transformedReference']);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYTBjYS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmFjZXQvZGF0ZXRpbWUtdHJhbnNmb3JtLmpzPzM1YTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEYXRldGltZVRyYW5zZm9ybSBkZWZpbmVzIGEgdHJhbnNmb3JtYXRpb24gb24gdGltZSBvciBkYXRlcyB3aXRoIHRpbWV6b25lc1xuICpcbiAqIEBjbGFzcyBEYXRldGltZVRyYW5zZm9ybVxuICovXG52YXIgQW1wZXJzYW5kTW9kZWwgPSByZXF1aXJlKCdhbXBlcnNhbmQtbW9kZWwnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQtdGltZXpvbmUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC90aW1lJyk7XG52YXIgbWlzdmFsID0gcmVxdWlyZSgnLi4vdXRpbC9taXN2YWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbXBlcnNhbmRNb2RlbC5leHRlbmQoe1xuICBwcm9wczoge1xuICAgIC8qKlxuICAgICAqIFRpbWV6b25lIHRvIHVzZSB3aGVuIHBhcnNpbmcsIGZvciB3aGVuIHRpbWV6b25lIGluZm9ybWF0aW9uIGlzIGFic2VudCBvciBpbmNvcnJlY3QuXG4gICAgICogQG1lbWJlcm9mISBEYXRldGltZVRyYW5zZm9ybVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgem9uZTogWydzdHJpbmcnLCB0cnVlLCAnSVNPODYwMSddLFxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IGluZGVudGlmaWVyIHRvIHVzZSB3aGVuIHBhcnNpbmcsIHdoZW4gbm90IGluIElTTzg2MDEgZm9ybWF0XG4gICAgICogTWFwcGluZ3MgYXJlIGRlZmluZWQgaW4gdXRpbC90aW1lLmpzID0+IHRpbWVQYXJ0cy5kZXNjcmlwdGlvblxuICAgICAqIEBtZW1iZXJvZiEgRGF0ZXRpbWVUcmFuc2Zvcm1cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZvcm1hdDogWydzdHJpbmcnLCB0cnVlLCAnSVNPODYwMSddLFxuXG4gICAgLyoqXG4gICAgICogUmVmb3JtYXRzIHRvIGEgc3RyaW5nIHVzaW5nIHRoZSBtb21lbnRqcyBvciBwb3N0Z3JlU1FMIGZvcm1hdCBzcGVjaWZpZXJzLlxuICAgICAqIFRoaXMgYWxsb3dzIGEgdHJhbnNmb3JtYXRpb24gdG8gZGF5IG9mIHRoZSB5ZWFyLCBvciBkYXkgb2Ygd2VlayBldGMuXG4gICAgICogQG1lbWJlcm9mISBEYXRldGltZVRyYW5zZm9ybVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdHJhbnNmb3JtZWRGb3JtYXQ6IFsnc3RyaW5nJywgdHJ1ZSwgJ0lTTzg2MDEnXSxcblxuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIGNvbnZlcnNpb24gdG8gZHVyYXRpb24gYnkgc3VidHJhY3RpbmcgdGhpcyBkYXRlXG4gICAgICogQG1lbWJlcm9mISBEYXRldGltZVRyYW5zZm9ybVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdHJhbnNmb3JtZWRSZWZlcmVuY2U6ICdzdHJpbmcnLFxuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRpbWV6b25lIGZvciBjb252ZXJzaW9uIGZyb20gZGF0ZXRpbWUgdG8gZHVyYXRpb25cbiAgICAgKiBAbWVtYmVyb2YhIERhdGV0aW1lVHJhbnNmb3JtXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1lZFpvbmU6IFsnc3RyaW5nJywgdHJ1ZSwgJ0lTTzg2MDEnXVxuXG4gIH0sXG4gIGRlcml2ZWQ6IHtcbiAgICAvLyByZWZlcmVuY2UgbW9tZW50anMgZm9yIGR1cmF0aW9uIDwtPiBkYXRldGltZSBjb252ZXJzaW9uXG4gICAgcmVmZXJlbmNlTW9tZW50OiB7XG4gICAgICBkZXBzOiBbJ3RyYW5zZm9ybWVkUmVmZXJlbmNlJywgJ3RyYW5zZm9ybWVkWm9uZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHR6O1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm1lZFpvbmUgPT09ICdJU084NjAxJykge1xuICAgICAgICAgIHR6ID0gbW9tZW50LnR6Lmd1ZXNzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRpbWVab25lID0gdXRpbC50aW1lWm9uZXMuZ2V0KHRoaXMudHJhbnNmb3JtZWRab25lLCAnZGVzY3JpcHRpb24nKTtcbiAgICAgICAgICBpZiAodGltZVpvbmUgJiYgdGltZVpvbmUuZm9ybWF0KSB7XG4gICAgICAgICAgICB0eiA9IHRpbWVab25lLmZvcm1hdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHogPSBtb21lbnQudHouZ3Vlc3MoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtZWRSZWZlcmVuY2UpIHtcbiAgICAgICAgICByZXR1cm4gbW9tZW50LnR6KHRoaXMudHJhbnNmb3JtZWRSZWZlcmVuY2UsIHR6KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBmYWNldCBhZnRlciB0aGUgdHJhbnNmb3JtYXRpb24gaGFzIGJlZW4gYXBwbGllZFxuICAgICAqIEBtZW1iZXJvZiEgRGF0ZXRpbWVUcmFuc2Zvcm1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1lZFR5cGU6IHtcbiAgICAgIGRlcHM6IFsndHJhbnNmb3JtZWRGb3JtYXQnLCAndHJhbnNmb3JtZWRSZWZlcmVuY2UnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybWVkUmVmZXJlbmNlKSB7XG4gICAgICAgICAgLy8gZGF0ZXRpbWUgLT4gZHVyYXRpb25cbiAgICAgICAgICByZXR1cm4gJ2R1cmF0aW9uJztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRyYW5zZm9ybWVkRm9ybWF0ID09PSAnSVNPODYwMScpIHtcbiAgICAgICAgICAvLyBkYXRldGltZSAtPiBkYXRldGltZVxuICAgICAgICAgIHJldHVybiAnZGF0ZXRpbWUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRhdGV0aW1lIC0+IHRpbWUgcGFydFxuICAgICAgICAgIHZhciB0aW1lUGFydCA9IHV0aWwudGltZVBhcnRzLmdldCh0aGlzLnRyYW5zZm9ybWVkRm9ybWF0LCAnZGVzY3JpcHRpb24nKTtcbiAgICAgICAgICBpZiAodGltZVBhcnQgJiYgdGltZVBhcnQudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVQYXJ0LnR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnZGF0ZXRpbWUnO1xuICAgICAgfSxcbiAgICAgIGNhY2hlOiBmYWxzZVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIG1pbml1bSB2YWx1ZSB0aGlzIGZhY2V0IGNhbiB0YWtlLCBhZnRlciB0aGUgdHJhbnNmb3JtYXRpb24gaGFzIGJlZW4gYXBwbGllZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mISBEYXRldGltZVRyYW5zZm9ybVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWVkTWluOiB7XG4gICAgICBkZXBzOiBbJ3RyYW5zZm9ybWVkVHlwZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRpbWVQYXJ0O1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm1lZFR5cGUgPT09ICdkYXRldGltZScgfHwgdGhpcy50cmFuc2Zvcm1lZFR5cGUgPT09ICdkdXJhdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odGhpcy5wYXJlbnQubWludmFsKTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lUGFydCA9IHV0aWwudGltZVBhcnRzLmdldCh0aGlzLnRyYW5zZm9ybWVkRm9ybWF0LCAnZGVzY3JpcHRpb24nKTtcbiAgICAgICAgaWYgKHRpbWVQYXJ0LmNhbGN1YWx0ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh0aGlzLnBhcmVudC5taW52YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aW1lUGFydC5taW47XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWNoZTogZmFsc2VcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIHZhbHVlIHRoaXMgZmFjZXQgY2FuIHRha2UsIGFmdGVyIHRoZSB0cmFuc2Zvcm1hdGlvbiBoYXMgYmVlbiBhcHBsaWVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YhIERhdGV0aW1lVHJhbnNmb3JtXG4gICAgICovXG4gICAgdHJhbnNmb3JtZWRNYXg6IHtcbiAgICAgIGRlcHM6IFsndHJhbnNmb3JtZWRUeXBlJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGltZVBhcnQ7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybWVkVHlwZSA9PT0gJ2RhdGV0aW1lJyB8fCB0aGlzLnRyYW5zZm9ybWVkVHlwZSA9PT0gJ2R1cmF0aW9uJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh0aGlzLnBhcmVudC5tYXh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVQYXJ0ID0gdXRpbC50aW1lUGFydHMuZ2V0KHRoaXMudHJhbnNmb3JtZWRGb3JtYXQsICdkZXNjcmlwdGlvbicpO1xuICAgICAgICBpZiAodGltZVBhcnQuY2FsY3VhbHRlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHRoaXMucGFyZW50Lm1heHZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRpbWVQYXJ0Lm1heDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhY2hlOiBmYWxzZVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIG1pbmltdW0gdmFsdWUgdGhpcyBmYWNldCBjYW4gdGFrZSwgYWZ0ZXIgdGhlIHRyYW5zZm9ybWF0aW9uIGhhcyBiZWVuIGFwcGxpZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mISBEYXRldGltZVRyYW5zZm9ybVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWVkTWluQXNUZXh0OiB7XG4gICAgICBkZXBzOiBbJ3RyYW5zZm9ybWVkTWluJywgJ3RyYW5zZm9ybWVkVHlwZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1pbnZhbCA9IHRoaXMudHJhbnNmb3JtZWRNaW47XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybWVkVHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgIHJldHVybiBtaW52YWwuZm9ybWF0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG1pbnZhbC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FjaGU6IGZhbHNlXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSB2YWx1ZSB0aGlzIGZhY2V0IGNhbiB0YWtlLCBhZnRlciB0aGUgdHJhbnNmb3JtYXRpb24gaGFzIGJlZW4gYXBwbGllZFxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YhIERhdGV0aW1lVHJhbnNmb3JtXG4gICAgICovXG4gICAgdHJhbnNmb3JtZWRNYXhBc1RleHQ6IHtcbiAgICAgIGRlcHM6IFsndHJhbnNmb3JtZWRNYXgnLCAndHJhbnNmb3JtZWRUeXBlJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWF4dmFsID0gdGhpcy50cmFuc2Zvcm1lZE1heDtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtZWRUeXBlID09PSAnZGF0ZXRpbWUnKSB7XG4gICAgICAgICAgcmV0dXJuIG1heHZhbC5mb3JtYXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbWF4dmFsLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWNoZTogZmFsc2VcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyb2YhIERhdGV0aW1lVHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtb21lbnRqc1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBtb21lbnRqc1xuICAgKi9cbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0gKGludmFsKSB7XG4gICAgaWYgKHR5cGVvZiBpbnZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBtaXN2YWw7XG4gICAgfVxuXG4gICAgdmFyIGQgPSBpbnZhbC5jbG9uZSgpO1xuICAgIHZhciB0aW1lUGFydDtcblxuICAgIGlmICh0aGlzLnJlZmVyZW5jZU1vbWVudCkge1xuICAgICAgLy8gZGF0ZXRpbWUgLT4gZHVyYXRpb25cbiAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oZC5kaWZmKHRoaXMucmVmZXJlbmNlTW9tZW50LCAnbWlsbGlzZWNvbmRzJywgdHJ1ZSksICdtaWxsaXNlY29uZHMnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHJhbnNmb3JtZWRGb3JtYXQgIT09ICdJU084NjAxJykge1xuICAgICAgdGltZVBhcnQgPSB1dGlsLnRpbWVQYXJ0cy5nZXQodGhpcy50cmFuc2Zvcm1lZEZvcm1hdCwgJ2Rlc2NyaXB0aW9uJyk7XG4gICAgICBpZiAodGltZVBhcnQgJiYgdGltZVBhcnQubW9tZW50Rm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBkLmZvcm1hdCh0aW1lUGFydC5tb21lbnRGb3JtYXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgfSxcbiAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnVuc2V0KFsnem9uZScsICd0cmFuc2Zvcm1lZEZvcm1hdCcsICd0cmFuc2Zvcm1lZFpvbmUnLCAndHJhbnNmb3JtZWRSZWZlcmVuY2UnXSk7XG4gIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///a0ca\n")},aa6c:function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Module dependencies.\n */\n\nvar keys = __webpack_require__(/*! ./keys */ \"7d91\");\nvar hasBinary = __webpack_require__(/*! has-binary */ \"d304\");\nvar sliceBuffer = __webpack_require__(/*! arraybuffer.slice */ \"ef13\");\nvar after = __webpack_require__(/*! after */ \"4aa5\");\nvar utf8 = __webpack_require__(/*! wtf-8 */ \"943e\");\n\nvar base64encoder;\nif (global && global.ArrayBuffer) {\n  base64encoder = __webpack_require__(/*! base64-arraybuffer */ \"21de\");\n}\n\n/**\n * Check if we are running an android browser. That requires us to use\n * ArrayBuffer with polling transports...\n *\n * http://ghinda.net/jpeg-blob-ajax-android/\n */\n\nvar isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\n\n/**\n * Check if we are running in PhantomJS.\n * Uploading a Blob with PhantomJS does not work correctly, as reported here:\n * https://github.com/ariya/phantomjs/issues/11395\n * @type boolean\n */\nvar isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);\n\n/**\n * When true, avoids using Blobs to encode payloads.\n * @type boolean\n */\nvar dontSendBlobs = isAndroid || isPhantomJS;\n\n/**\n * Current protocol version.\n */\n\nexports.protocol = 3;\n\n/**\n * Packet types.\n */\n\nvar packets = exports.packets = {\n    open:     0    // non-ws\n  , close:    1    // non-ws\n  , ping:     2\n  , pong:     3\n  , message:  4\n  , upgrade:  5\n  , noop:     6\n};\n\nvar packetslist = keys(packets);\n\n/**\n * Premade error packet.\n */\n\nvar err = { type: 'error', data: 'parser error' };\n\n/**\n * Create a blob api even for blob builder when vendor prefixes exist\n */\n\nvar Blob = __webpack_require__(/*! blob */ \"939f\");\n\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\n\nexports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n  if ('function' == typeof supportsBinary) {\n    callback = supportsBinary;\n    supportsBinary = false;\n  }\n\n  if ('function' == typeof utf8encode) {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n\n  var data = (packet.data === undefined)\n    ? undefined\n    : packet.data.buffer || packet.data;\n\n  if (global.ArrayBuffer && data instanceof ArrayBuffer) {\n    return encodeArrayBuffer(packet, supportsBinary, callback);\n  } else if (Blob && data instanceof global.Blob) {\n    return encodeBlob(packet, supportsBinary, callback);\n  }\n\n  // might be an object with { base64: true, data: dataAsBase64String }\n  if (data && data.base64) {\n    return encodeBase64Object(packet, callback);\n  }\n\n  // Sending data as a utf-8 string\n  var encoded = packets[packet.type];\n\n  // data fragment is optional\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);\n  }\n\n  return callback('' + encoded);\n\n};\n\nfunction encodeBase64Object(packet, callback) {\n  // packet data is an object { base64: true, data: dataAsBase64String }\n  var message = 'b' + exports.packets[packet.type] + packet.data.data;\n  return callback(message);\n}\n\n/**\n * Encode packet helpers for binary types\n */\n\nfunction encodeArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var data = packet.data;\n  var contentArray = new Uint8Array(data);\n  var resultBuffer = new Uint8Array(1 + data.byteLength);\n\n  resultBuffer[0] = packets[packet.type];\n  for (var i = 0; i < contentArray.length; i++) {\n    resultBuffer[i+1] = contentArray[i];\n  }\n\n  return callback(resultBuffer.buffer);\n}\n\nfunction encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var fr = new FileReader();\n  fr.onload = function() {\n    packet.data = fr.result;\n    exports.encodePacket(packet, supportsBinary, true, callback);\n  };\n  return fr.readAsArrayBuffer(packet.data);\n}\n\nfunction encodeBlob(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  if (dontSendBlobs) {\n    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\n  }\n\n  var length = new Uint8Array(1);\n  length[0] = packets[packet.type];\n  var blob = new Blob([length.buffer, packet.data]);\n\n  return callback(blob);\n}\n\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\n\nexports.encodeBase64Packet = function(packet, callback) {\n  var message = 'b' + exports.packets[packet.type];\n  if (Blob && packet.data instanceof global.Blob) {\n    var fr = new FileReader();\n    fr.onload = function() {\n      var b64 = fr.result.split(',')[1];\n      callback(message + b64);\n    };\n    return fr.readAsDataURL(packet.data);\n  }\n\n  var b64data;\n  try {\n    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\n  } catch (e) {\n    // iPhone Safari doesn't let you apply with typed arrays\n    var typed = new Uint8Array(packet.data);\n    var basic = new Array(typed.length);\n    for (var i = 0; i < typed.length; i++) {\n      basic[i] = typed[i];\n    }\n    b64data = String.fromCharCode.apply(null, basic);\n  }\n  message += global.btoa(b64data);\n  return callback(message);\n};\n\n/**\n * Decodes a packet. Changes format to Blob if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\nexports.decodePacket = function (data, binaryType, utf8decode) {\n  if (data === undefined) {\n    return err;\n  }\n  // String data\n  if (typeof data == 'string') {\n    if (data.charAt(0) == 'b') {\n      return exports.decodeBase64Packet(data.substr(1), binaryType);\n    }\n\n    if (utf8decode) {\n      data = tryDecode(data);\n      if (data === false) {\n        return err;\n      }\n    }\n    var type = data.charAt(0);\n\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n\n    if (data.length > 1) {\n      return { type: packetslist[type], data: data.substring(1) };\n    } else {\n      return { type: packetslist[type] };\n    }\n  }\n\n  var asArray = new Uint8Array(data);\n  var type = asArray[0];\n  var rest = sliceBuffer(data, 1);\n  if (Blob && binaryType === 'blob') {\n    rest = new Blob([rest]);\n  }\n  return { type: packetslist[type], data: rest };\n};\n\nfunction tryDecode(data) {\n  try {\n    data = utf8.decode(data);\n  } catch (e) {\n    return false;\n  }\n  return data;\n}\n\n/**\n * Decodes a packet encoded in a base64 string\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\n\nexports.decodeBase64Packet = function(msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  if (!base64encoder) {\n    return { type: type, data: { base64: true, data: msg.substr(1) } };\n  }\n\n  var data = base64encoder.decode(msg.substr(1));\n\n  if (binaryType === 'blob' && Blob) {\n    data = new Blob([data]);\n  }\n\n  return { type: type, data: data };\n};\n\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\n\nexports.encodePayload = function (packets, supportsBinary, callback) {\n  if (typeof supportsBinary == 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  var isBinary = hasBinary(packets);\n\n  if (supportsBinary && isBinary) {\n    if (Blob && !dontSendBlobs) {\n      return exports.encodePayloadAsBlob(packets, callback);\n    }\n\n    return exports.encodePayloadAsArrayBuffer(packets, callback);\n  }\n\n  if (!packets.length) {\n    return callback('0:');\n  }\n\n  function setLengthHeader(message) {\n    return message.length + ':' + message;\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(results.join(''));\n  });\n};\n\n/**\n * Async array map using after\n */\n\nfunction map(ary, each, done) {\n  var result = new Array(ary.length);\n  var next = after(ary.length, done);\n\n  var eachWithIndex = function(i, el, cb) {\n    each(el, function(error, msg) {\n      result[i] = msg;\n      cb(error, result);\n    });\n  };\n\n  for (var i = 0; i < ary.length; i++) {\n    eachWithIndex(i, ary[i], next);\n  }\n}\n\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\n\nexports.decodePayload = function (data, binaryType, callback) {\n  if (typeof data != 'string') {\n    return exports.decodePayloadAsBinary(data, binaryType, callback);\n  }\n\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var packet;\n  if (data == '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = ''\n    , n, msg;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (':' != chr) {\n      length += chr;\n    } else {\n      if ('' == length || (length != (n = Number(length)))) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      msg = data.substr(i + 1, n);\n\n      if (length != msg.length) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      if (msg.length) {\n        packet = exports.decodePacket(msg, binaryType, true);\n\n        if (err.type == packet.type && err.data == packet.data) {\n          // parser error in individual packet - ignoring payload\n          return callback(err, 0, 1);\n        }\n\n        var ret = callback(packet, i + n, l);\n        if (false === ret) return;\n      }\n\n      // advance cursor\n      i += n;\n      length = '';\n    }\n  }\n\n  if (length != '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n};\n\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {ArrayBuffer} encoded payload\n * @api private\n */\n\nexports.encodePayloadAsArrayBuffer = function(packets, callback) {\n  if (!packets.length) {\n    return callback(new ArrayBuffer(0));\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(data) {\n      return doneCallback(null, data);\n    });\n  }\n\n  map(packets, encodeOne, function(err, encodedPackets) {\n    var totalLength = encodedPackets.reduce(function(acc, p) {\n      var len;\n      if (typeof p === 'string'){\n        len = p.length;\n      } else {\n        len = p.byteLength;\n      }\n      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2\n    }, 0);\n\n    var resultArray = new Uint8Array(totalLength);\n\n    var bufferIndex = 0;\n    encodedPackets.forEach(function(p) {\n      var isString = typeof p === 'string';\n      var ab = p;\n      if (isString) {\n        var view = new Uint8Array(p.length);\n        for (var i = 0; i < p.length; i++) {\n          view[i] = p.charCodeAt(i);\n        }\n        ab = view.buffer;\n      }\n\n      if (isString) { // not true binary\n        resultArray[bufferIndex++] = 0;\n      } else { // true binary\n        resultArray[bufferIndex++] = 1;\n      }\n\n      var lenStr = ab.byteLength.toString();\n      for (var i = 0; i < lenStr.length; i++) {\n        resultArray[bufferIndex++] = parseInt(lenStr[i]);\n      }\n      resultArray[bufferIndex++] = 255;\n\n      var view = new Uint8Array(ab);\n      for (var i = 0; i < view.length; i++) {\n        resultArray[bufferIndex++] = view[i];\n      }\n    });\n\n    return callback(resultArray.buffer);\n  });\n};\n\n/**\n * Encode as Blob\n */\n\nexports.encodePayloadAsBlob = function(packets, callback) {\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(encoded) {\n      var binaryIdentifier = new Uint8Array(1);\n      binaryIdentifier[0] = 1;\n      if (typeof encoded === 'string') {\n        var view = new Uint8Array(encoded.length);\n        for (var i = 0; i < encoded.length; i++) {\n          view[i] = encoded.charCodeAt(i);\n        }\n        encoded = view.buffer;\n        binaryIdentifier[0] = 0;\n      }\n\n      var len = (encoded instanceof ArrayBuffer)\n        ? encoded.byteLength\n        : encoded.size;\n\n      var lenStr = len.toString();\n      var lengthAry = new Uint8Array(lenStr.length + 1);\n      for (var i = 0; i < lenStr.length; i++) {\n        lengthAry[i] = parseInt(lenStr[i]);\n      }\n      lengthAry[lenStr.length] = 255;\n\n      if (Blob) {\n        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\n        doneCallback(null, blob);\n      }\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(new Blob(results));\n  });\n};\n\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n *\n * @param {ArrayBuffer} data, callback method\n * @api public\n */\n\nexports.decodePayloadAsBinary = function (data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var bufferTail = data;\n  var buffers = [];\n\n  var numberTooLong = false;\n  while (bufferTail.byteLength > 0) {\n    var tailArray = new Uint8Array(bufferTail);\n    var isString = tailArray[0] === 0;\n    var msgLength = '';\n\n    for (var i = 1; ; i++) {\n      if (tailArray[i] == 255) break;\n\n      if (msgLength.length > 310) {\n        numberTooLong = true;\n        break;\n      }\n\n      msgLength += tailArray[i];\n    }\n\n    if(numberTooLong) return callback(err, 0, 1);\n\n    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);\n    msgLength = parseInt(msgLength);\n\n    var msg = sliceBuffer(bufferTail, 0, msgLength);\n    if (isString) {\n      try {\n        msg = String.fromCharCode.apply(null, new Uint8Array(msg));\n      } catch (e) {\n        // iPhone Safari doesn't let you apply to typed arrays\n        var typed = new Uint8Array(msg);\n        msg = '';\n        for (var i = 0; i < typed.length; i++) {\n          msg += String.fromCharCode(typed[i]);\n        }\n      }\n    }\n\n    buffers.push(msg);\n    bufferTail = sliceBuffer(bufferTail, msgLength);\n  }\n\n  var total = buffers.length;\n  buffers.forEach(function(buffer, i) {\n    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n  });\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"698d\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWE2Yy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvYnJvd3Nlci5qcz9hZjAyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xudmFyIGhhc0JpbmFyeSA9IHJlcXVpcmUoJ2hhcy1iaW5hcnknKTtcbnZhciBzbGljZUJ1ZmZlciA9IHJlcXVpcmUoJ2FycmF5YnVmZmVyLnNsaWNlJyk7XG52YXIgYWZ0ZXIgPSByZXF1aXJlKCdhZnRlcicpO1xudmFyIHV0ZjggPSByZXF1aXJlKCd3dGYtOCcpO1xuXG52YXIgYmFzZTY0ZW5jb2RlcjtcbmlmIChnbG9iYWwgJiYgZ2xvYmFsLkFycmF5QnVmZmVyKSB7XG4gIGJhc2U2NGVuY29kZXIgPSByZXF1aXJlKCdiYXNlNjQtYXJyYXlidWZmZXInKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBhbiBhbmRyb2lkIGJyb3dzZXIuIFRoYXQgcmVxdWlyZXMgdXMgdG8gdXNlXG4gKiBBcnJheUJ1ZmZlciB3aXRoIHBvbGxpbmcgdHJhbnNwb3J0cy4uLlxuICpcbiAqIGh0dHA6Ly9naGluZGEubmV0L2pwZWctYmxvYi1hamF4LWFuZHJvaWQvXG4gKi9cblxudmFyIGlzQW5kcm9pZCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBpbiBQaGFudG9tSlMuXG4gKiBVcGxvYWRpbmcgYSBCbG9iIHdpdGggUGhhbnRvbUpTIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5LCBhcyByZXBvcnRlZCBoZXJlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTEzOTVcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGlzUGhhbnRvbUpTID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1BoYW50b21KUy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogV2hlbiB0cnVlLCBhdm9pZHMgdXNpbmcgQmxvYnMgdG8gZW5jb2RlIHBheWxvYWRzLlxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgZG9udFNlbmRCbG9icyA9IGlzQW5kcm9pZCB8fCBpc1BoYW50b21KUztcblxuLyoqXG4gKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICovXG5cbnZhciBwYWNrZXRzID0gZXhwb3J0cy5wYWNrZXRzID0ge1xuICAgIG9wZW46ICAgICAwICAgIC8vIG5vbi13c1xuICAsIGNsb3NlOiAgICAxICAgIC8vIG5vbi13c1xuICAsIHBpbmc6ICAgICAyXG4gICwgcG9uZzogICAgIDNcbiAgLCBtZXNzYWdlOiAgNFxuICAsIHVwZ3JhZGU6ICA1XG4gICwgbm9vcDogICAgIDZcbn07XG5cbnZhciBwYWNrZXRzbGlzdCA9IGtleXMocGFja2V0cyk7XG5cbi8qKlxuICogUHJlbWFkZSBlcnJvciBwYWNrZXQuXG4gKi9cblxudmFyIGVyciA9IHsgdHlwZTogJ2Vycm9yJywgZGF0YTogJ3BhcnNlciBlcnJvcicgfTtcblxuLyoqXG4gKiBDcmVhdGUgYSBibG9iIGFwaSBldmVuIGZvciBibG9iIGJ1aWxkZXIgd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYiA9IHJlcXVpcmUoJ2Jsb2InKTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0LlxuICpcbiAqICAgICA8cGFja2V0IHR5cGUgaWQ+IFsgPGRhdGE+IF1cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICA1aGVsbG8gd29ybGRcbiAqICAgICAzXG4gKiAgICAgNFxuICpcbiAqIEJpbmFyeSBpcyBlbmNvZGVkIGluIGFuIGlkZW50aWNhbCBwcmluY2lwbGVcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB1dGY4ZW5jb2RlLCBjYWxsYmFjaykge1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdXRmOGVuY29kZSkge1xuICAgIGNhbGxiYWNrID0gdXRmOGVuY29kZTtcbiAgICB1dGY4ZW5jb2RlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkYXRhID0gKHBhY2tldC5kYXRhID09PSB1bmRlZmluZWQpXG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHBhY2tldC5kYXRhLmJ1ZmZlciB8fCBwYWNrZXQuZGF0YTtcblxuICBpZiAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAoQmxvYiAmJiBkYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBtaWdodCBiZSBhbiBvYmplY3Qgd2l0aCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgaWYgKGRhdGEgJiYgZGF0YS5iYXNlNjQpIHtcbiAgICByZXR1cm4gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gU2VuZGluZyBkYXRhIGFzIGEgdXRmLTggc3RyaW5nXG4gIHZhciBlbmNvZGVkID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cbiAgLy8gZGF0YSBmcmFnbWVudCBpcyBvcHRpb25hbFxuICBpZiAodW5kZWZpbmVkICE9PSBwYWNrZXQuZGF0YSkge1xuICAgIGVuY29kZWQgKz0gdXRmOGVuY29kZSA/IHV0ZjguZW5jb2RlKFN0cmluZyhwYWNrZXQuZGF0YSkpIDogU3RyaW5nKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjaygnJyArIGVuY29kZWQpO1xuXG59O1xuXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjaykge1xuICAvLyBwYWNrZXQgZGF0YSBpcyBhbiBvYmplY3QgeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXSArIHBhY2tldC5kYXRhLmRhdGE7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGhlbHBlcnMgZm9yIGJpbmFyeSB0eXBlc1xuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHBhY2tldC5kYXRhO1xuICB2YXIgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciByZXN1bHRCdWZmZXIgPSBuZXcgVWludDhBcnJheSgxICsgZGF0YS5ieXRlTGVuZ3RoKTtcblxuICByZXN1bHRCdWZmZXJbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRCdWZmZXJbaSsxXSA9IGNvbnRlbnRBcnJheVtpXTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjayhyZXN1bHRCdWZmZXIuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIHBhY2tldC5kYXRhID0gZnIucmVzdWx0O1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHRydWUsIGNhbGxiYWNrKTtcbiAgfTtcbiAgcmV0dXJuIGZyLnJlYWRBc0FycmF5QnVmZmVyKHBhY2tldC5kYXRhKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKGRvbnRTZW5kQmxvYnMpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IG5ldyBVaW50OEFycmF5KDEpO1xuICBsZW5ndGhbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgdmFyIGJsb2IgPSBuZXcgQmxvYihbbGVuZ3RoLmJ1ZmZlciwgcGFja2V0LmRhdGFdKTtcblxuICByZXR1cm4gY2FsbGJhY2soYmxvYik7XG59XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldCB3aXRoIGJpbmFyeSBkYXRhIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuICogQHJldHVybiB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgaWYgKEJsb2IgJiYgcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYikge1xuICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYjY0ID0gZnIucmVzdWx0LnNwbGl0KCcsJylbMV07XG4gICAgICBjYWxsYmFjayhtZXNzYWdlICsgYjY0KTtcbiAgICB9O1xuICAgIHJldHVybiBmci5yZWFkQXNEYXRhVVJMKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHZhciBiNjRkYXRhO1xuICB0cnkge1xuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB3aXRoIHR5cGVkIGFycmF5c1xuICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKTtcbiAgICB2YXIgYmFzaWMgPSBuZXcgQXJyYXkodHlwZWQubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiYXNpY1tpXSA9IHR5cGVkW2ldO1xuICAgIH1cbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBiYXNpYyk7XG4gIH1cbiAgbWVzc2FnZSArPSBnbG9iYWwuYnRvYShiNjRkYXRhKTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0LiBDaGFuZ2VzIGZvcm1hdCB0byBCbG9iIGlmIHJlcXVlc3RlZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIHV0ZjhkZWNvZGUpIHtcbiAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBlcnI7XG4gIH1cbiAgLy8gU3RyaW5nIGRhdGFcbiAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGRhdGEuY2hhckF0KDApID09ICdiJykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0KGRhdGEuc3Vic3RyKDEpLCBiaW5hcnlUeXBlKTtcbiAgICB9XG5cbiAgICBpZiAodXRmOGRlY29kZSkge1xuICAgICAgZGF0YSA9IHRyeURlY29kZShkYXRhKTtcbiAgICAgIGlmIChkYXRhID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdHlwZSA9IGRhdGEuY2hhckF0KDApO1xuXG4gICAgaWYgKE51bWJlcih0eXBlKSAhPSB0eXBlIHx8ICFwYWNrZXRzbGlzdFt0eXBlXSkge1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogZGF0YS5zdWJzdHJpbmcoMSkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0gfTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXNBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB2YXIgdHlwZSA9IGFzQXJyYXlbMF07XG4gIHZhciByZXN0ID0gc2xpY2VCdWZmZXIoZGF0YSwgMSk7XG4gIGlmIChCbG9iICYmIGJpbmFyeVR5cGUgPT09ICdibG9iJykge1xuICAgIHJlc3QgPSBuZXcgQmxvYihbcmVzdF0pO1xuICB9XG4gIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiByZXN0IH07XG59O1xuXG5mdW5jdGlvbiB0cnlEZWNvZGUoZGF0YSkge1xuICB0cnkge1xuICAgIGRhdGEgPSB1dGY4LmRlY29kZShkYXRhKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0IGVuY29kZWQgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICovXG5cbmV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24obXNnLCBiaW5hcnlUeXBlKSB7XG4gIHZhciB0eXBlID0gcGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07XG4gIGlmICghYmFzZTY0ZW5jb2Rlcikge1xuICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBtc2cuc3Vic3RyKDEpIH0gfTtcbiAgfVxuXG4gIHZhciBkYXRhID0gYmFzZTY0ZW5jb2Rlci5kZWNvZGUobXNnLnN1YnN0cigxKSk7XG5cbiAgaWYgKGJpbmFyeVR5cGUgPT09ICdibG9iJyAmJiBCbG9iKSB7XG4gICAgZGF0YSA9IG5ldyBCbG9iKFtkYXRhXSk7XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH07XG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpLlxuICpcbiAqICAgICA8bGVuZ3RoPjpkYXRhXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgMTE6aGVsbG8gd29ybGQyOmhpXG4gKlxuICogSWYgYW55IGNvbnRlbnRzIGFyZSBiaW5hcnksIHRoZXkgd2lsbCBiZSBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmdzLiBCYXNlNjRcbiAqIGVuY29kZWQgc3RyaW5ncyBhcmUgbWFya2VkIHdpdGggYSBiIGJlZm9yZSB0aGUgbGVuZ3RoIHNwZWNpZmllclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChwYWNrZXRzLCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cbiAgaWYgKHN1cHBvcnRzQmluYXJ5ICYmIGlzQmluYXJ5KSB7XG4gICAgaWYgKEJsb2IgJiYgIWRvbnRTZW5kQmxvYnMpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIHRydWUsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdHMuam9pbignJykpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQXN5bmMgYXJyYXkgbWFwIHVzaW5nIGFmdGVyXG4gKi9cblxuZnVuY3Rpb24gbWFwKGFyeSwgZWFjaCwgZG9uZSkge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGFyeS5sZW5ndGgpO1xuICB2YXIgbmV4dCA9IGFmdGVyKGFyeS5sZW5ndGgsIGRvbmUpO1xuXG4gIHZhciBlYWNoV2l0aEluZGV4ID0gZnVuY3Rpb24oaSwgZWwsIGNiKSB7XG4gICAgZWFjaChlbCwgZnVuY3Rpb24oZXJyb3IsIG1zZykge1xuICAgICAgcmVzdWx0W2ldID0gbXNnO1xuICAgICAgY2IoZXJyb3IsIHJlc3VsdCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICBlYWNoV2l0aEluZGV4KGksIGFyeVtpXSwgbmV4dCk7XG4gIH1cbn1cblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gUG9zc2libGUgYmluYXJ5IGNvbnRlbnRzIGFyZVxuICogZGVjb2RlZCBmcm9tIHRoZWlyIGJhc2U2NCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZGF0YSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiBleHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeShkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgcGFja2V0O1xuICBpZiAoZGF0YSA9PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSAnJ1xuICAgICwgbiwgbXNnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cbiAgICBpZiAoJzonICE9IGNocikge1xuICAgICAgbGVuZ3RoICs9IGNocjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCcnID09IGxlbmd0aCB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBtc2cgPSBkYXRhLnN1YnN0cihpICsgMSwgbik7XG5cbiAgICAgIGlmIChsZW5ndGggIT0gbXNnLmxlbmd0aCkge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgICBwYWNrZXQgPSBleHBvcnRzLmRlY29kZVBhY2tldChtc2csIGJpbmFyeVR5cGUsIHRydWUpO1xuXG4gICAgICAgIGlmIChlcnIudHlwZSA9PSBwYWNrZXQudHlwZSAmJiBlcnIuZGF0YSA9PSBwYWNrZXQuZGF0YSkge1xuICAgICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgICAgaWYgKGZhbHNlID09PSByZXQpIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICAgIGkgKz0gbjtcbiAgICAgIGxlbmd0aCA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsZW5ndGggIT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKSBhcyBiaW5hcnkuXG4gKlxuICogPDEgPSBiaW5hcnksIDAgPSBzdHJpbmc+PG51bWJlciBmcm9tIDAtOT48bnVtYmVyIGZyb20gMC05PlsuLi5dPG51bWJlclxuICogMjU1PjxkYXRhPlxuICpcbiAqIEV4YW1wbGU6XG4gKiAxIDMgMjU1IDEgMiAzLCBpZiB0aGUgYmluYXJ5IGNvbnRlbnRzIGFyZSBpbnRlcnByZXRlZCBhcyA4IGJpdCBpbnRlZ2Vyc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBlbmNvZGVkIHBheWxvYWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBkb25lQ2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIGVuY29kZWRQYWNrZXRzKSB7XG4gICAgdmFyIHRvdGFsTGVuZ3RoID0gZW5jb2RlZFBhY2tldHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgcCkge1xuICAgICAgdmFyIGxlbjtcbiAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpe1xuICAgICAgICBsZW4gPSBwLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IHAuYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2MgKyBsZW4udG9TdHJpbmcoKS5sZW5ndGggKyBsZW4gKyAyOyAvLyBzdHJpbmcvYmluYXJ5IGlkZW50aWZpZXIgKyBzZXBhcmF0b3IgPSAyXG4gICAgfSwgMCk7XG5cbiAgICB2YXIgcmVzdWx0QXJyYXkgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG5cbiAgICB2YXIgYnVmZmVySW5kZXggPSAwO1xuICAgIGVuY29kZWRQYWNrZXRzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnO1xuICAgICAgdmFyIGFiID0gcDtcbiAgICAgIGlmIChpc1N0cmluZykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHAubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IHAuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBhYiA9IHZpZXcuYnVmZmVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTdHJpbmcpIHsgLy8gbm90IHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMDtcbiAgICAgIH0gZWxzZSB7IC8vIHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlblN0ciA9IGFiLmJ5dGVMZW5ndGgudG9TdHJpbmcoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMjU1O1xuXG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHZpZXdbaV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0QXJyYXkuYnVmZmVyKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEVuY29kZSBhcyBCbG9iXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICB2YXIgYmluYXJ5SWRlbnRpZmllciA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDE7XG4gICAgICBpZiAodHlwZW9mIGVuY29kZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gZW5jb2RlZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZWQgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSAoZW5jb2RlZCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICA/IGVuY29kZWQuYnl0ZUxlbmd0aFxuICAgICAgICA6IGVuY29kZWQuc2l6ZTtcblxuICAgICAgdmFyIGxlblN0ciA9IGxlbi50b1N0cmluZygpO1xuICAgICAgdmFyIGxlbmd0aEFyeSA9IG5ldyBVaW50OEFycmF5KGxlblN0ci5sZW5ndGggKyAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxlbmd0aEFyeVtpXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICBsZW5ndGhBcnlbbGVuU3RyLmxlbmd0aF0gPSAyNTU7XG5cbiAgICAgIGlmIChCbG9iKSB7XG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2JpbmFyeUlkZW50aWZpZXIuYnVmZmVyLCBsZW5ndGhBcnkuYnVmZmVyLCBlbmNvZGVkXSk7XG4gICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBibG9iKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQmxvYihyZXN1bHRzKSk7XG4gIH0pO1xufTtcblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gU3RyaW5ncyBhcmUgZGVjb2RlZCBieVxuICogaW50ZXJwcmV0aW5nIGVhY2ggYnl0ZSBhcyBhIGtleSBjb2RlIGZvciBlbnRyaWVzIG1hcmtlZCB0byBzdGFydCB3aXRoIDAuIFNlZVxuICogZGVzY3JpcHRpb24gb2YgZW5jb2RlUGF5bG9hZEFzQmluYXJ5XG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBidWZmZXJUYWlsID0gZGF0YTtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcblxuICB2YXIgbnVtYmVyVG9vTG9uZyA9IGZhbHNlO1xuICB3aGlsZSAoYnVmZmVyVGFpbC5ieXRlTGVuZ3RoID4gMCkge1xuICAgIHZhciB0YWlsQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJUYWlsKTtcbiAgICB2YXIgaXNTdHJpbmcgPSB0YWlsQXJyYXlbMF0gPT09IDA7XG4gICAgdmFyIG1zZ0xlbmd0aCA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IDsgaSsrKSB7XG4gICAgICBpZiAodGFpbEFycmF5W2ldID09IDI1NSkgYnJlYWs7XG5cbiAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgIG51bWJlclRvb0xvbmcgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbXNnTGVuZ3RoICs9IHRhaWxBcnJheVtpXTtcbiAgICB9XG5cbiAgICBpZihudW1iZXJUb29Mb25nKSByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblxuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgbXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG4gICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG4gICAgICAgIG1zZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIG1zZ0xlbmd0aCk7XG4gIH1cblxuICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1ZmZlciwgaSkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgfSk7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aa6c\n")},adfa:function(module,exports,__webpack_require__){eval("/**\n * Utility functions for crossfilter datasets\n * We roughly follow the crossfilter design of dimensions and groups, but we\n * add extra steps to allow transformations on the data.\n * 1. a datum is turned into a raw value, ie. string or number etc. by rawValueFn\n * 2. it is then cast to the correct type value using baseValFn\n * 3. a further transfrom can be applied with valueFn\n * 4. a value is grouped using groupFn; this value must be either a number or a string.\n *\n * @module client/util-crossfilter\n * @see rawValueFn, baseValueFn, valueFn, groupFn\n */\nvar misval = __webpack_require__(/*! ./misval */ \"bff6\");\nvar moment = __webpack_require__(/*! moment-timezone */ \"6c9d\");\nvar util = __webpack_require__(/*! ../util/time */ \"d45b\");\n\n/**\n * @typedef {Object} SubgroupValue\n * @property {number} count The count of the number of elements in this subgroup\n * @property {number} sum The sum of all elements in this subgroup\n */\n\n/**\n * Reduce a SubgroupValue to a single number\n *\n * @callback reduceCB\n * @param {SubgroupValue} d SubgroupValue\n * @returns {number} Reduced value\n */\n/**\n\n/**\n * Returns a function for further reducing the crossfilter group\n * to a single value, depending on sum/count/average settings of\n * the Aggregate class.\n * @param {Aggregate} facet - The Aggregate class for which to create the reduction function\n * @returns {cb} The required reduction function\n */\nfunction reduceFn (aggregate) {\n  if (aggregate.doSum) {\n    /**\n     * @callback subgroupSum\n     * @param {SubgroupValue} d\n     * @returns {number} sum\n     */\n    return function (d) {\n      if (d === misval || d == null) {\n        return misval;\n      }\n      if (d.count > 0) {\n        return d.sum;\n      } else {\n        return misval;\n      }\n    };\n  } else if (aggregate.doCount) {\n    /**\n     * @callback subgroupCount\n     * @param {SubgroupValue} d\n     * @returns {number} count\n     */\n    return function (d) {\n      if (d === misval || d == null) {\n        return misval;\n      }\n      if (d.count > 0) {\n        return d.count;\n      } else {\n        return misval;\n      }\n    };\n  } else if (aggregate.doAverage) {\n    /**\n     * @callback subgroupAverage\n     * @param {SubgroupValue} d\n     * @returns {number} d.sum/d.count\n     */\n    return function (d) {\n      if (d === misval || d == null) {\n        return misval;\n      }\n\n      if (d.count > 0) {\n        return d.sum / d.count;\n      } else {\n        return misval;\n      }\n    };\n  } else if (aggregate.doStddev) {\n    /**\n     * @callback subgroupStddev\n     * @param {SubgroupValue} d\n     * @returns {number} stddev(d)\n     */\n    return function (d) {\n      if (d === misval || d == null) {\n        return misval;\n      }\n\n      // \\sum_i (x_i - \\bar x)^2 =\n      //   \\sum_i (x_i^2 - 2x_i\\bar x + (\\bar x)^2) =\n      //   \\sum_i (x_i^2) - 2 N (\\bar x)^2 + N(\\bar x)^2 =\n      //   \\sum_i (x_i^2) - N (\\bar x)^2\n      if (d.count > 1) {\n        return Math.sqrt((d.sumsquares - (d.sum * d.sum / d.count)) / (d.count - 1));\n      } else {\n        return misval;\n      }\n    };\n  }\n\n  console.error('Operation not implemented for this Aggregate', aggregate);\n  return function (d) {\n    if (d === misval || d == null) {\n      return misval;\n    }\n    if (d.count > 0) {\n      return d.count;\n    } else {\n      return misval;\n    }\n  };\n}\n\n// ********************************************************\n// Facet transform utility function\n// ********************************************************\n\n/**\n * Returns the base value for a datum\n *\n * @callback baseValueCB\n * @param {Object} d Raw data record\n * @returns {Object} base value\n */\n\n/**\n * Raw value for given facet\n * @param {Facet} facet\n * @returns {rawValueCB} Raw value function for this facet\n */\nfunction rawValueFn (facet) {\n  var accessor;\n\n  // Array dimensions have a [] appended to the accessor,\n  // remove it to get to the actual accessor\n  var path = facet.accessor;\n  if (path.match(/\\[]$/)) {\n    path = path.substring(0, path.length - 2);\n  }\n\n  var misvals = {};\n  facet.misval.forEach(function (val) {\n    misvals[val] = true;\n  });\n\n  // Access nested properties via a double hash sign, this to prevent collision with regular keys; fi. 'person.name'\n  path = path.split('##');\n\n  if (path.length === 1) {\n    // Use a simple direct accessor, as it is probably faster than the more general case\n    // and it was implemented already\n    if (facet.misval.length > 0) {\n      accessor = function (d) {\n        var value = d[path[0]];\n        if (value === undefined || value === null || value in misvals) {\n          return misval;\n        }\n        return value;\n      };\n    } else {\n      accessor = function (d) {\n        var value = d[path[0]];\n        if (value === undefined || value === null) {\n          return misval;\n        }\n        return value;\n      };\n    }\n  } else {\n    // Recursively follow the crumbs to the desired property\n    accessor = function (d) {\n      var i = 0;\n      var value = d;\n\n      for (i = 0; i < path.length; i++) {\n        if (value && value[path[i]] !== undefined) {\n          value = value[path[i]];\n        } else {\n          return misval;\n        }\n      }\n\n      if (value === null || value in misvals) {\n        value = misval;\n      }\n      return value;\n    };\n  }\n\n  return accessor;\n}\n\n/**\n * Base value for given facet, ie. cast to correct type or object.\n * @param {Facet} facet\n * @returns {vaseValueCB} Base value function for this facet\n */\nfunction baseValueFn (facet) {\n  var rawValFn = rawValueFn(facet);\n\n  if (facet.isContinuous) {\n    /*\n     * Continuous facets:\n     * Parse numeric value from base value\n     */\n    return function (d) {\n      var val = parseFloat(rawValFn(d));\n      if (isNaN(val) || val === Infinity || val === -Infinity) {\n        return misval;\n      }\n      return val;\n    };\n  } else if (facet.isCategorial) {\n    return function (d) {\n      var vals = rawValFn(d);\n      if (vals !== misval) {\n        if (vals instanceof Array) {\n          vals.forEach(function (val, i) {\n            vals[i] = val.toString();\n          });\n        } else {\n          vals = vals.toString();\n        }\n        return vals;\n      }\n      return misval;\n    };\n  } else if (facet.isDatetime) {\n    /*\n     * Time parsing:\n     * 1. moment parses the string using the given format, but defaults to\n     *    the [ISO 8601 standard](https://en.wikipedia.org/wiki/ISO_8601)\n     * 2. Note that if the string contains timezone information, that is parsed too.\n     * 3. The time is transformed to requested timezone, defaulting the locale default\n     *    when no zone is set\n    */\n    var timeFormat = facet.datetimeTransform.format;\n    if (timeFormat === 'ISO8601') {\n      // use default ISO formatting\n      timeFormat = moment.ISO_8601;\n    }\n\n    var timeZone = facet.datetimeTransform.zone;\n    if (timeZone === 'ISO8601') {\n      // use default locale timezone, get overridden if a string contains a timezone\n      timeZone = moment.tz.guess();\n    } else {\n      timeZone = util.timeZones.get(timeZone, 'description').format;\n    }\n\n    return function (d) {\n      var value = rawValFn(d);\n      if (value !== misval) {\n        var m = moment.tz(value, timeFormat, timeZone);\n        if (m.isValid()) {\n          return m;\n        }\n      }\n      return misval;\n    };\n  } else if (facet.isDuration) {\n    /*\n     * Duration parsing:\n     * 1. If no format is given, the string parsed using\n     *    the [ISO 8601 standard](https://en.wikipedia.org/wiki/ISO_8601)\n     * 2. If a format is given, the string is parsed as float and interpreted in the given units\n     */\n    var units = facet.durationTransform.units;\n    if (units === 'ISO8601') {\n      return function (d) {\n        var value = rawValFn(d);\n\n        // parse string if necessary\n        if (value !== misval && typeof value === 'string' && value[0].toLowerCase() === 'p') {\n          value = moment.duration(value);\n        }\n\n        // check for valid duration\n        if (moment.isDuration(value)) {\n          return value;\n        }\n\n        return misval;\n      };\n    } else {\n      units = util.durationUnits.get(units, 'description').momentFormat;\n      return function (d) {\n        var value = rawValFn(d);\n\n        // parse string if necessary\n        if (value !== misval && !isNaN(value)) {\n          // NOTE: isNaN('0') is false, if that gives problems, we could use:\n          // value == +value) { // eslint-disable-line eqeqeq\n          value = moment.duration(parseFloat(value), units);\n        }\n\n        // check for valid duration\n        if (moment.isDuration(value)) {\n          return value;\n        }\n\n        return misval;\n      };\n    }\n  }\n\n  // isCategorial, isText\n  // no casting or constructing necessary, return the raw value\n  return rawValFn;\n}\n\n/**\n * Returns the transformed value from a base value\n *\n * @callback valueCB\n * @param {Object} d Base value\n * @returns {Object} Transformed value\n */\n\n/**\n * Create a function that returns the transformed value for this facet\n * @param {Facet} facet\n * @returns {valueCB} Value function for this facet\n */\nfunction valueFn (facet) {\n  // get base value function\n  var baseValFn = baseValueFn(facet);\n\n  if (facet.isConstant) {\n    return function () { return '1'; };\n  } else if (facet.isContinuous) {\n    // do we have a continuous transform?\n    if (facet.continuousTransform && facet.continuousTransform.type !== 'none') {\n      // yes, use it\n      return function (d) {\n        var val = facet.continuousTransform.transform(parseFloat(baseValFn(d)));\n        if (isNaN(val) || val === Infinity || val === -Infinity) {\n          return misval;\n        }\n        return val;\n      };\n    }\n  } else if (facet.isCategorial) {\n    // do we have a categorial transform?\n    if (facet.categorialTransform && facet.categorialTransform.rules.length > 0) {\n      // yes, use it\n      return function (d) {\n        var val = baseValFn(d);\n        return val === misval ? misval : facet.categorialTransform.transform(baseValFn(d));\n      };\n    }\n  } else if (facet.isDatetime) {\n    // always use the transform, so we do not have to repeat the yes/no transfrom logic here\n    return function (d) {\n      var val = baseValFn(d);\n      return val === misval ? misval : facet.datetimeTransform.transform(val);\n    };\n  } else if (facet.isDuration) {\n    // always use the transform, so we do not have to repeat the yes/no transfrom logic here\n    return function (d) {\n      var val = baseValFn(d);\n      return val === misval ? misval : facet.durationTransform.transform(val);\n    };\n  }\n\n  // no transfrom, return base value\n  return baseValFn;\n}\n\nfunction continuousGroupFn (partition) {\n  return function (d) {\n    if (d === misval) {\n      return d;\n    }\n\n    var ngroups = partition.groups.length;\n    if (d < partition.minval || d > partition.maxval) {\n      return misval;\n    }\n\n    // bins include their lower bound, but not their upper bound\n    var i = 0;\n    while (i < ngroups && d >= partition.groups.models[i].max) {\n      i++;\n    }\n    // special case last bin includes also upperbound d === partition.maxval\n    if (i === ngroups) {\n      return partition.groups.models[i - 1].value;\n    }\n    return partition.groups.models[i].value;\n  };\n}\n\n/*\n * Round the datetime to the specified resolution\n * see:\n * http://momentjs.com/docs/#/manipulating/start-of/\n * http://momentjs.com/docs/#/displaying/as-javascript-date/\n */\nfunction datetimeGroupFn (partition) {\n  var timeStep = util.getDatetimeResolution(partition.minval, partition.maxval);\n  return function (d) {\n    if (d === misval) {\n      return misval;\n    }\n    if (d.isBefore(partition.minval) || d.isAfter(partition.maxval)) {\n      return misval;\n    }\n    var grouped = moment(d).startOf(timeStep).format();\n    return grouped;\n  };\n}\n\n/*\n * Round the duration to the specified resolution\n */\nfunction durationGroupFn (partition) {\n  var timeStep = util.getDurationResolution(partition.minval, partition.maxval);\n  return function (d) {\n    if (d === misval) {\n      return misval;\n    }\n    if (d < partition.minval || d > partition.maxval) {\n      return misval;\n    }\n    var rounded = Math.floor(parseFloat(d.as(timeStep)));\n    return moment.duration(rounded, timeStep).toISOString();\n  };\n}\n\n/*\n * Don't do any grouping; that is done in the step from base value to value.\n * Matching of facet value and group could lead to a different ordering,\n * which is not allowed by crossfilter\n */\nfunction categorialGroupFn (partition) {\n  return function (d) { return d; };\n}\n\n/**\n * Returns the grouped value for a transformed value\n *\n * @callback groupCB\n * @param {Object} d Transformed value\n * @returns {Object} Group\n */\n\n/**\n * Create a function that returns the group value for a partition\n * @param {Partition} partition\n * @returns {cb} Group function for this partition, taking a `Data`\n */\nfunction groupFn (partition) {\n  if (partition.isConstant) {\n    return function () { return '1'; };\n  } else if (partition.isContinuous) {\n    return continuousGroupFn(partition);\n  } else if (partition.isCategorial) {\n    return categorialGroupFn(partition);\n  } else if (partition.isDatetime) {\n    return datetimeGroupFn(partition);\n  } else if (partition.isDuration) {\n    return durationGroupFn(partition);\n  } else if (partition.isText) {\n    return function (d) { return d.toString(); };\n  } else {\n    console.error('Group function not implemented for partition', partition);\n  }\n}\n\nmodule.exports = {\n  rawValueFn: rawValueFn,\n  baseValueFn: baseValueFn,\n  valueFn: valueFn,\n  groupFn: groupFn,\n\n  reduceFn: reduceFn\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRmYS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvdXRpbC9jcm9zc2ZpbHRlci5qcz8xZjdhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGNyb3NzZmlsdGVyIGRhdGFzZXRzXG4gKiBXZSByb3VnaGx5IGZvbGxvdyB0aGUgY3Jvc3NmaWx0ZXIgZGVzaWduIG9mIGRpbWVuc2lvbnMgYW5kIGdyb3VwcywgYnV0IHdlXG4gKiBhZGQgZXh0cmEgc3RlcHMgdG8gYWxsb3cgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBkYXRhLlxuICogMS4gYSBkYXR1bSBpcyB0dXJuZWQgaW50byBhIHJhdyB2YWx1ZSwgaWUuIHN0cmluZyBvciBudW1iZXIgZXRjLiBieSByYXdWYWx1ZUZuXG4gKiAyLiBpdCBpcyB0aGVuIGNhc3QgdG8gdGhlIGNvcnJlY3QgdHlwZSB2YWx1ZSB1c2luZyBiYXNlVmFsRm5cbiAqIDMuIGEgZnVydGhlciB0cmFuc2Zyb20gY2FuIGJlIGFwcGxpZWQgd2l0aCB2YWx1ZUZuXG4gKiA0LiBhIHZhbHVlIGlzIGdyb3VwZWQgdXNpbmcgZ3JvdXBGbjsgdGhpcyB2YWx1ZSBtdXN0IGJlIGVpdGhlciBhIG51bWJlciBvciBhIHN0cmluZy5cbiAqXG4gKiBAbW9kdWxlIGNsaWVudC91dGlsLWNyb3NzZmlsdGVyXG4gKiBAc2VlIHJhd1ZhbHVlRm4sIGJhc2VWYWx1ZUZuLCB2YWx1ZUZuLCBncm91cEZuXG4gKi9cbnZhciBtaXN2YWwgPSByZXF1aXJlKCcuL21pc3ZhbCcpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudC10aW1lem9uZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3RpbWUnKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdWJncm91cFZhbHVlXG4gKiBAcHJvcGVydHkge251bWJlcn0gY291bnQgVGhlIGNvdW50IG9mIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhpcyBzdWJncm91cFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN1bSBUaGUgc3VtIG9mIGFsbCBlbGVtZW50cyBpbiB0aGlzIHN1Ymdyb3VwXG4gKi9cblxuLyoqXG4gKiBSZWR1Y2UgYSBTdWJncm91cFZhbHVlIHRvIGEgc2luZ2xlIG51bWJlclxuICpcbiAqIEBjYWxsYmFjayByZWR1Y2VDQlxuICogQHBhcmFtIHtTdWJncm91cFZhbHVlfSBkIFN1Ymdyb3VwVmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJlZHVjZWQgdmFsdWVcbiAqL1xuLyoqXG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIGZvciBmdXJ0aGVyIHJlZHVjaW5nIHRoZSBjcm9zc2ZpbHRlciBncm91cFxuICogdG8gYSBzaW5nbGUgdmFsdWUsIGRlcGVuZGluZyBvbiBzdW0vY291bnQvYXZlcmFnZSBzZXR0aW5ncyBvZlxuICogdGhlIEFnZ3JlZ2F0ZSBjbGFzcy5cbiAqIEBwYXJhbSB7QWdncmVnYXRlfSBmYWNldCAtIFRoZSBBZ2dyZWdhdGUgY2xhc3MgZm9yIHdoaWNoIHRvIGNyZWF0ZSB0aGUgcmVkdWN0aW9uIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7Y2J9IFRoZSByZXF1aXJlZCByZWR1Y3Rpb24gZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gcmVkdWNlRm4gKGFnZ3JlZ2F0ZSkge1xuICBpZiAoYWdncmVnYXRlLmRvU3VtKSB7XG4gICAgLyoqXG4gICAgICogQGNhbGxiYWNrIHN1Ymdyb3VwU3VtXG4gICAgICogQHBhcmFtIHtTdWJncm91cFZhbHVlfSBkXG4gICAgICogQHJldHVybnMge251bWJlcn0gc3VtXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgICBpZiAoZCA9PT0gbWlzdmFsIHx8IGQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbWlzdmFsO1xuICAgICAgfVxuICAgICAgaWYgKGQuY291bnQgPiAwKSB7XG4gICAgICAgIHJldHVybiBkLnN1bTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtaXN2YWw7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIGlmIChhZ2dyZWdhdGUuZG9Db3VudCkge1xuICAgIC8qKlxuICAgICAqIEBjYWxsYmFjayBzdWJncm91cENvdW50XG4gICAgICogQHBhcmFtIHtTdWJncm91cFZhbHVlfSBkXG4gICAgICogQHJldHVybnMge251bWJlcn0gY291bnRcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIGlmIChkID09PSBtaXN2YWwgfHwgZCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtaXN2YWw7XG4gICAgICB9XG4gICAgICBpZiAoZC5jb3VudCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGQuY291bnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWlzdmFsO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAoYWdncmVnYXRlLmRvQXZlcmFnZSkge1xuICAgIC8qKlxuICAgICAqIEBjYWxsYmFjayBzdWJncm91cEF2ZXJhZ2VcbiAgICAgKiBAcGFyYW0ge1N1Ymdyb3VwVmFsdWV9IGRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBkLnN1bS9kLmNvdW50XG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgICBpZiAoZCA9PT0gbWlzdmFsIHx8IGQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbWlzdmFsO1xuICAgICAgfVxuXG4gICAgICBpZiAoZC5jb3VudCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGQuc3VtIC8gZC5jb3VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtaXN2YWw7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIGlmIChhZ2dyZWdhdGUuZG9TdGRkZXYpIHtcbiAgICAvKipcbiAgICAgKiBAY2FsbGJhY2sgc3ViZ3JvdXBTdGRkZXZcbiAgICAgKiBAcGFyYW0ge1N1Ymdyb3VwVmFsdWV9IGRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBzdGRkZXYoZClcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIGlmIChkID09PSBtaXN2YWwgfHwgZCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtaXN2YWw7XG4gICAgICB9XG5cbiAgICAgIC8vIFxcc3VtX2kgKHhfaSAtIFxcYmFyIHgpXjIgPVxuICAgICAgLy8gICBcXHN1bV9pICh4X2leMiAtIDJ4X2lcXGJhciB4ICsgKFxcYmFyIHgpXjIpID1cbiAgICAgIC8vICAgXFxzdW1faSAoeF9pXjIpIC0gMiBOIChcXGJhciB4KV4yICsgTihcXGJhciB4KV4yID1cbiAgICAgIC8vICAgXFxzdW1faSAoeF9pXjIpIC0gTiAoXFxiYXIgeCleMlxuICAgICAgaWYgKGQuY291bnQgPiAxKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoKGQuc3Vtc3F1YXJlcyAtIChkLnN1bSAqIGQuc3VtIC8gZC5jb3VudCkpIC8gKGQuY291bnQgLSAxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWlzdmFsO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBjb25zb2xlLmVycm9yKCdPcGVyYXRpb24gbm90IGltcGxlbWVudGVkIGZvciB0aGlzIEFnZ3JlZ2F0ZScsIGFnZ3JlZ2F0ZSk7XG4gIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgIGlmIChkID09PSBtaXN2YWwgfHwgZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbWlzdmFsO1xuICAgIH1cbiAgICBpZiAoZC5jb3VudCA+IDApIHtcbiAgICAgIHJldHVybiBkLmNvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlzdmFsO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vIEZhY2V0IHRyYW5zZm9ybSB1dGlsaXR5IGZ1bmN0aW9uXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgdmFsdWUgZm9yIGEgZGF0dW1cbiAqXG4gKiBAY2FsbGJhY2sgYmFzZVZhbHVlQ0JcbiAqIEBwYXJhbSB7T2JqZWN0fSBkIFJhdyBkYXRhIHJlY29yZFxuICogQHJldHVybnMge09iamVjdH0gYmFzZSB2YWx1ZVxuICovXG5cbi8qKlxuICogUmF3IHZhbHVlIGZvciBnaXZlbiBmYWNldFxuICogQHBhcmFtIHtGYWNldH0gZmFjZXRcbiAqIEByZXR1cm5zIHtyYXdWYWx1ZUNCfSBSYXcgdmFsdWUgZnVuY3Rpb24gZm9yIHRoaXMgZmFjZXRcbiAqL1xuZnVuY3Rpb24gcmF3VmFsdWVGbiAoZmFjZXQpIHtcbiAgdmFyIGFjY2Vzc29yO1xuXG4gIC8vIEFycmF5IGRpbWVuc2lvbnMgaGF2ZSBhIFtdIGFwcGVuZGVkIHRvIHRoZSBhY2Nlc3NvcixcbiAgLy8gcmVtb3ZlIGl0IHRvIGdldCB0byB0aGUgYWN0dWFsIGFjY2Vzc29yXG4gIHZhciBwYXRoID0gZmFjZXQuYWNjZXNzb3I7XG4gIGlmIChwYXRoLm1hdGNoKC9cXFtdJC8pKSB7XG4gICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIHBhdGgubGVuZ3RoIC0gMik7XG4gIH1cblxuICB2YXIgbWlzdmFscyA9IHt9O1xuICBmYWNldC5taXN2YWwuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG4gICAgbWlzdmFsc1t2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgLy8gQWNjZXNzIG5lc3RlZCBwcm9wZXJ0aWVzIHZpYSBhIGRvdWJsZSBoYXNoIHNpZ24sIHRoaXMgdG8gcHJldmVudCBjb2xsaXNpb24gd2l0aCByZWd1bGFyIGtleXM7IGZpLiAncGVyc29uLm5hbWUnXG4gIHBhdGggPSBwYXRoLnNwbGl0KCcjIycpO1xuXG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFVzZSBhIHNpbXBsZSBkaXJlY3QgYWNjZXNzb3IsIGFzIGl0IGlzIHByb2JhYmx5IGZhc3RlciB0aGFuIHRoZSBtb3JlIGdlbmVyYWwgY2FzZVxuICAgIC8vIGFuZCBpdCB3YXMgaW1wbGVtZW50ZWQgYWxyZWFkeVxuICAgIGlmIChmYWNldC5taXN2YWwubGVuZ3RoID4gMCkge1xuICAgICAgYWNjZXNzb3IgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBkW3BhdGhbMF1dO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSBpbiBtaXN2YWxzKSB7XG4gICAgICAgICAgcmV0dXJuIG1pc3ZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2Nlc3NvciA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRbcGF0aFswXV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG1pc3ZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBSZWN1cnNpdmVseSBmb2xsb3cgdGhlIGNydW1icyB0byB0aGUgZGVzaXJlZCBwcm9wZXJ0eVxuICAgIGFjY2Vzc29yID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciB2YWx1ZSA9IGQ7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZVtwYXRoW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZVtwYXRoW2ldXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbWlzdmFsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSBpbiBtaXN2YWxzKSB7XG4gICAgICAgIHZhbHVlID0gbWlzdmFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gYWNjZXNzb3I7XG59XG5cbi8qKlxuICogQmFzZSB2YWx1ZSBmb3IgZ2l2ZW4gZmFjZXQsIGllLiBjYXN0IHRvIGNvcnJlY3QgdHlwZSBvciBvYmplY3QuXG4gKiBAcGFyYW0ge0ZhY2V0fSBmYWNldFxuICogQHJldHVybnMge3Zhc2VWYWx1ZUNCfSBCYXNlIHZhbHVlIGZ1bmN0aW9uIGZvciB0aGlzIGZhY2V0XG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZUZuIChmYWNldCkge1xuICB2YXIgcmF3VmFsRm4gPSByYXdWYWx1ZUZuKGZhY2V0KTtcblxuICBpZiAoZmFjZXQuaXNDb250aW51b3VzKSB7XG4gICAgLypcbiAgICAgKiBDb250aW51b3VzIGZhY2V0czpcbiAgICAgKiBQYXJzZSBudW1lcmljIHZhbHVlIGZyb20gYmFzZSB2YWx1ZVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIHZhbCA9IHBhcnNlRmxvYXQocmF3VmFsRm4oZCkpO1xuICAgICAgaWYgKGlzTmFOKHZhbCkgfHwgdmFsID09PSBJbmZpbml0eSB8fCB2YWwgPT09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gbWlzdmFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuICB9IGVsc2UgaWYgKGZhY2V0LmlzQ2F0ZWdvcmlhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIHZhbHMgPSByYXdWYWxGbihkKTtcbiAgICAgIGlmICh2YWxzICE9PSBtaXN2YWwpIHtcbiAgICAgICAgaWYgKHZhbHMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIHZhbHMuZm9yRWFjaChmdW5jdGlvbiAodmFsLCBpKSB7XG4gICAgICAgICAgICB2YWxzW2ldID0gdmFsLnRvU3RyaW5nKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFscyA9IHZhbHMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFscztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtaXN2YWw7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChmYWNldC5pc0RhdGV0aW1lKSB7XG4gICAgLypcbiAgICAgKiBUaW1lIHBhcnNpbmc6XG4gICAgICogMS4gbW9tZW50IHBhcnNlcyB0aGUgc3RyaW5nIHVzaW5nIHRoZSBnaXZlbiBmb3JtYXQsIGJ1dCBkZWZhdWx0cyB0b1xuICAgICAqICAgIHRoZSBbSVNPIDg2MDEgc3RhbmRhcmRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxKVxuICAgICAqIDIuIE5vdGUgdGhhdCBpZiB0aGUgc3RyaW5nIGNvbnRhaW5zIHRpbWV6b25lIGluZm9ybWF0aW9uLCB0aGF0IGlzIHBhcnNlZCB0b28uXG4gICAgICogMy4gVGhlIHRpbWUgaXMgdHJhbnNmb3JtZWQgdG8gcmVxdWVzdGVkIHRpbWV6b25lLCBkZWZhdWx0aW5nIHRoZSBsb2NhbGUgZGVmYXVsdFxuICAgICAqICAgIHdoZW4gbm8gem9uZSBpcyBzZXRcbiAgICAqL1xuICAgIHZhciB0aW1lRm9ybWF0ID0gZmFjZXQuZGF0ZXRpbWVUcmFuc2Zvcm0uZm9ybWF0O1xuICAgIGlmICh0aW1lRm9ybWF0ID09PSAnSVNPODYwMScpIHtcbiAgICAgIC8vIHVzZSBkZWZhdWx0IElTTyBmb3JtYXR0aW5nXG4gICAgICB0aW1lRm9ybWF0ID0gbW9tZW50LklTT184NjAxO1xuICAgIH1cblxuICAgIHZhciB0aW1lWm9uZSA9IGZhY2V0LmRhdGV0aW1lVHJhbnNmb3JtLnpvbmU7XG4gICAgaWYgKHRpbWVab25lID09PSAnSVNPODYwMScpIHtcbiAgICAgIC8vIHVzZSBkZWZhdWx0IGxvY2FsZSB0aW1lem9uZSwgZ2V0IG92ZXJyaWRkZW4gaWYgYSBzdHJpbmcgY29udGFpbnMgYSB0aW1lem9uZVxuICAgICAgdGltZVpvbmUgPSBtb21lbnQudHouZ3Vlc3MoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZVpvbmUgPSB1dGlsLnRpbWVab25lcy5nZXQodGltZVpvbmUsICdkZXNjcmlwdGlvbicpLmZvcm1hdDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHJhd1ZhbEZuKGQpO1xuICAgICAgaWYgKHZhbHVlICE9PSBtaXN2YWwpIHtcbiAgICAgICAgdmFyIG0gPSBtb21lbnQudHoodmFsdWUsIHRpbWVGb3JtYXQsIHRpbWVab25lKTtcbiAgICAgICAgaWYgKG0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtaXN2YWw7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChmYWNldC5pc0R1cmF0aW9uKSB7XG4gICAgLypcbiAgICAgKiBEdXJhdGlvbiBwYXJzaW5nOlxuICAgICAqIDEuIElmIG5vIGZvcm1hdCBpcyBnaXZlbiwgdGhlIHN0cmluZyBwYXJzZWQgdXNpbmdcbiAgICAgKiAgICB0aGUgW0lTTyA4NjAxIHN0YW5kYXJkXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSlcbiAgICAgKiAyLiBJZiBhIGZvcm1hdCBpcyBnaXZlbiwgdGhlIHN0cmluZyBpcyBwYXJzZWQgYXMgZmxvYXQgYW5kIGludGVycHJldGVkIGluIHRoZSBnaXZlbiB1bml0c1xuICAgICAqL1xuICAgIHZhciB1bml0cyA9IGZhY2V0LmR1cmF0aW9uVHJhbnNmb3JtLnVuaXRzO1xuICAgIGlmICh1bml0cyA9PT0gJ0lTTzg2MDEnKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcmF3VmFsRm4oZCk7XG5cbiAgICAgICAgLy8gcGFyc2Ugc3RyaW5nIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAodmFsdWUgIT09IG1pc3ZhbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlWzBdLnRvTG93ZXJDYXNlKCkgPT09ICdwJykge1xuICAgICAgICAgIHZhbHVlID0gbW9tZW50LmR1cmF0aW9uKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGZvciB2YWxpZCBkdXJhdGlvblxuICAgICAgICBpZiAobW9tZW50LmlzRHVyYXRpb24odmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1pc3ZhbDtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXRzID0gdXRpbC5kdXJhdGlvblVuaXRzLmdldCh1bml0cywgJ2Rlc2NyaXB0aW9uJykubW9tZW50Rm9ybWF0O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJhd1ZhbEZuKGQpO1xuXG4gICAgICAgIC8vIHBhcnNlIHN0cmluZyBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKHZhbHVlICE9PSBtaXN2YWwgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgIC8vIE5PVEU6IGlzTmFOKCcwJykgaXMgZmFsc2UsIGlmIHRoYXQgZ2l2ZXMgcHJvYmxlbXMsIHdlIGNvdWxkIHVzZTpcbiAgICAgICAgICAvLyB2YWx1ZSA9PSArdmFsdWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgICB2YWx1ZSA9IG1vbWVudC5kdXJhdGlvbihwYXJzZUZsb2F0KHZhbHVlKSwgdW5pdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIHZhbGlkIGR1cmF0aW9uXG4gICAgICAgIGlmIChtb21lbnQuaXNEdXJhdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWlzdmFsO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBpc0NhdGVnb3JpYWwsIGlzVGV4dFxuICAvLyBubyBjYXN0aW5nIG9yIGNvbnN0cnVjdGluZyBuZWNlc3NhcnksIHJldHVybiB0aGUgcmF3IHZhbHVlXG4gIHJldHVybiByYXdWYWxGbjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZSBmcm9tIGEgYmFzZSB2YWx1ZVxuICpcbiAqIEBjYWxsYmFjayB2YWx1ZUNCXG4gKiBAcGFyYW0ge09iamVjdH0gZCBCYXNlIHZhbHVlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUcmFuc2Zvcm1lZCB2YWx1ZVxuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZSBmb3IgdGhpcyBmYWNldFxuICogQHBhcmFtIHtGYWNldH0gZmFjZXRcbiAqIEByZXR1cm5zIHt2YWx1ZUNCfSBWYWx1ZSBmdW5jdGlvbiBmb3IgdGhpcyBmYWNldFxuICovXG5mdW5jdGlvbiB2YWx1ZUZuIChmYWNldCkge1xuICAvLyBnZXQgYmFzZSB2YWx1ZSBmdW5jdGlvblxuICB2YXIgYmFzZVZhbEZuID0gYmFzZVZhbHVlRm4oZmFjZXQpO1xuXG4gIGlmIChmYWNldC5pc0NvbnN0YW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuICcxJzsgfTtcbiAgfSBlbHNlIGlmIChmYWNldC5pc0NvbnRpbnVvdXMpIHtcbiAgICAvLyBkbyB3ZSBoYXZlIGEgY29udGludW91cyB0cmFuc2Zvcm0/XG4gICAgaWYgKGZhY2V0LmNvbnRpbnVvdXNUcmFuc2Zvcm0gJiYgZmFjZXQuY29udGludW91c1RyYW5zZm9ybS50eXBlICE9PSAnbm9uZScpIHtcbiAgICAgIC8vIHllcywgdXNlIGl0XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIHZhbCA9IGZhY2V0LmNvbnRpbnVvdXNUcmFuc2Zvcm0udHJhbnNmb3JtKHBhcnNlRmxvYXQoYmFzZVZhbEZuKGQpKSk7XG4gICAgICAgIGlmIChpc05hTih2YWwpIHx8IHZhbCA9PT0gSW5maW5pdHkgfHwgdmFsID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXR1cm4gbWlzdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChmYWNldC5pc0NhdGVnb3JpYWwpIHtcbiAgICAvLyBkbyB3ZSBoYXZlIGEgY2F0ZWdvcmlhbCB0cmFuc2Zvcm0/XG4gICAgaWYgKGZhY2V0LmNhdGVnb3JpYWxUcmFuc2Zvcm0gJiYgZmFjZXQuY2F0ZWdvcmlhbFRyYW5zZm9ybS5ydWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyB5ZXMsIHVzZSBpdFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciB2YWwgPSBiYXNlVmFsRm4oZCk7XG4gICAgICAgIHJldHVybiB2YWwgPT09IG1pc3ZhbCA/IG1pc3ZhbCA6IGZhY2V0LmNhdGVnb3JpYWxUcmFuc2Zvcm0udHJhbnNmb3JtKGJhc2VWYWxGbihkKSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChmYWNldC5pc0RhdGV0aW1lKSB7XG4gICAgLy8gYWx3YXlzIHVzZSB0aGUgdHJhbnNmb3JtLCBzbyB3ZSBkbyBub3QgaGF2ZSB0byByZXBlYXQgdGhlIHllcy9ubyB0cmFuc2Zyb20gbG9naWMgaGVyZVxuICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIHZhbCA9IGJhc2VWYWxGbihkKTtcbiAgICAgIHJldHVybiB2YWwgPT09IG1pc3ZhbCA/IG1pc3ZhbCA6IGZhY2V0LmRhdGV0aW1lVHJhbnNmb3JtLnRyYW5zZm9ybSh2YWwpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoZmFjZXQuaXNEdXJhdGlvbikge1xuICAgIC8vIGFsd2F5cyB1c2UgdGhlIHRyYW5zZm9ybSwgc28gd2UgZG8gbm90IGhhdmUgdG8gcmVwZWF0IHRoZSB5ZXMvbm8gdHJhbnNmcm9tIGxvZ2ljIGhlcmVcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciB2YWwgPSBiYXNlVmFsRm4oZCk7XG4gICAgICByZXR1cm4gdmFsID09PSBtaXN2YWwgPyBtaXN2YWwgOiBmYWNldC5kdXJhdGlvblRyYW5zZm9ybS50cmFuc2Zvcm0odmFsKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gbm8gdHJhbnNmcm9tLCByZXR1cm4gYmFzZSB2YWx1ZVxuICByZXR1cm4gYmFzZVZhbEZuO1xufVxuXG5mdW5jdGlvbiBjb250aW51b3VzR3JvdXBGbiAocGFydGl0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgIGlmIChkID09PSBtaXN2YWwpIHtcbiAgICAgIHJldHVybiBkO1xuICAgIH1cblxuICAgIHZhciBuZ3JvdXBzID0gcGFydGl0aW9uLmdyb3Vwcy5sZW5ndGg7XG4gICAgaWYgKGQgPCBwYXJ0aXRpb24ubWludmFsIHx8IGQgPiBwYXJ0aXRpb24ubWF4dmFsKSB7XG4gICAgICByZXR1cm4gbWlzdmFsO1xuICAgIH1cblxuICAgIC8vIGJpbnMgaW5jbHVkZSB0aGVpciBsb3dlciBib3VuZCwgYnV0IG5vdCB0aGVpciB1cHBlciBib3VuZFxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IG5ncm91cHMgJiYgZCA+PSBwYXJ0aXRpb24uZ3JvdXBzLm1vZGVsc1tpXS5tYXgpIHtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgLy8gc3BlY2lhbCBjYXNlIGxhc3QgYmluIGluY2x1ZGVzIGFsc28gdXBwZXJib3VuZCBkID09PSBwYXJ0aXRpb24ubWF4dmFsXG4gICAgaWYgKGkgPT09IG5ncm91cHMpIHtcbiAgICAgIHJldHVybiBwYXJ0aXRpb24uZ3JvdXBzLm1vZGVsc1tpIC0gMV0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aXRpb24uZ3JvdXBzLm1vZGVsc1tpXS52YWx1ZTtcbiAgfTtcbn1cblxuLypcbiAqIFJvdW5kIHRoZSBkYXRldGltZSB0byB0aGUgc3BlY2lmaWVkIHJlc29sdXRpb25cbiAqIHNlZTpcbiAqIGh0dHA6Ly9tb21lbnRqcy5jb20vZG9jcy8jL21hbmlwdWxhdGluZy9zdGFydC1vZi9cbiAqIGh0dHA6Ly9tb21lbnRqcy5jb20vZG9jcy8jL2Rpc3BsYXlpbmcvYXMtamF2YXNjcmlwdC1kYXRlL1xuICovXG5mdW5jdGlvbiBkYXRldGltZUdyb3VwRm4gKHBhcnRpdGlvbikge1xuICB2YXIgdGltZVN0ZXAgPSB1dGlsLmdldERhdGV0aW1lUmVzb2x1dGlvbihwYXJ0aXRpb24ubWludmFsLCBwYXJ0aXRpb24ubWF4dmFsKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKGQgPT09IG1pc3ZhbCkge1xuICAgICAgcmV0dXJuIG1pc3ZhbDtcbiAgICB9XG4gICAgaWYgKGQuaXNCZWZvcmUocGFydGl0aW9uLm1pbnZhbCkgfHwgZC5pc0FmdGVyKHBhcnRpdGlvbi5tYXh2YWwpKSB7XG4gICAgICByZXR1cm4gbWlzdmFsO1xuICAgIH1cbiAgICB2YXIgZ3JvdXBlZCA9IG1vbWVudChkKS5zdGFydE9mKHRpbWVTdGVwKS5mb3JtYXQoKTtcbiAgICByZXR1cm4gZ3JvdXBlZDtcbiAgfTtcbn1cblxuLypcbiAqIFJvdW5kIHRoZSBkdXJhdGlvbiB0byB0aGUgc3BlY2lmaWVkIHJlc29sdXRpb25cbiAqL1xuZnVuY3Rpb24gZHVyYXRpb25Hcm91cEZuIChwYXJ0aXRpb24pIHtcbiAgdmFyIHRpbWVTdGVwID0gdXRpbC5nZXREdXJhdGlvblJlc29sdXRpb24ocGFydGl0aW9uLm1pbnZhbCwgcGFydGl0aW9uLm1heHZhbCk7XG4gIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgIGlmIChkID09PSBtaXN2YWwpIHtcbiAgICAgIHJldHVybiBtaXN2YWw7XG4gICAgfVxuICAgIGlmIChkIDwgcGFydGl0aW9uLm1pbnZhbCB8fCBkID4gcGFydGl0aW9uLm1heHZhbCkge1xuICAgICAgcmV0dXJuIG1pc3ZhbDtcbiAgICB9XG4gICAgdmFyIHJvdW5kZWQgPSBNYXRoLmZsb29yKHBhcnNlRmxvYXQoZC5hcyh0aW1lU3RlcCkpKTtcbiAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHJvdW5kZWQsIHRpbWVTdGVwKS50b0lTT1N0cmluZygpO1xuICB9O1xufVxuXG4vKlxuICogRG9uJ3QgZG8gYW55IGdyb3VwaW5nOyB0aGF0IGlzIGRvbmUgaW4gdGhlIHN0ZXAgZnJvbSBiYXNlIHZhbHVlIHRvIHZhbHVlLlxuICogTWF0Y2hpbmcgb2YgZmFjZXQgdmFsdWUgYW5kIGdyb3VwIGNvdWxkIGxlYWQgdG8gYSBkaWZmZXJlbnQgb3JkZXJpbmcsXG4gKiB3aGljaCBpcyBub3QgYWxsb3dlZCBieSBjcm9zc2ZpbHRlclxuICovXG5mdW5jdGlvbiBjYXRlZ29yaWFsR3JvdXBGbiAocGFydGl0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZDsgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBncm91cGVkIHZhbHVlIGZvciBhIHRyYW5zZm9ybWVkIHZhbHVlXG4gKlxuICogQGNhbGxiYWNrIGdyb3VwQ0JcbiAqIEBwYXJhbSB7T2JqZWN0fSBkIFRyYW5zZm9ybWVkIHZhbHVlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBHcm91cFxuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBncm91cCB2YWx1ZSBmb3IgYSBwYXJ0aXRpb25cbiAqIEBwYXJhbSB7UGFydGl0aW9ufSBwYXJ0aXRpb25cbiAqIEByZXR1cm5zIHtjYn0gR3JvdXAgZnVuY3Rpb24gZm9yIHRoaXMgcGFydGl0aW9uLCB0YWtpbmcgYSBgRGF0YWBcbiAqL1xuZnVuY3Rpb24gZ3JvdXBGbiAocGFydGl0aW9uKSB7XG4gIGlmIChwYXJ0aXRpb24uaXNDb25zdGFudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiAnMSc7IH07XG4gIH0gZWxzZSBpZiAocGFydGl0aW9uLmlzQ29udGludW91cykge1xuICAgIHJldHVybiBjb250aW51b3VzR3JvdXBGbihwYXJ0aXRpb24pO1xuICB9IGVsc2UgaWYgKHBhcnRpdGlvbi5pc0NhdGVnb3JpYWwpIHtcbiAgICByZXR1cm4gY2F0ZWdvcmlhbEdyb3VwRm4ocGFydGl0aW9uKTtcbiAgfSBlbHNlIGlmIChwYXJ0aXRpb24uaXNEYXRldGltZSkge1xuICAgIHJldHVybiBkYXRldGltZUdyb3VwRm4ocGFydGl0aW9uKTtcbiAgfSBlbHNlIGlmIChwYXJ0aXRpb24uaXNEdXJhdGlvbikge1xuICAgIHJldHVybiBkdXJhdGlvbkdyb3VwRm4ocGFydGl0aW9uKTtcbiAgfSBlbHNlIGlmIChwYXJ0aXRpb24uaXNUZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnRvU3RyaW5nKCk7IH07XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcignR3JvdXAgZnVuY3Rpb24gbm90IGltcGxlbWVudGVkIGZvciBwYXJ0aXRpb24nLCBwYXJ0aXRpb24pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByYXdWYWx1ZUZuOiByYXdWYWx1ZUZuLFxuICBiYXNlVmFsdWVGbjogYmFzZVZhbHVlRm4sXG4gIHZhbHVlRm46IHZhbHVlRm4sXG4gIGdyb3VwRm46IGdyb3VwRm4sXG5cbiAgcmVkdWNlRm46IHJlZHVjZUZuXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///adfa\n")},b123:function(module,exports,__webpack_require__){eval("/**\n * DurationTransfrom defines a transformation on duration data\n *\n * @class DurationTransform\n */\nvar AmpersandModel = __webpack_require__(/*! ampersand-model */ \"3bfc\");\nvar moment = __webpack_require__(/*! moment-timezone */ \"6c9d\");\nvar util = __webpack_require__(/*! ../util/time */ \"d45b\");\n\nmodule.exports = AmpersandModel.extend({\n  props: {\n    /**\n     * Units of the duration\n     *\n     * @memberof! DurationTransform\n     * @type {string}\n     */\n    units: ['string', true, 'ISO8601'],\n\n    /**\n     * For durations, transforms duration to these units\n     *\n     * @memberof! DurationTransform\n     * @type {string}\n     */\n    transformedUnits: ['string', true, 'ISO8601'],\n\n    /**\n     * Transform the date to this timezone.\n     *\n     * @memberof! DatetimeTransform\n     * @type {string}\n     */\n    transformedZone: ['string', true, 'ISO8601'],\n\n    /**\n     * Controls conversion to datetime by adding this date\n     *\n     * @memberof! DurationTransform\n     * @type {string}\n     */\n    transformedReference: 'string'\n  },\n  derived: {\n    /**\n     * Reference momentjs for duration <-> datetime conversion\n     *\n     * @type {moment}\n     * @memberof! DurationTransform\n     */\n    referenceMoment: {\n      deps: ['transformedReference', 'transformedZone'],\n      fn: function () {\n        var tz;\n        if (this.transformedZone === 'ISO8601') {\n          tz = moment.tz.guess();\n        } else {\n          var timeZone = util.timeZones.get(this.transformedZone, 'description');\n          if (timeZone && timeZone.format) {\n            tz = timeZone.format;\n          } else {\n            tz = moment.tz.guess();\n          }\n        }\n\n        if (this.transformedReference) {\n          return moment.tz(this.transformedReference, tz);\n        }\n        return null;\n      }\n    },\n    /**\n     * The type of the facet after the transformation has been applied\n     *\n     * @type {string}\n     * @memberof! DurationTransform\n     */\n    transformedType: {\n      deps: ['transformedFormat', 'transformedReference', 'transformedZone'],\n      fn: function () {\n        if (this.referenceMoment) {\n          return 'datetime';\n        } else if (this.transformedUnits !== 'ISO8601') {\n          return 'continuous';\n        } else {\n          return 'duration';\n        }\n      },\n      cache: false\n    },\n    /**\n     * The minium value this facet can take, after the transformation has been applied\n     *\n     * @type {number}\n     * @memberof! DurationTransform\n     */\n    transformedMin: {\n      deps: ['transformedType'],\n      fn: function () {\n        var facet = this.parent;\n        if (this.transformedType === 'datetime') {\n          return this.transform(facet.minval);\n        } else if (this.transformedType === 'continuous') {\n          return this.transform(facet.minval);\n        } else {\n          return facet.minval;\n        }\n      },\n      cache: false\n    },\n    /**\n     * The maximum value this facet can take, after the transformation has been applied\n     *\n     * @type {number}\n     * @memberof! DurationTransform\n     */\n    transformedMax: {\n      deps: ['transformedType'],\n      fn: function () {\n        var facet = this.parent;\n        if (this.transformedType === 'datetime') {\n          return this.transform(facet.maxval);\n        } else if (this.transformedType === 'continuous') {\n          return this.transform(facet.maxval);\n        } else {\n          return facet.maxval;\n        }\n      },\n      cache: false\n    },\n    /**\n     * The minimum value this facet can take, after the transformation has been applied\n     *\n     * @type {number}\n     * @memberof! DurationTransform\n     */\n    transformedMinAsText: {\n      deps: ['transformedMin', 'transformedType'],\n      fn: function () {\n        var minval = this.transformedMin;\n        if (this.transformedType === 'datetime') {\n          return minval.format();\n        } else {\n          return minval.toString();\n        }\n      },\n      cache: false\n    },\n    /**\n     * The maximum value this facet can take, after the transformation has been applied\n     *\n     * @type {number}\n     * @memberof! DurationTransform\n     */\n    transformedMaxAsText: {\n      deps: ['transformedMax', 'transformedType'],\n      fn: function () {\n        var maxval = this.transformedMax;\n        if (this.transformedType === 'datetime') {\n          return maxval.format();\n        } else {\n          return maxval.toString();\n        }\n      },\n      cache: false\n    }\n  },\n\n  /**\n   * Apply the configured transformation to this Facet's value\n   *\n   * @function\n   * @memberof! DurationTransform\n   * @param {Object} inval momentjs duration\n   * @returns {Object} outval momentjs duration or datetime\n   */\n  transform: function transform (inval) {\n    var units;\n    if (this.referenceMoment) {\n      // duration -> datetime\n      return this.referenceMoment.clone().add(inval);\n    } else if (this.transformedUnits !== 'ISO8601') {\n      // duration -> continuous\n      units = util.durationUnits.get(this.transformedUnits, 'description').momentFormat;\n      return inval.as(units);\n    } else {\n      // no change\n      return inval;\n    }\n  },\n  reset: function () {\n    this.unset(['zone', 'transformedFormat', 'transformedZone', 'transformedReference']);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYjEyMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmFjZXQvZHVyYXRpb24tdHJhbnNmb3JtLmpzPzJkZjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEdXJhdGlvblRyYW5zZnJvbSBkZWZpbmVzIGEgdHJhbnNmb3JtYXRpb24gb24gZHVyYXRpb24gZGF0YVxuICpcbiAqIEBjbGFzcyBEdXJhdGlvblRyYW5zZm9ybVxuICovXG52YXIgQW1wZXJzYW5kTW9kZWwgPSByZXF1aXJlKCdhbXBlcnNhbmQtbW9kZWwnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQtdGltZXpvbmUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC90aW1lJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQW1wZXJzYW5kTW9kZWwuZXh0ZW5kKHtcbiAgcHJvcHM6IHtcbiAgICAvKipcbiAgICAgKiBVbml0cyBvZiB0aGUgZHVyYXRpb25cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiEgRHVyYXRpb25UcmFuc2Zvcm1cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHVuaXRzOiBbJ3N0cmluZycsIHRydWUsICdJU084NjAxJ10sXG5cbiAgICAvKipcbiAgICAgKiBGb3IgZHVyYXRpb25zLCB0cmFuc2Zvcm1zIGR1cmF0aW9uIHRvIHRoZXNlIHVuaXRzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YhIER1cmF0aW9uVHJhbnNmb3JtXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1lZFVuaXRzOiBbJ3N0cmluZycsIHRydWUsICdJU084NjAxJ10sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gdGhlIGRhdGUgdG8gdGhpcyB0aW1lem9uZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiEgRGF0ZXRpbWVUcmFuc2Zvcm1cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWVkWm9uZTogWydzdHJpbmcnLCB0cnVlLCAnSVNPODYwMSddLFxuXG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgY29udmVyc2lvbiB0byBkYXRldGltZSBieSBhZGRpbmcgdGhpcyBkYXRlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YhIER1cmF0aW9uVHJhbnNmb3JtXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1lZFJlZmVyZW5jZTogJ3N0cmluZydcbiAgfSxcbiAgZGVyaXZlZDoge1xuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSBtb21lbnRqcyBmb3IgZHVyYXRpb24gPC0+IGRhdGV0aW1lIGNvbnZlcnNpb25cbiAgICAgKlxuICAgICAqIEB0eXBlIHttb21lbnR9XG4gICAgICogQG1lbWJlcm9mISBEdXJhdGlvblRyYW5zZm9ybVxuICAgICAqL1xuICAgIHJlZmVyZW5jZU1vbWVudDoge1xuICAgICAgZGVwczogWyd0cmFuc2Zvcm1lZFJlZmVyZW5jZScsICd0cmFuc2Zvcm1lZFpvbmUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ejtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtZWRab25lID09PSAnSVNPODYwMScpIHtcbiAgICAgICAgICB0eiA9IG1vbWVudC50ei5ndWVzcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0aW1lWm9uZSA9IHV0aWwudGltZVpvbmVzLmdldCh0aGlzLnRyYW5zZm9ybWVkWm9uZSwgJ2Rlc2NyaXB0aW9uJyk7XG4gICAgICAgICAgaWYgKHRpbWVab25lICYmIHRpbWVab25lLmZvcm1hdCkge1xuICAgICAgICAgICAgdHogPSB0aW1lWm9uZS5mb3JtYXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR6ID0gbW9tZW50LnR6Lmd1ZXNzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtZWRSZWZlcmVuY2UpIHtcbiAgICAgICAgICByZXR1cm4gbW9tZW50LnR6KHRoaXMudHJhbnNmb3JtZWRSZWZlcmVuY2UsIHR6KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBmYWNldCBhZnRlciB0aGUgdHJhbnNmb3JtYXRpb24gaGFzIGJlZW4gYXBwbGllZFxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YhIER1cmF0aW9uVHJhbnNmb3JtXG4gICAgICovXG4gICAgdHJhbnNmb3JtZWRUeXBlOiB7XG4gICAgICBkZXBzOiBbJ3RyYW5zZm9ybWVkRm9ybWF0JywgJ3RyYW5zZm9ybWVkUmVmZXJlbmNlJywgJ3RyYW5zZm9ybWVkWm9uZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmZXJlbmNlTW9tZW50KSB7XG4gICAgICAgICAgcmV0dXJuICdkYXRldGltZSc7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50cmFuc2Zvcm1lZFVuaXRzICE9PSAnSVNPODYwMScpIHtcbiAgICAgICAgICByZXR1cm4gJ2NvbnRpbnVvdXMnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAnZHVyYXRpb24nO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FjaGU6IGZhbHNlXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgbWluaXVtIHZhbHVlIHRoaXMgZmFjZXQgY2FuIHRha2UsIGFmdGVyIHRoZSB0cmFuc2Zvcm1hdGlvbiBoYXMgYmVlbiBhcHBsaWVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiEgRHVyYXRpb25UcmFuc2Zvcm1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1lZE1pbjoge1xuICAgICAgZGVwczogWyd0cmFuc2Zvcm1lZFR5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmYWNldCA9IHRoaXMucGFyZW50O1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm1lZFR5cGUgPT09ICdkYXRldGltZScpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oZmFjZXQubWludmFsKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRyYW5zZm9ybWVkVHlwZSA9PT0gJ2NvbnRpbnVvdXMnKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKGZhY2V0Lm1pbnZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhY2V0Lm1pbnZhbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhY2hlOiBmYWxzZVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gdmFsdWUgdGhpcyBmYWNldCBjYW4gdGFrZSwgYWZ0ZXIgdGhlIHRyYW5zZm9ybWF0aW9uIGhhcyBiZWVuIGFwcGxpZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mISBEdXJhdGlvblRyYW5zZm9ybVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWVkTWF4OiB7XG4gICAgICBkZXBzOiBbJ3RyYW5zZm9ybWVkVHlwZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZhY2V0ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybWVkVHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShmYWNldC5tYXh2YWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHJhbnNmb3JtZWRUeXBlID09PSAnY29udGludW91cycpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oZmFjZXQubWF4dmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFjZXQubWF4dmFsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FjaGU6IGZhbHNlXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgbWluaW11bSB2YWx1ZSB0aGlzIGZhY2V0IGNhbiB0YWtlLCBhZnRlciB0aGUgdHJhbnNmb3JtYXRpb24gaGFzIGJlZW4gYXBwbGllZFxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YhIER1cmF0aW9uVHJhbnNmb3JtXG4gICAgICovXG4gICAgdHJhbnNmb3JtZWRNaW5Bc1RleHQ6IHtcbiAgICAgIGRlcHM6IFsndHJhbnNmb3JtZWRNaW4nLCAndHJhbnNmb3JtZWRUeXBlJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWludmFsID0gdGhpcy50cmFuc2Zvcm1lZE1pbjtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtZWRUeXBlID09PSAnZGF0ZXRpbWUnKSB7XG4gICAgICAgICAgcmV0dXJuIG1pbnZhbC5mb3JtYXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbWludmFsLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWNoZTogZmFsc2VcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIHZhbHVlIHRoaXMgZmFjZXQgY2FuIHRha2UsIGFmdGVyIHRoZSB0cmFuc2Zvcm1hdGlvbiBoYXMgYmVlbiBhcHBsaWVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiEgRHVyYXRpb25UcmFuc2Zvcm1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1lZE1heEFzVGV4dDoge1xuICAgICAgZGVwczogWyd0cmFuc2Zvcm1lZE1heCcsICd0cmFuc2Zvcm1lZFR5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXh2YWwgPSB0aGlzLnRyYW5zZm9ybWVkTWF4O1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm1lZFR5cGUgPT09ICdkYXRldGltZScpIHtcbiAgICAgICAgICByZXR1cm4gbWF4dmFsLmZvcm1hdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtYXh2YWwudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhY2hlOiBmYWxzZVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQXBwbHkgdGhlIGNvbmZpZ3VyZWQgdHJhbnNmb3JtYXRpb24gdG8gdGhpcyBGYWNldCdzIHZhbHVlXG4gICAqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyb2YhIER1cmF0aW9uVHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnZhbCBtb21lbnRqcyBkdXJhdGlvblxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvdXR2YWwgbW9tZW50anMgZHVyYXRpb24gb3IgZGF0ZXRpbWVcbiAgICovXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtIChpbnZhbCkge1xuICAgIHZhciB1bml0cztcbiAgICBpZiAodGhpcy5yZWZlcmVuY2VNb21lbnQpIHtcbiAgICAgIC8vIGR1cmF0aW9uIC0+IGRhdGV0aW1lXG4gICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VNb21lbnQuY2xvbmUoKS5hZGQoaW52YWwpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50cmFuc2Zvcm1lZFVuaXRzICE9PSAnSVNPODYwMScpIHtcbiAgICAgIC8vIGR1cmF0aW9uIC0+IGNvbnRpbnVvdXNcbiAgICAgIHVuaXRzID0gdXRpbC5kdXJhdGlvblVuaXRzLmdldCh0aGlzLnRyYW5zZm9ybWVkVW5pdHMsICdkZXNjcmlwdGlvbicpLm1vbWVudEZvcm1hdDtcbiAgICAgIHJldHVybiBpbnZhbC5hcyh1bml0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vIGNoYW5nZVxuICAgICAgcmV0dXJuIGludmFsO1xuICAgIH1cbiAgfSxcbiAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnVuc2V0KFsnem9uZScsICd0cmFuc2Zvcm1lZEZvcm1hdCcsICd0cmFuc2Zvcm1lZFpvbmUnLCAndHJhbnNmb3JtZWRSZWZlcmVuY2UnXSk7XG4gIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///b123\n")},b452:function(module,exports,__webpack_require__){eval("\n/**\n * Module dependencies.\n */\n\nvar url = __webpack_require__(/*! ./url */ \"780f\");\nvar parser = __webpack_require__(/*! socket.io-parser */ \"6fba\");\nvar Manager = __webpack_require__(/*! ./manager */ \"1e1f\");\nvar debug = __webpack_require__(/*! debug */ \"433b\")('socket.io-client');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = lookup;\n\n/**\n * Managers cache.\n */\n\nvar cache = exports.managers = {};\n\n/**\n * Looks up an existing `Manager` for multiplexing.\n * If the user summons:\n *\n *   `io('http://localhost/a');`\n *   `io('http://localhost/b');`\n *\n * We reuse the existing instance based on same scheme/port/host,\n * and we initialize sockets for each namespace.\n *\n * @api public\n */\n\nfunction lookup (uri, opts) {\n  if (typeof uri === 'object') {\n    opts = uri;\n    uri = undefined;\n  }\n\n  opts = opts || {};\n\n  var parsed = url(uri);\n  var source = parsed.source;\n  var id = parsed.id;\n  var path = parsed.path;\n  var sameNamespace = cache[id] && path in cache[id].nsps;\n  var newConnection = opts.forceNew || opts['force new connection'] ||\n                      false === opts.multiplex || sameNamespace;\n\n  var io;\n\n  if (newConnection) {\n    debug('ignoring socket cache for %s', source);\n    io = Manager(source, opts);\n  } else {\n    if (!cache[id]) {\n      debug('new io instance for %s', source);\n      cache[id] = Manager(source, opts);\n    }\n    io = cache[id];\n  }\n  if (parsed.query && !opts.query) {\n    opts.query = parsed.query;\n  } else if (opts && 'object' === typeof opts.query) {\n    opts.query = encodeQueryString(opts.query);\n  }\n  return io.socket(parsed.path, opts);\n}\n/**\n *  Helper method to parse query objects to string.\n * @param {object} query\n * @returns {string}\n */\nfunction encodeQueryString (obj) {\n  var str = [];\n  for (var p in obj) {\n    if (obj.hasOwnProperty(p)) {\n      str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));\n    }\n  }\n  return str.join('&');\n}\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = parser.protocol;\n\n/**\n * `connect`.\n *\n * @param {String} uri\n * @api public\n */\n\nexports.connect = lookup;\n\n/**\n * Expose constructors for standalone build.\n *\n * @api public\n */\n\nexports.Manager = __webpack_require__(/*! ./manager */ \"1e1f\");\nexports.Socket = __webpack_require__(/*! ./socket */ \"4c13\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYjQ1Mi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvaW5kZXguanM/ZjQyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXJsID0gcmVxdWlyZSgnLi91cmwnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGxvb2t1cDtcblxuLyoqXG4gKiBNYW5hZ2VycyBjYWNoZS5cbiAqL1xuXG52YXIgY2FjaGUgPSBleHBvcnRzLm1hbmFnZXJzID0ge307XG5cbi8qKlxuICogTG9va3MgdXAgYW4gZXhpc3RpbmcgYE1hbmFnZXJgIGZvciBtdWx0aXBsZXhpbmcuXG4gKiBJZiB0aGUgdXNlciBzdW1tb25zOlxuICpcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2EnKTtgXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9iJyk7YFxuICpcbiAqIFdlIHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZSBiYXNlZCBvbiBzYW1lIHNjaGVtZS9wb3J0L2hvc3QsXG4gKiBhbmQgd2UgaW5pdGlhbGl6ZSBzb2NrZXRzIGZvciBlYWNoIG5hbWVzcGFjZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvb2t1cCAodXJpLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgdXJpID09PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHBhcnNlZCA9IHVybCh1cmkpO1xuICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcbiAgdmFyIGlkID0gcGFyc2VkLmlkO1xuICB2YXIgcGF0aCA9IHBhcnNlZC5wYXRoO1xuICB2YXIgc2FtZU5hbWVzcGFjZSA9IGNhY2hlW2lkXSAmJiBwYXRoIGluIGNhY2hlW2lkXS5uc3BzO1xuICB2YXIgbmV3Q29ubmVjdGlvbiA9IG9wdHMuZm9yY2VOZXcgfHwgb3B0c1snZm9yY2UgbmV3IGNvbm5lY3Rpb24nXSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGZhbHNlID09PSBvcHRzLm11bHRpcGxleCB8fCBzYW1lTmFtZXNwYWNlO1xuXG4gIHZhciBpbztcblxuICBpZiAobmV3Q29ubmVjdGlvbikge1xuICAgIGRlYnVnKCdpZ25vcmluZyBzb2NrZXQgY2FjaGUgZm9yICVzJywgc291cmNlKTtcbiAgICBpbyA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWNhY2hlW2lkXSkge1xuICAgICAgZGVidWcoJ25ldyBpbyBpbnN0YW5jZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgICAgY2FjaGVbaWRdID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICAgIH1cbiAgICBpbyA9IGNhY2hlW2lkXTtcbiAgfVxuICBpZiAocGFyc2VkLnF1ZXJ5ICYmICFvcHRzLnF1ZXJ5KSB7XG4gICAgb3B0cy5xdWVyeSA9IHBhcnNlZC5xdWVyeTtcbiAgfSBlbHNlIGlmIChvcHRzICYmICdvYmplY3QnID09PSB0eXBlb2Ygb3B0cy5xdWVyeSkge1xuICAgIG9wdHMucXVlcnkgPSBlbmNvZGVRdWVyeVN0cmluZyhvcHRzLnF1ZXJ5KTtcbiAgfVxuICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoLCBvcHRzKTtcbn1cbi8qKlxuICogIEhlbHBlciBtZXRob2QgdG8gcGFyc2UgcXVlcnkgb2JqZWN0cyB0byBzdHJpbmcuXG4gKiBAcGFyYW0ge29iamVjdH0gcXVlcnlcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZVF1ZXJ5U3RyaW5nIChvYmopIHtcbiAgdmFyIHN0ciA9IFtdO1xuICBmb3IgKHZhciBwIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgIHN0ci5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChwKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbcF0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0ci5qb2luKCcmJyk7XG59XG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sO1xuXG4vKipcbiAqIGBjb25uZWN0YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuY29ubmVjdCA9IGxvb2t1cDtcblxuLyoqXG4gKiBFeHBvc2UgY29uc3RydWN0b3JzIGZvciBzdGFuZGFsb25lIGJ1aWxkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5NYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2VyJyk7XG5leHBvcnRzLlNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///b452\n")},ba23:function(module,exports,__webpack_require__){eval("/**\n * Categorial Rule abstracts a single matching rule\n *\n * @class CategorialRule\n */\nvar Base = __webpack_require__(/*! ../util/base */ \"3902\");\n\n// Data structure for mapping categorial (and textual) data on groups\nmodule.exports = Base.extend({\n  props: {\n    /**\n     * string or string format of regexp to match data against.\n     * To use a regular expression, start and end the string with a slash, '/'.\n     * Options can be appedended, notably 'i' for case insensitive matching.\n     * The first captured group can be used in the group, see below.\n     * Examples\n     * 1. 'hello' matches 'hello', not 'hello world'\n     * 2. '/hello/' matches 'hello world', but not 'Hello world'\n     * 3. '/hello/i' matches 'I say Hello'\n     * @type {string}\n     * @memberof! CategorialRule\n     */\n    expression: ['string', true, 'Missing'],\n\n    /**\n     * Number of items this transform is used\n     * @type {number}\n     * @memberof! CategorialRule\n     */\n    count: ['number', true, 0],\n\n    /**\n     * Name of the group this is mapped to. The special substring $1 is replaced by the first captured group,\n     * in example 4 above, with group set to 'He says $1', the match results in 'He says goodbye'\n     * @type {string}\n     * @memberof! CategorialRule\n     */\n    group: ['string', true, 'Missing']\n  },\n  derived: {\n\n    /**\n     * Match function\n     * @memberof! CategorialRule\n     * @function\n     * @param {string} text The text to match\n     * @returns {string|false} group The group label if matching, else false\n     */\n    match: {\n      deps: ['expression', 'group'],\n      fn: function () {\n        var that = this;\n\n        var reFormat = new RegExp(/^\\/(.*)\\/([gimuy]*)$/);\n        var match = reFormat.exec(that.expression);\n\n        if (match) {\n          // if the expression is in the form of /<text>/<flags>, it is a regular expression, compile it\n          var exp = RegExp(match[1], match[2]);\n          return function (text) {\n            var m = exp.exec(text);\n            if (m) {\n              return that.group;\n              // return that.group.replace('$1', m[1]);\n            } else {\n              return false;\n            }\n          };\n        } else {\n          // otherwise do matching using '==='\n          return function (text) {\n            if (text === that.expression) {\n              return that.group;\n            } else {\n              return false;\n            }\n          };\n        }\n      }\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmEyMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmFjZXQvY2F0ZWdvcmlhbC1ydWxlLmpzP2UxNzMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDYXRlZ29yaWFsIFJ1bGUgYWJzdHJhY3RzIGEgc2luZ2xlIG1hdGNoaW5nIHJ1bGVcbiAqXG4gKiBAY2xhc3MgQ2F0ZWdvcmlhbFJ1bGVcbiAqL1xudmFyIEJhc2UgPSByZXF1aXJlKCcuLi91dGlsL2Jhc2UnKTtcblxuLy8gRGF0YSBzdHJ1Y3R1cmUgZm9yIG1hcHBpbmcgY2F0ZWdvcmlhbCAoYW5kIHRleHR1YWwpIGRhdGEgb24gZ3JvdXBzXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2UuZXh0ZW5kKHtcbiAgcHJvcHM6IHtcbiAgICAvKipcbiAgICAgKiBzdHJpbmcgb3Igc3RyaW5nIGZvcm1hdCBvZiByZWdleHAgdG8gbWF0Y2ggZGF0YSBhZ2FpbnN0LlxuICAgICAqIFRvIHVzZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgc3RhcnQgYW5kIGVuZCB0aGUgc3RyaW5nIHdpdGggYSBzbGFzaCwgJy8nLlxuICAgICAqIE9wdGlvbnMgY2FuIGJlIGFwcGVkZW5kZWQsIG5vdGFibHkgJ2knIGZvciBjYXNlIGluc2Vuc2l0aXZlIG1hdGNoaW5nLlxuICAgICAqIFRoZSBmaXJzdCBjYXB0dXJlZCBncm91cCBjYW4gYmUgdXNlZCBpbiB0aGUgZ3JvdXAsIHNlZSBiZWxvdy5cbiAgICAgKiBFeGFtcGxlc1xuICAgICAqIDEuICdoZWxsbycgbWF0Y2hlcyAnaGVsbG8nLCBub3QgJ2hlbGxvIHdvcmxkJ1xuICAgICAqIDIuICcvaGVsbG8vJyBtYXRjaGVzICdoZWxsbyB3b3JsZCcsIGJ1dCBub3QgJ0hlbGxvIHdvcmxkJ1xuICAgICAqIDMuICcvaGVsbG8vaScgbWF0Y2hlcyAnSSBzYXkgSGVsbG8nXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YhIENhdGVnb3JpYWxSdWxlXG4gICAgICovXG4gICAgZXhwcmVzc2lvbjogWydzdHJpbmcnLCB0cnVlLCAnTWlzc2luZyddLFxuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGl0ZW1zIHRoaXMgdHJhbnNmb3JtIGlzIHVzZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiEgQ2F0ZWdvcmlhbFJ1bGVcbiAgICAgKi9cbiAgICBjb3VudDogWydudW1iZXInLCB0cnVlLCAwXSxcblxuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIGdyb3VwIHRoaXMgaXMgbWFwcGVkIHRvLiBUaGUgc3BlY2lhbCBzdWJzdHJpbmcgJDEgaXMgcmVwbGFjZWQgYnkgdGhlIGZpcnN0IGNhcHR1cmVkIGdyb3VwLFxuICAgICAqIGluIGV4YW1wbGUgNCBhYm92ZSwgd2l0aCBncm91cCBzZXQgdG8gJ0hlIHNheXMgJDEnLCB0aGUgbWF0Y2ggcmVzdWx0cyBpbiAnSGUgc2F5cyBnb29kYnllJ1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mISBDYXRlZ29yaWFsUnVsZVxuICAgICAqL1xuICAgIGdyb3VwOiBbJ3N0cmluZycsIHRydWUsICdNaXNzaW5nJ11cbiAgfSxcbiAgZGVyaXZlZDoge1xuXG4gICAgLyoqXG4gICAgICogTWF0Y2ggZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YhIENhdGVnb3JpYWxSdWxlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gbWF0Y2hcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfGZhbHNlfSBncm91cCBUaGUgZ3JvdXAgbGFiZWwgaWYgbWF0Y2hpbmcsIGVsc2UgZmFsc2VcbiAgICAgKi9cbiAgICBtYXRjaDoge1xuICAgICAgZGVwczogWydleHByZXNzaW9uJywgJ2dyb3VwJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHJlRm9ybWF0ID0gbmV3IFJlZ0V4cCgvXlxcLyguKilcXC8oW2dpbXV5XSopJC8pO1xuICAgICAgICB2YXIgbWF0Y2ggPSByZUZvcm1hdC5leGVjKHRoYXQuZXhwcmVzc2lvbik7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGV4cHJlc3Npb24gaXMgaW4gdGhlIGZvcm0gb2YgLzx0ZXh0Pi88ZmxhZ3M+LCBpdCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgY29tcGlsZSBpdFxuICAgICAgICAgIHZhciBleHAgPSBSZWdFeHAobWF0Y2hbMV0sIG1hdGNoWzJdKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgIHZhciBtID0gZXhwLmV4ZWModGV4dCk7XG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhhdC5ncm91cDtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoYXQuZ3JvdXAucmVwbGFjZSgnJDEnLCBtWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSBkbyBtYXRjaGluZyB1c2luZyAnPT09J1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgaWYgKHRleHQgPT09IHRoYXQuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gdGhhdC5ncm91cDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///ba23\n")},bb16:function(module,exports,__webpack_require__){eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"1ed2\");\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmIxNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvZGVidWcvZGVidWcuanM/NTJhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyY2FzZWQgbGV0dGVyLCBpLmUuIFwiblwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzbHkgYXNzaWduZWQgY29sb3IuXG4gKi9cblxudmFyIHByZXZDb2xvciA9IDA7XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IoKSB7XG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1twcmV2Q29sb3IrKyAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSkge1xuXG4gIC8vIGRlZmluZSB0aGUgYGRpc2FibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGRpc2FibGVkKCkge1xuICB9XG4gIGRpc2FibGVkLmVuYWJsZWQgPSBmYWxzZTtcblxuICAvLyBkZWZpbmUgdGhlIGBlbmFibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG5cbiAgICB2YXIgc2VsZiA9IGVuYWJsZWQ7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIGFkZCB0aGUgYGNvbG9yYCBpZiBub3Qgc2V0XG4gICAgaWYgKG51bGwgPT0gc2VsZi51c2VDb2xvcnMpIHNlbGYudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgICBpZiAobnVsbCA9PSBzZWxmLmNvbG9yICYmIHNlbGYudXNlQ29sb3JzKSBzZWxmLmNvbG9yID0gc2VsZWN0Q29sb3IoKTtcblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVvXG4gICAgICBhcmdzID0gWyclbyddLmNvbmNhdChhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16JV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmZvcm1hdEFyZ3MpIHtcbiAgICAgIGFyZ3MgPSBleHBvcnRzLmZvcm1hdEFyZ3MuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuICAgIHZhciBsb2dGbiA9IGVuYWJsZWQubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbiAgZW5hYmxlZC5lbmFibGVkID0gdHJ1ZTtcblxuICB2YXIgZm4gPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKSA/IGVuYWJsZWQgOiBkaXNhYmxlZDtcblxuICBmbi5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIHZhciBzcGxpdCA9IChuYW1lc3BhY2VzIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///bb16\n")},bff6:function(module,exports){eval("/**\n * This module defines a single unique missing value indicator.\n * All invalid, absent, or user-indicated missing value is internally set to this value.\n *\n * @example\n * var misval = require('./framework/misval');\n * if ( a === misval ) {\n *   ...\n * }\n * @module client/misval\n */\n\n// module.exports = -Number.MAX_VALUE;\nmodule.exports = 'missing';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmZmNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvdXRpbC9taXN2YWwuanM/YjI3OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgbW9kdWxlIGRlZmluZXMgYSBzaW5nbGUgdW5pcXVlIG1pc3NpbmcgdmFsdWUgaW5kaWNhdG9yLlxuICogQWxsIGludmFsaWQsIGFic2VudCwgb3IgdXNlci1pbmRpY2F0ZWQgbWlzc2luZyB2YWx1ZSBpcyBpbnRlcm5hbGx5IHNldCB0byB0aGlzIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgbWlzdmFsID0gcmVxdWlyZSgnLi9mcmFtZXdvcmsvbWlzdmFsJyk7XG4gKiBpZiAoIGEgPT09IG1pc3ZhbCApIHtcbiAqICAgLi4uXG4gKiB9XG4gKiBAbW9kdWxlIGNsaWVudC9taXN2YWxcbiAqL1xuXG4vLyBtb2R1bGUuZXhwb3J0cyA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xubW9kdWxlLmV4cG9ydHMgPSAnbWlzc2luZyc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///bff6\n")},c59b:function(module,exports,__webpack_require__){eval('\nmodule.exports = __webpack_require__(/*! ./lib/index */ "58ab");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYzU5Yi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9pbmRleC5qcz80NmEyIl0sInNvdXJjZXNDb250ZW50IjpbIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9pbmRleCcpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///c59b\n')},d45b:function(module,exports,__webpack_require__){eval("var AmpersandModel = __webpack_require__(/*! ampersand-model */ \"3bfc\");\nvar AmpersandColllection = __webpack_require__(/*! ampersand-collection */ \"7bd3\");\nvar moment = __webpack_require__(/*! moment-timezone */ \"6c9d\");\n\n/*\n * Time is grouped by truncating; the resolution is determined in util-time.getResolution()\n * See [this table](http://momentjs.com/docs/#/durations/creating/) for accpetable values\n * when using a crossfilter dataset.\n */\nfunction unitsForMilliseconds (milliseconds) {\n  var count = milliseconds;\n  if (count < 10000) { // 10 seconds\n    return 'milliseconds';\n  }\n  count = count / 1000;\n\n  if (count < 15 * 60) { // 15 minutes\n    return 'seconds';\n  }\n  count = count / 60;\n\n  if (count < 3 * 60) { // 3 hours\n    return 'minutes';\n  }\n  count = count / 60;\n\n  if (count < 3 * 24) { // 3 days\n    return 'hours';\n  }\n  count = count / 24;\n\n  if (count < 3 * 7) { // 3 weeks\n    return 'days';\n  }\n  if (count < 7 * 52) { // 52 weeks\n    return 'weeks';\n  }\n  if (count < 2 * 365) { // 2 years\n    return 'months';\n  }\n  return 'years';\n}\n\nfunction getFormat (units) {\n  var fmt;\n  if (units === 'seconds') {\n    fmt = 'mm:ss';\n  } else if (units === 'minutes') {\n    fmt = 'HH:mm';\n  } else if (units === 'hours') {\n    fmt = 'HH:00';\n  } else if (units === 'days') {\n    fmt = 'dddd do';\n  } else if (units === 'weeks') {\n    fmt = 'wo';\n  } else if (units === 'months') {\n    fmt = 'YY MMM';\n  } else if (units === 'years') {\n    fmt = 'YYYY';\n  }\n  return fmt;\n}\n\nfunction getDatetimeResolution (start, end) {\n  var difference = end.diff(start);\n  return unitsForMilliseconds(difference);\n}\n\nfunction getDurationResolution (min, max) {\n  var length = moment.duration(max.as('milliseconds') - min.as('milliseconds'), 'milliseconds');\n  return unitsForMilliseconds(length);\n}\n\nvar TimePart = AmpersandModel.extend({\n  props: {\n    /**\n     * The format string for momentjs\n     * @memberof! TimePart\n     * @type {string}\n     */\n    momentFormat: ['string', true],\n    /**\n     * The format string for postgresql\n     * @memberof! TimePart\n     * @type {string}\n     */\n    postgresFormat: ['string', true],\n    /**\n     * The human readable descprition of the datetime part\n     * @memberof! TimePart\n     * @type {string}\n     */\n    description: ['string', true],\n    /**\n     * Data type after conversion: 'continuous', or 'categorial'\n     * @memberof! TimePart\n     * @type {string}\n     */\n    type: ['string', true],\n    /**\n     * For continuous datetime parts (ie, day-of-year), the minimum value\n     * @memberof! TimePart\n     * @type {number}\n     */\n    min: ['number', true, 0],\n    /**\n     * For continuous datetime parts (ie, day-of-year), the maximum value\n     * @memberof! TimePart\n     * @type {number}\n     */\n    max: ['number', true, 1],\n    /**\n     * When true, calculate the minimum and maximum value from the\n     * original datetime limits. Used for continuous datetime parts (ie, year)\n     * @memberof! TimePart\n     * @type {boolean}\n     */\n    calculate: ['boolean', true, false],\n    /**\n     * For categorial datetime parts (Mon, Tue, ..), the array of possible values\n     * @memberof! TimePart\n     * @type {String[]}\n     */\n    groups: ['array']\n  }\n});\n\nvar TimeParts = AmpersandColllection.extend({\n  model: TimePart,\n  indexes: ['description']\n});\n\nvar timeParts = new TimeParts([\n  { description: 'ISO8601', type: 'datetime', calculate: true },\n  { postgresFormat: 'month', momentFormat: 'M', description: 'Month (1-12)', type: 'continuous', min: 1, max: 12 },\n  { postgresFormat: 'quarter', momentFormat: 'Q', description: 'Quarter (1-4)', type: 'continuous', min: 1, max: 4 },\n  { postgresFormat: 'day', momentFormat: 'D', description: 'Day of Month  (1-31)', type: 'continuous', min: 1, max: 31 },\n  { postgresFormat: 'doy', momentFormat: 'DDD', description: 'Day of Year (1-365)', type: 'continuous', min: 1, max: 365 },\n  { postgresFormat: 'dow', momentFormat: 'd', description: 'Day of Week (0-6)', type: 'continuous', min: 0, max: 6 },\n  { postgresFormat: 'isodow', momentFormat: 'E', description: 'Day of Week ISO (1-7)', type: 'continuous', min: 1, max: 7 },\n  { postgresFormat: 'week', momentFormat: 'W', description: 'Week of Year ISO  (1-53)', type: 'continuous', min: 1, max: 53 },\n  { postgresFormat: 'year', momentFormat: 'Y', description: 'Year', type: 'continuous', calculate: true },\n  { postgresFormat: 'hours', momentFormat: 'H', description: 'Hour (0-23)', type: 'continuous', min: 0, max: 23 },\n  { postgresFormat: 'minute', momentFormat: 'm', description: 'Minute (0-59)', type: 'continuous', min: 0, max: 59 },\n  { postgresFormat: 'second', momentFormat: 's', description: 'Second (0-59)', type: 'continuous', min: 0, max: 59 },\n  { postgresFormat: 'milliseconds', momentFormat: 'SSS', description: 'Milliseconds (0-999)', type: 'continuous', min: 0, max: 999 },\n  { postgresFormat: 'microseconds', momentFormat: 'SSSSSS', description: 'microseconds (0-999999)', type: 'continuous', min: 0, max: 999999 },\n  { postgresFormat: 'epoch', momentFormat: 'X', description: 'Unix Timestamp', type: 'continuous', calculate: true },\n  { postgresFormat: 'Mon', momentFormat: 'MMM', description: 'Month (Jan - Dec)', type: 'categorial', groups: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] },\n  { postgresFormat: 'Month', momentFormat: 'MMMM', description: 'Month (January - December)', type: 'categorial', groups: ['January', 'Feburary', 'March', 'April', 'May', 'June', 'July', 'August', 'Septebmer', 'October', 'November', 'December'] },\n  { postgresFormat: 'Dy', momentFormat: 'ddd', description: 'Day of Week (Sun-Sat)', type: 'categorial', groups: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'] },\n  { postgresFormat: 'Day', momentFormat: 'dddd', description: 'Day of Week (Sunday-Saturday)', type: 'categorial', groups: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'] },\n  { postgresFormat: 'AM', momentFormat: 'A', description: 'AM/PM', type: 'categorial', groups: ['AM', 'PM'] }\n]);\n\nvar DurationUnit = AmpersandModel.extend({\n  props: {\n    /**\n     * The descriptive name of the time unit\n     * @memberof! DurationUnit\n     * @type {string}\n     */\n    description: ['string'],\n    /**\n     * Momentjs parsing format\n     * @memberof! DurationUnit\n     * @type {string}\n     */\n    momentFormat: ['string'],\n    /**\n     * Postgres parsing format\n     * @memberof! DurationUnit\n     * @type {string}\n     */\n    postgresFormat: ['string'],\n    /**\n     * Conversion factor to seconds\n     * @memberof! DurationUnit\n     * @type {string}\n     */\n    seconds: ['number']\n  }\n});\n\nvar DurationUnits = AmpersandColllection.extend({\n  indexes: ['description'],\n  model: DurationUnit\n});\n\nvar durationUnits = new DurationUnits([\n  {\n    description: 'ISO8601',\n    seconds: 1\n  }, {\n    description: 'millenium',\n    momentFormat: 'millenium',\n    postgresFormat: 'millenium',\n    seconds: 100 * 365.25 * 24 * 60 * 60\n  }, {\n    description: 'century',\n    momentFormat: 'century',\n    postgresFormat: 'century',\n    seconds: 100 * 365.25 * 24 * 60 * 60\n  }, {\n    description: 'decades',\n    momentFormat: 'decades',\n    postgresFormat: 'decade',\n    seconds: 10 * 365.25 * 24 * 60 * 60\n  }, {\n    description: 'years',\n    momentFormat: 'years',\n    postgresFormat: 'year',\n    seconds: 365.25 * 24 * 60 * 60\n  }, {\n    description: 'quarters',\n    momentFormat: '',\n    postgresFormat: 'quarter',\n    seconds: 365.25 * 8 * 60 * 60\n  }, {\n    description: 'months',\n    momentFormat: 'months',\n    postgresFormat: 'month',\n    seconds: 30 * 24 * 60 * 60\n  }, {\n    description: 'weeks',\n    momentFormat: 'weeks',\n    postgresFormat: 'week',\n    seconds: 7 * 24 * 60 * 60\n  }, {\n    description: 'days',\n    momentFormat: 'days',\n    postgresFormat: 'day',\n    seconds: 24 * 60 * 60\n  }, {\n    description: 'hours',\n    momentFormat: 'hours',\n    postgresFormat: 'hour',\n    seconds: 60 * 60\n  }, {\n    description: 'minutes',\n    momentFormat: 'minutes',\n    postgresFormat: 'minute',\n    seconds: 60\n  }, {\n    description: 'seconds',\n    momentFormat: 'seconds',\n    postgresFormat: 'second',\n    seconds: 1\n  }, {\n    description: 'milliseconds',\n    momentFormat: 'milliseconds',\n    postgresFormat: 'milliseconds',\n    seconds: 0.001\n  }, {\n    description: 'microseconds',\n    momentFormat: 'microseconds',\n    postgresFormat: 'microseconds',\n    seconds: 0.000001\n  }\n]);\n\nvar TimeZone = AmpersandModel.extend({\n  props: {\n    /**\n     * The descriptive name of the time zone\n     * @memberof! TimeZone\n     * @type {string}\n     */\n    description: ['string'],\n    /**\n     * The time zone format\n     * @memberof! TimeZone\n     * @type {string}\n     */\n    format: ['string']\n  }\n});\n\nvar TimeZones = AmpersandColllection.extend({\n  indexes: ['description'],\n  model: TimeZone\n});\n\nvar timeZones = new TimeZones();\ntimeZones.add({\n  description: 'ISO8601',\n  format: 'ISO8601'\n});\n\nmoment.tz.names().forEach(function (tz) {\n  timeZones.add({\n    description: tz,\n    format: tz\n  });\n});\n\nmodule.exports = {\n  timeParts: timeParts,\n  timeZones: timeZones,\n  durationUnits: durationUnits,\n  getDatetimeResolution: getDatetimeResolution,\n  getDurationResolution: getDurationResolution,\n  getFormat: getFormat\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZDQ1Yi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvdXRpbC90aW1lLmpzP2ExMzkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEFtcGVyc2FuZE1vZGVsID0gcmVxdWlyZSgnYW1wZXJzYW5kLW1vZGVsJyk7XG52YXIgQW1wZXJzYW5kQ29sbGxlY3Rpb24gPSByZXF1aXJlKCdhbXBlcnNhbmQtY29sbGVjdGlvbicpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudC10aW1lem9uZScpO1xuXG4vKlxuICogVGltZSBpcyBncm91cGVkIGJ5IHRydW5jYXRpbmc7IHRoZSByZXNvbHV0aW9uIGlzIGRldGVybWluZWQgaW4gdXRpbC10aW1lLmdldFJlc29sdXRpb24oKVxuICogU2VlIFt0aGlzIHRhYmxlXShodHRwOi8vbW9tZW50anMuY29tL2RvY3MvIy9kdXJhdGlvbnMvY3JlYXRpbmcvKSBmb3IgYWNjcGV0YWJsZSB2YWx1ZXNcbiAqIHdoZW4gdXNpbmcgYSBjcm9zc2ZpbHRlciBkYXRhc2V0LlxuICovXG5mdW5jdGlvbiB1bml0c0Zvck1pbGxpc2Vjb25kcyAobWlsbGlzZWNvbmRzKSB7XG4gIHZhciBjb3VudCA9IG1pbGxpc2Vjb25kcztcbiAgaWYgKGNvdW50IDwgMTAwMDApIHsgLy8gMTAgc2Vjb25kc1xuICAgIHJldHVybiAnbWlsbGlzZWNvbmRzJztcbiAgfVxuICBjb3VudCA9IGNvdW50IC8gMTAwMDtcblxuICBpZiAoY291bnQgPCAxNSAqIDYwKSB7IC8vIDE1IG1pbnV0ZXNcbiAgICByZXR1cm4gJ3NlY29uZHMnO1xuICB9XG4gIGNvdW50ID0gY291bnQgLyA2MDtcblxuICBpZiAoY291bnQgPCAzICogNjApIHsgLy8gMyBob3Vyc1xuICAgIHJldHVybiAnbWludXRlcyc7XG4gIH1cbiAgY291bnQgPSBjb3VudCAvIDYwO1xuXG4gIGlmIChjb3VudCA8IDMgKiAyNCkgeyAvLyAzIGRheXNcbiAgICByZXR1cm4gJ2hvdXJzJztcbiAgfVxuICBjb3VudCA9IGNvdW50IC8gMjQ7XG5cbiAgaWYgKGNvdW50IDwgMyAqIDcpIHsgLy8gMyB3ZWVrc1xuICAgIHJldHVybiAnZGF5cyc7XG4gIH1cbiAgaWYgKGNvdW50IDwgNyAqIDUyKSB7IC8vIDUyIHdlZWtzXG4gICAgcmV0dXJuICd3ZWVrcyc7XG4gIH1cbiAgaWYgKGNvdW50IDwgMiAqIDM2NSkgeyAvLyAyIHllYXJzXG4gICAgcmV0dXJuICdtb250aHMnO1xuICB9XG4gIHJldHVybiAneWVhcnMnO1xufVxuXG5mdW5jdGlvbiBnZXRGb3JtYXQgKHVuaXRzKSB7XG4gIHZhciBmbXQ7XG4gIGlmICh1bml0cyA9PT0gJ3NlY29uZHMnKSB7XG4gICAgZm10ID0gJ21tOnNzJztcbiAgfSBlbHNlIGlmICh1bml0cyA9PT0gJ21pbnV0ZXMnKSB7XG4gICAgZm10ID0gJ0hIOm1tJztcbiAgfSBlbHNlIGlmICh1bml0cyA9PT0gJ2hvdXJzJykge1xuICAgIGZtdCA9ICdISDowMCc7XG4gIH0gZWxzZSBpZiAodW5pdHMgPT09ICdkYXlzJykge1xuICAgIGZtdCA9ICdkZGRkIGRvJztcbiAgfSBlbHNlIGlmICh1bml0cyA9PT0gJ3dlZWtzJykge1xuICAgIGZtdCA9ICd3byc7XG4gIH0gZWxzZSBpZiAodW5pdHMgPT09ICdtb250aHMnKSB7XG4gICAgZm10ID0gJ1lZIE1NTSc7XG4gIH0gZWxzZSBpZiAodW5pdHMgPT09ICd5ZWFycycpIHtcbiAgICBmbXQgPSAnWVlZWSc7XG4gIH1cbiAgcmV0dXJuIGZtdDtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZXRpbWVSZXNvbHV0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBkaWZmZXJlbmNlID0gZW5kLmRpZmYoc3RhcnQpO1xuICByZXR1cm4gdW5pdHNGb3JNaWxsaXNlY29uZHMoZGlmZmVyZW5jZSk7XG59XG5cbmZ1bmN0aW9uIGdldER1cmF0aW9uUmVzb2x1dGlvbiAobWluLCBtYXgpIHtcbiAgdmFyIGxlbmd0aCA9IG1vbWVudC5kdXJhdGlvbihtYXguYXMoJ21pbGxpc2Vjb25kcycpIC0gbWluLmFzKCdtaWxsaXNlY29uZHMnKSwgJ21pbGxpc2Vjb25kcycpO1xuICByZXR1cm4gdW5pdHNGb3JNaWxsaXNlY29uZHMobGVuZ3RoKTtcbn1cblxudmFyIFRpbWVQYXJ0ID0gQW1wZXJzYW5kTW9kZWwuZXh0ZW5kKHtcbiAgcHJvcHM6IHtcbiAgICAvKipcbiAgICAgKiBUaGUgZm9ybWF0IHN0cmluZyBmb3IgbW9tZW50anNcbiAgICAgKiBAbWVtYmVyb2YhIFRpbWVQYXJ0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBtb21lbnRGb3JtYXQ6IFsnc3RyaW5nJywgdHJ1ZV0sXG4gICAgLyoqXG4gICAgICogVGhlIGZvcm1hdCBzdHJpbmcgZm9yIHBvc3RncmVzcWxcbiAgICAgKiBAbWVtYmVyb2YhIFRpbWVQYXJ0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBwb3N0Z3Jlc0Zvcm1hdDogWydzdHJpbmcnLCB0cnVlXSxcbiAgICAvKipcbiAgICAgKiBUaGUgaHVtYW4gcmVhZGFibGUgZGVzY3ByaXRpb24gb2YgdGhlIGRhdGV0aW1lIHBhcnRcbiAgICAgKiBAbWVtYmVyb2YhIFRpbWVQYXJ0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBkZXNjcmlwdGlvbjogWydzdHJpbmcnLCB0cnVlXSxcbiAgICAvKipcbiAgICAgKiBEYXRhIHR5cGUgYWZ0ZXIgY29udmVyc2lvbjogJ2NvbnRpbnVvdXMnLCBvciAnY2F0ZWdvcmlhbCdcbiAgICAgKiBAbWVtYmVyb2YhIFRpbWVQYXJ0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0eXBlOiBbJ3N0cmluZycsIHRydWVdLFxuICAgIC8qKlxuICAgICAqIEZvciBjb250aW51b3VzIGRhdGV0aW1lIHBhcnRzIChpZSwgZGF5LW9mLXllYXIpLCB0aGUgbWluaW11bSB2YWx1ZVxuICAgICAqIEBtZW1iZXJvZiEgVGltZVBhcnRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIG1pbjogWydudW1iZXInLCB0cnVlLCAwXSxcbiAgICAvKipcbiAgICAgKiBGb3IgY29udGludW91cyBkYXRldGltZSBwYXJ0cyAoaWUsIGRheS1vZi15ZWFyKSwgdGhlIG1heGltdW0gdmFsdWVcbiAgICAgKiBAbWVtYmVyb2YhIFRpbWVQYXJ0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBtYXg6IFsnbnVtYmVyJywgdHJ1ZSwgMV0sXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBjYWxjdWxhdGUgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWUgZnJvbSB0aGVcbiAgICAgKiBvcmlnaW5hbCBkYXRldGltZSBsaW1pdHMuIFVzZWQgZm9yIGNvbnRpbnVvdXMgZGF0ZXRpbWUgcGFydHMgKGllLCB5ZWFyKVxuICAgICAqIEBtZW1iZXJvZiEgVGltZVBhcnRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjYWxjdWxhdGU6IFsnYm9vbGVhbicsIHRydWUsIGZhbHNlXSxcbiAgICAvKipcbiAgICAgKiBGb3IgY2F0ZWdvcmlhbCBkYXRldGltZSBwYXJ0cyAoTW9uLCBUdWUsIC4uKSwgdGhlIGFycmF5IG9mIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIEBtZW1iZXJvZiEgVGltZVBhcnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nW119XG4gICAgICovXG4gICAgZ3JvdXBzOiBbJ2FycmF5J11cbiAgfVxufSk7XG5cbnZhciBUaW1lUGFydHMgPSBBbXBlcnNhbmRDb2xsbGVjdGlvbi5leHRlbmQoe1xuICBtb2RlbDogVGltZVBhcnQsXG4gIGluZGV4ZXM6IFsnZGVzY3JpcHRpb24nXVxufSk7XG5cbnZhciB0aW1lUGFydHMgPSBuZXcgVGltZVBhcnRzKFtcbiAgeyBkZXNjcmlwdGlvbjogJ0lTTzg2MDEnLCB0eXBlOiAnZGF0ZXRpbWUnLCBjYWxjdWxhdGU6IHRydWUgfSxcbiAgeyBwb3N0Z3Jlc0Zvcm1hdDogJ21vbnRoJywgbW9tZW50Rm9ybWF0OiAnTScsIGRlc2NyaXB0aW9uOiAnTW9udGggKDEtMTIpJywgdHlwZTogJ2NvbnRpbnVvdXMnLCBtaW46IDEsIG1heDogMTIgfSxcbiAgeyBwb3N0Z3Jlc0Zvcm1hdDogJ3F1YXJ0ZXInLCBtb21lbnRGb3JtYXQ6ICdRJywgZGVzY3JpcHRpb246ICdRdWFydGVyICgxLTQpJywgdHlwZTogJ2NvbnRpbnVvdXMnLCBtaW46IDEsIG1heDogNCB9LFxuICB7IHBvc3RncmVzRm9ybWF0OiAnZGF5JywgbW9tZW50Rm9ybWF0OiAnRCcsIGRlc2NyaXB0aW9uOiAnRGF5IG9mIE1vbnRoICAoMS0zMSknLCB0eXBlOiAnY29udGludW91cycsIG1pbjogMSwgbWF4OiAzMSB9LFxuICB7IHBvc3RncmVzRm9ybWF0OiAnZG95JywgbW9tZW50Rm9ybWF0OiAnREREJywgZGVzY3JpcHRpb246ICdEYXkgb2YgWWVhciAoMS0zNjUpJywgdHlwZTogJ2NvbnRpbnVvdXMnLCBtaW46IDEsIG1heDogMzY1IH0sXG4gIHsgcG9zdGdyZXNGb3JtYXQ6ICdkb3cnLCBtb21lbnRGb3JtYXQ6ICdkJywgZGVzY3JpcHRpb246ICdEYXkgb2YgV2VlayAoMC02KScsIHR5cGU6ICdjb250aW51b3VzJywgbWluOiAwLCBtYXg6IDYgfSxcbiAgeyBwb3N0Z3Jlc0Zvcm1hdDogJ2lzb2RvdycsIG1vbWVudEZvcm1hdDogJ0UnLCBkZXNjcmlwdGlvbjogJ0RheSBvZiBXZWVrIElTTyAoMS03KScsIHR5cGU6ICdjb250aW51b3VzJywgbWluOiAxLCBtYXg6IDcgfSxcbiAgeyBwb3N0Z3Jlc0Zvcm1hdDogJ3dlZWsnLCBtb21lbnRGb3JtYXQ6ICdXJywgZGVzY3JpcHRpb246ICdXZWVrIG9mIFllYXIgSVNPICAoMS01MyknLCB0eXBlOiAnY29udGludW91cycsIG1pbjogMSwgbWF4OiA1MyB9LFxuICB7IHBvc3RncmVzRm9ybWF0OiAneWVhcicsIG1vbWVudEZvcm1hdDogJ1knLCBkZXNjcmlwdGlvbjogJ1llYXInLCB0eXBlOiAnY29udGludW91cycsIGNhbGN1bGF0ZTogdHJ1ZSB9LFxuICB7IHBvc3RncmVzRm9ybWF0OiAnaG91cnMnLCBtb21lbnRGb3JtYXQ6ICdIJywgZGVzY3JpcHRpb246ICdIb3VyICgwLTIzKScsIHR5cGU6ICdjb250aW51b3VzJywgbWluOiAwLCBtYXg6IDIzIH0sXG4gIHsgcG9zdGdyZXNGb3JtYXQ6ICdtaW51dGUnLCBtb21lbnRGb3JtYXQ6ICdtJywgZGVzY3JpcHRpb246ICdNaW51dGUgKDAtNTkpJywgdHlwZTogJ2NvbnRpbnVvdXMnLCBtaW46IDAsIG1heDogNTkgfSxcbiAgeyBwb3N0Z3Jlc0Zvcm1hdDogJ3NlY29uZCcsIG1vbWVudEZvcm1hdDogJ3MnLCBkZXNjcmlwdGlvbjogJ1NlY29uZCAoMC01OSknLCB0eXBlOiAnY29udGludW91cycsIG1pbjogMCwgbWF4OiA1OSB9LFxuICB7IHBvc3RncmVzRm9ybWF0OiAnbWlsbGlzZWNvbmRzJywgbW9tZW50Rm9ybWF0OiAnU1NTJywgZGVzY3JpcHRpb246ICdNaWxsaXNlY29uZHMgKDAtOTk5KScsIHR5cGU6ICdjb250aW51b3VzJywgbWluOiAwLCBtYXg6IDk5OSB9LFxuICB7IHBvc3RncmVzRm9ybWF0OiAnbWljcm9zZWNvbmRzJywgbW9tZW50Rm9ybWF0OiAnU1NTU1NTJywgZGVzY3JpcHRpb246ICdtaWNyb3NlY29uZHMgKDAtOTk5OTk5KScsIHR5cGU6ICdjb250aW51b3VzJywgbWluOiAwLCBtYXg6IDk5OTk5OSB9LFxuICB7IHBvc3RncmVzRm9ybWF0OiAnZXBvY2gnLCBtb21lbnRGb3JtYXQ6ICdYJywgZGVzY3JpcHRpb246ICdVbml4IFRpbWVzdGFtcCcsIHR5cGU6ICdjb250aW51b3VzJywgY2FsY3VsYXRlOiB0cnVlIH0sXG4gIHsgcG9zdGdyZXNGb3JtYXQ6ICdNb24nLCBtb21lbnRGb3JtYXQ6ICdNTU0nLCBkZXNjcmlwdGlvbjogJ01vbnRoIChKYW4gLSBEZWMpJywgdHlwZTogJ2NhdGVnb3JpYWwnLCBncm91cHM6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSB9LFxuICB7IHBvc3RncmVzRm9ybWF0OiAnTW9udGgnLCBtb21lbnRGb3JtYXQ6ICdNTU1NJywgZGVzY3JpcHRpb246ICdNb250aCAoSmFudWFyeSAtIERlY2VtYmVyKScsIHR5cGU6ICdjYXRlZ29yaWFsJywgZ3JvdXBzOiBbJ0phbnVhcnknLCAnRmVidXJhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVibWVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXSB9LFxuICB7IHBvc3RncmVzRm9ybWF0OiAnRHknLCBtb21lbnRGb3JtYXQ6ICdkZGQnLCBkZXNjcmlwdGlvbjogJ0RheSBvZiBXZWVrIChTdW4tU2F0KScsIHR5cGU6ICdjYXRlZ29yaWFsJywgZ3JvdXBzOiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddIH0sXG4gIHsgcG9zdGdyZXNGb3JtYXQ6ICdEYXknLCBtb21lbnRGb3JtYXQ6ICdkZGRkJywgZGVzY3JpcHRpb246ICdEYXkgb2YgV2VlayAoU3VuZGF5LVNhdHVyZGF5KScsIHR5cGU6ICdjYXRlZ29yaWFsJywgZ3JvdXBzOiBbJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknLCAnU3VuZGF5J10gfSxcbiAgeyBwb3N0Z3Jlc0Zvcm1hdDogJ0FNJywgbW9tZW50Rm9ybWF0OiAnQScsIGRlc2NyaXB0aW9uOiAnQU0vUE0nLCB0eXBlOiAnY2F0ZWdvcmlhbCcsIGdyb3VwczogWydBTScsICdQTSddIH1cbl0pO1xuXG52YXIgRHVyYXRpb25Vbml0ID0gQW1wZXJzYW5kTW9kZWwuZXh0ZW5kKHtcbiAgcHJvcHM6IHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVzY3JpcHRpdmUgbmFtZSBvZiB0aGUgdGltZSB1bml0XG4gICAgICogQG1lbWJlcm9mISBEdXJhdGlvblVuaXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGRlc2NyaXB0aW9uOiBbJ3N0cmluZyddLFxuICAgIC8qKlxuICAgICAqIE1vbWVudGpzIHBhcnNpbmcgZm9ybWF0XG4gICAgICogQG1lbWJlcm9mISBEdXJhdGlvblVuaXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIG1vbWVudEZvcm1hdDogWydzdHJpbmcnXSxcbiAgICAvKipcbiAgICAgKiBQb3N0Z3JlcyBwYXJzaW5nIGZvcm1hdFxuICAgICAqIEBtZW1iZXJvZiEgRHVyYXRpb25Vbml0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBwb3N0Z3Jlc0Zvcm1hdDogWydzdHJpbmcnXSxcbiAgICAvKipcbiAgICAgKiBDb252ZXJzaW9uIGZhY3RvciB0byBzZWNvbmRzXG4gICAgICogQG1lbWJlcm9mISBEdXJhdGlvblVuaXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHNlY29uZHM6IFsnbnVtYmVyJ11cbiAgfVxufSk7XG5cbnZhciBEdXJhdGlvblVuaXRzID0gQW1wZXJzYW5kQ29sbGxlY3Rpb24uZXh0ZW5kKHtcbiAgaW5kZXhlczogWydkZXNjcmlwdGlvbiddLFxuICBtb2RlbDogRHVyYXRpb25Vbml0XG59KTtcblxudmFyIGR1cmF0aW9uVW5pdHMgPSBuZXcgRHVyYXRpb25Vbml0cyhbXG4gIHtcbiAgICBkZXNjcmlwdGlvbjogJ0lTTzg2MDEnLFxuICAgIHNlY29uZHM6IDFcbiAgfSwge1xuICAgIGRlc2NyaXB0aW9uOiAnbWlsbGVuaXVtJyxcbiAgICBtb21lbnRGb3JtYXQ6ICdtaWxsZW5pdW0nLFxuICAgIHBvc3RncmVzRm9ybWF0OiAnbWlsbGVuaXVtJyxcbiAgICBzZWNvbmRzOiAxMDAgKiAzNjUuMjUgKiAyNCAqIDYwICogNjBcbiAgfSwge1xuICAgIGRlc2NyaXB0aW9uOiAnY2VudHVyeScsXG4gICAgbW9tZW50Rm9ybWF0OiAnY2VudHVyeScsXG4gICAgcG9zdGdyZXNGb3JtYXQ6ICdjZW50dXJ5JyxcbiAgICBzZWNvbmRzOiAxMDAgKiAzNjUuMjUgKiAyNCAqIDYwICogNjBcbiAgfSwge1xuICAgIGRlc2NyaXB0aW9uOiAnZGVjYWRlcycsXG4gICAgbW9tZW50Rm9ybWF0OiAnZGVjYWRlcycsXG4gICAgcG9zdGdyZXNGb3JtYXQ6ICdkZWNhZGUnLFxuICAgIHNlY29uZHM6IDEwICogMzY1LjI1ICogMjQgKiA2MCAqIDYwXG4gIH0sIHtcbiAgICBkZXNjcmlwdGlvbjogJ3llYXJzJyxcbiAgICBtb21lbnRGb3JtYXQ6ICd5ZWFycycsXG4gICAgcG9zdGdyZXNGb3JtYXQ6ICd5ZWFyJyxcbiAgICBzZWNvbmRzOiAzNjUuMjUgKiAyNCAqIDYwICogNjBcbiAgfSwge1xuICAgIGRlc2NyaXB0aW9uOiAncXVhcnRlcnMnLFxuICAgIG1vbWVudEZvcm1hdDogJycsXG4gICAgcG9zdGdyZXNGb3JtYXQ6ICdxdWFydGVyJyxcbiAgICBzZWNvbmRzOiAzNjUuMjUgKiA4ICogNjAgKiA2MFxuICB9LCB7XG4gICAgZGVzY3JpcHRpb246ICdtb250aHMnLFxuICAgIG1vbWVudEZvcm1hdDogJ21vbnRocycsXG4gICAgcG9zdGdyZXNGb3JtYXQ6ICdtb250aCcsXG4gICAgc2Vjb25kczogMzAgKiAyNCAqIDYwICogNjBcbiAgfSwge1xuICAgIGRlc2NyaXB0aW9uOiAnd2Vla3MnLFxuICAgIG1vbWVudEZvcm1hdDogJ3dlZWtzJyxcbiAgICBwb3N0Z3Jlc0Zvcm1hdDogJ3dlZWsnLFxuICAgIHNlY29uZHM6IDcgKiAyNCAqIDYwICogNjBcbiAgfSwge1xuICAgIGRlc2NyaXB0aW9uOiAnZGF5cycsXG4gICAgbW9tZW50Rm9ybWF0OiAnZGF5cycsXG4gICAgcG9zdGdyZXNGb3JtYXQ6ICdkYXknLFxuICAgIHNlY29uZHM6IDI0ICogNjAgKiA2MFxuICB9LCB7XG4gICAgZGVzY3JpcHRpb246ICdob3VycycsXG4gICAgbW9tZW50Rm9ybWF0OiAnaG91cnMnLFxuICAgIHBvc3RncmVzRm9ybWF0OiAnaG91cicsXG4gICAgc2Vjb25kczogNjAgKiA2MFxuICB9LCB7XG4gICAgZGVzY3JpcHRpb246ICdtaW51dGVzJyxcbiAgICBtb21lbnRGb3JtYXQ6ICdtaW51dGVzJyxcbiAgICBwb3N0Z3Jlc0Zvcm1hdDogJ21pbnV0ZScsXG4gICAgc2Vjb25kczogNjBcbiAgfSwge1xuICAgIGRlc2NyaXB0aW9uOiAnc2Vjb25kcycsXG4gICAgbW9tZW50Rm9ybWF0OiAnc2Vjb25kcycsXG4gICAgcG9zdGdyZXNGb3JtYXQ6ICdzZWNvbmQnLFxuICAgIHNlY29uZHM6IDFcbiAgfSwge1xuICAgIGRlc2NyaXB0aW9uOiAnbWlsbGlzZWNvbmRzJyxcbiAgICBtb21lbnRGb3JtYXQ6ICdtaWxsaXNlY29uZHMnLFxuICAgIHBvc3RncmVzRm9ybWF0OiAnbWlsbGlzZWNvbmRzJyxcbiAgICBzZWNvbmRzOiAwLjAwMVxuICB9LCB7XG4gICAgZGVzY3JpcHRpb246ICdtaWNyb3NlY29uZHMnLFxuICAgIG1vbWVudEZvcm1hdDogJ21pY3Jvc2Vjb25kcycsXG4gICAgcG9zdGdyZXNGb3JtYXQ6ICdtaWNyb3NlY29uZHMnLFxuICAgIHNlY29uZHM6IDAuMDAwMDAxXG4gIH1cbl0pO1xuXG52YXIgVGltZVpvbmUgPSBBbXBlcnNhbmRNb2RlbC5leHRlbmQoe1xuICBwcm9wczoge1xuICAgIC8qKlxuICAgICAqIFRoZSBkZXNjcmlwdGl2ZSBuYW1lIG9mIHRoZSB0aW1lIHpvbmVcbiAgICAgKiBAbWVtYmVyb2YhIFRpbWVab25lXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBkZXNjcmlwdGlvbjogWydzdHJpbmcnXSxcbiAgICAvKipcbiAgICAgKiBUaGUgdGltZSB6b25lIGZvcm1hdFxuICAgICAqIEBtZW1iZXJvZiEgVGltZVpvbmVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZvcm1hdDogWydzdHJpbmcnXVxuICB9XG59KTtcblxudmFyIFRpbWVab25lcyA9IEFtcGVyc2FuZENvbGxsZWN0aW9uLmV4dGVuZCh7XG4gIGluZGV4ZXM6IFsnZGVzY3JpcHRpb24nXSxcbiAgbW9kZWw6IFRpbWVab25lXG59KTtcblxudmFyIHRpbWVab25lcyA9IG5ldyBUaW1lWm9uZXMoKTtcbnRpbWVab25lcy5hZGQoe1xuICBkZXNjcmlwdGlvbjogJ0lTTzg2MDEnLFxuICBmb3JtYXQ6ICdJU084NjAxJ1xufSk7XG5cbm1vbWVudC50ei5uYW1lcygpLmZvckVhY2goZnVuY3Rpb24gKHR6KSB7XG4gIHRpbWVab25lcy5hZGQoe1xuICAgIGRlc2NyaXB0aW9uOiB0eixcbiAgICBmb3JtYXQ6IHR6XG4gIH0pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB0aW1lUGFydHM6IHRpbWVQYXJ0cyxcbiAgdGltZVpvbmVzOiB0aW1lWm9uZXMsXG4gIGR1cmF0aW9uVW5pdHM6IGR1cmF0aW9uVW5pdHMsXG4gIGdldERhdGV0aW1lUmVzb2x1dGlvbjogZ2V0RGF0ZXRpbWVSZXNvbHV0aW9uLFxuICBnZXREdXJhdGlvblJlc29sdXRpb246IGdldER1cmF0aW9uUmVzb2x1dGlvbixcbiAgZ2V0Rm9ybWF0OiBnZXRGb3JtYXRcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///d45b\n")},e59a:function(module,exports,__webpack_require__){eval("var Collection = __webpack_require__(/*! ampersand-collection */ \"7bd3\");\nvar Partition = __webpack_require__(/*! ../partition */ \"8191\");\n\nmodule.exports = Collection.extend({\n  model: Partition,\n  indexes: ['rank'],\n  comparator: 'rank',\n  initialize: function () {\n    this.on('add', function (newPartition) {\n      newPartition.reset();\n    });\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZTU5YS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvcGFydGl0aW9uL2NvbGxlY3Rpb24uanM/YzRiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ2FtcGVyc2FuZC1jb2xsZWN0aW9uJyk7XG52YXIgUGFydGl0aW9uID0gcmVxdWlyZSgnLi4vcGFydGl0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGlvbi5leHRlbmQoe1xuICBtb2RlbDogUGFydGl0aW9uLFxuICBpbmRleGVzOiBbJ3JhbmsnXSxcbiAgY29tcGFyYXRvcjogJ3JhbmsnLFxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5vbignYWRkJywgZnVuY3Rpb24gKG5ld1BhcnRpdGlvbikge1xuICAgICAgbmV3UGFydGl0aW9uLnJlc2V0KCk7XG4gICAgfSk7XG4gIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///e59a\n")},e810:function(module,exports,__webpack_require__){eval("/**\n * ContinuousTransfrom defines a transformation on continuous (nummerical) data.\n * Currently linear interpolation between a set of control points is implemented.\n *\n * @class ContinuousTransform\n */\nvar AmpersandModel = __webpack_require__(/*! ampersand-model */ \"3bfc\");\n\nmodule.exports = AmpersandModel.extend({\n  props: {\n    transformedType: {\n      type: 'string',\n      required: true,\n      default: 'text',\n      values: ['text']\n    },\n    transformedMin: {\n      type: 'number',\n      required: true,\n      default: 0\n    },\n    transformedMax: {\n      type: 'number',\n      required: true,\n      default: 100\n    }\n  },\n  reset: function () {\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZTgxMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmFjZXQvdGV4dC10cmFuc2Zvcm0uanM/MzQ1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbnRpbnVvdXNUcmFuc2Zyb20gZGVmaW5lcyBhIHRyYW5zZm9ybWF0aW9uIG9uIGNvbnRpbnVvdXMgKG51bW1lcmljYWwpIGRhdGEuXG4gKiBDdXJyZW50bHkgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiBhIHNldCBvZiBjb250cm9sIHBvaW50cyBpcyBpbXBsZW1lbnRlZC5cbiAqXG4gKiBAY2xhc3MgQ29udGludW91c1RyYW5zZm9ybVxuICovXG52YXIgQW1wZXJzYW5kTW9kZWwgPSByZXF1aXJlKCdhbXBlcnNhbmQtbW9kZWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbXBlcnNhbmRNb2RlbC5leHRlbmQoe1xuICBwcm9wczoge1xuICAgIHRyYW5zZm9ybWVkVHlwZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6ICd0ZXh0JyxcbiAgICAgIHZhbHVlczogWyd0ZXh0J11cbiAgICB9LFxuICAgIHRyYW5zZm9ybWVkTWluOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZGVmYXVsdDogMFxuICAgIH0sXG4gICAgdHJhbnNmb3JtZWRNYXg6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiAxMDBcbiAgICB9XG4gIH0sXG4gIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///e810\n")},ea82:function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/*global Blob,File*/\n\n/**\n * Module requirements\n */\n\nvar isArray = __webpack_require__(/*! isarray */ \"6176\");\nvar isBuf = __webpack_require__(/*! ./is-buffer */ \"419b\");\n\n/**\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n * Anything with blobs or files should be fed through removeBlobs before coming\n * here.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @api public\n */\n\nexports.deconstructPacket = function(packet){\n  var buffers = [];\n  var packetData = packet.data;\n\n  function _deconstructPacket(data) {\n    if (!data) return data;\n\n    if (isBuf(data)) {\n      var placeholder = { _placeholder: true, num: buffers.length };\n      buffers.push(data);\n      return placeholder;\n    } else if (isArray(data)) {\n      var newData = new Array(data.length);\n      for (var i = 0; i < data.length; i++) {\n        newData[i] = _deconstructPacket(data[i]);\n      }\n      return newData;\n    } else if ('object' == typeof data && !(data instanceof Date)) {\n      var newData = {};\n      for (var key in data) {\n        newData[key] = _deconstructPacket(data[key]);\n      }\n      return newData;\n    }\n    return data;\n  }\n\n  var pack = packet;\n  pack.data = _deconstructPacket(packetData);\n  pack.attachments = buffers.length; // number of binary 'attachments'\n  return {packet: pack, buffers: buffers};\n};\n\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @api public\n */\n\nexports.reconstructPacket = function(packet, buffers) {\n  var curPlaceHolder = 0;\n\n  function _reconstructPacket(data) {\n    if (data && data._placeholder) {\n      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)\n      return buf;\n    } else if (isArray(data)) {\n      for (var i = 0; i < data.length; i++) {\n        data[i] = _reconstructPacket(data[i]);\n      }\n      return data;\n    } else if (data && 'object' == typeof data) {\n      for (var key in data) {\n        data[key] = _reconstructPacket(data[key]);\n      }\n      return data;\n    }\n    return data;\n  }\n\n  packet.data = _reconstructPacket(packet.data);\n  packet.attachments = undefined; // no longer useful\n  return packet;\n};\n\n/**\n * Asynchronously removes Blobs or Files from data via\n * FileReader's readAsArrayBuffer method. Used before encoding\n * data as msgpack. Calls callback with the blobless data.\n *\n * @param {Object} data\n * @param {Function} callback\n * @api private\n */\n\nexports.removeBlobs = function(data, callback) {\n  function _removeBlobs(obj, curKey, containingObject) {\n    if (!obj) return obj;\n\n    // convert any blob\n    if ((global.Blob && obj instanceof Blob) ||\n        (global.File && obj instanceof File)) {\n      pendingBlobs++;\n\n      // async filereader\n      var fileReader = new FileReader();\n      fileReader.onload = function() { // this.result == arraybuffer\n        if (containingObject) {\n          containingObject[curKey] = this.result;\n        }\n        else {\n          bloblessData = this.result;\n        }\n\n        // if nothing pending its callback time\n        if(! --pendingBlobs) {\n          callback(bloblessData);\n        }\n      };\n\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n    } else if (isArray(obj)) { // handle array\n      for (var i = 0; i < obj.length; i++) {\n        _removeBlobs(obj[i], i, obj);\n      }\n    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object\n      for (var key in obj) {\n        _removeBlobs(obj[key], key, obj);\n      }\n    }\n  }\n\n  var pendingBlobs = 0;\n  var bloblessData = data;\n  _removeBlobs(bloblessData);\n  if (!pendingBlobs) {\n    callback(bloblessData);\n  }\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"698d\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWE4Mi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9iaW5hcnkuanM/ZGQwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmdsb2JhbCBCbG9iLEZpbGUqL1xuXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHNcbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG5cbi8qKlxuICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cbiAqIEFueXRoaW5nIHdpdGggYmxvYnMgb3IgZmlsZXMgc2hvdWxkIGJlIGZlZCB0aHJvdWdoIHJlbW92ZUJsb2JzIGJlZm9yZSBjb21pbmdcbiAqIGhlcmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICB2YXIgYnVmZmVycyA9IFtdO1xuICB2YXIgcGFja2V0RGF0YSA9IHBhY2tldC5kYXRhO1xuXG4gIGZ1bmN0aW9uIF9kZWNvbnN0cnVjdFBhY2tldChkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuICAgIGlmIChpc0J1ZihkYXRhKSkge1xuICAgICAgdmFyIHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcbiAgICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHZhciBuZXdEYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdEYXRhW2ldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PSB0eXBlb2YgZGF0YSAmJiAhKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgdmFyIG5ld0RhdGEgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgIG5ld0RhdGFba2V5XSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIHBhY2sgPSBwYWNrZXQ7XG4gIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhKTtcbiAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcbiAgcmV0dXJuIHtwYWNrZXQ6IHBhY2ssIGJ1ZmZlcnM6IGJ1ZmZlcnN9O1xufTtcblxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGJ1ZmZlcnMpIHtcbiAgdmFyIGN1clBsYWNlSG9sZGVyID0gMDtcblxuICBmdW5jdGlvbiBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YSkge1xuICAgIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG4gICAgICB2YXIgYnVmID0gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhW2ldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBlbHNlIGlmIChkYXRhICYmICdvYmplY3QnID09IHR5cGVvZiBkYXRhKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhKTtcbiAgcGFja2V0LmF0dGFjaG1lbnRzID0gdW5kZWZpbmVkOyAvLyBubyBsb25nZXIgdXNlZnVsXG4gIHJldHVybiBwYWNrZXQ7XG59O1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHJlbW92ZXMgQmxvYnMgb3IgRmlsZXMgZnJvbSBkYXRhIHZpYVxuICogRmlsZVJlYWRlcidzIHJlYWRBc0FycmF5QnVmZmVyIG1ldGhvZC4gVXNlZCBiZWZvcmUgZW5jb2RpbmdcbiAqIGRhdGEgYXMgbXNncGFjay4gQ2FsbHMgY2FsbGJhY2sgd2l0aCB0aGUgYmxvYmxlc3MgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucmVtb3ZlQmxvYnMgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBfcmVtb3ZlQmxvYnMob2JqLCBjdXJLZXksIGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcblxuICAgIC8vIGNvbnZlcnQgYW55IGJsb2JcbiAgICBpZiAoKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgcGVuZGluZ0Jsb2JzKys7XG5cbiAgICAgIC8vIGFzeW5jIGZpbGVyZWFkZXJcbiAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7IC8vIHRoaXMucmVzdWx0ID09IGFycmF5YnVmZmVyXG4gICAgICAgIGlmIChjb250YWluaW5nT2JqZWN0KSB7XG4gICAgICAgICAgY29udGFpbmluZ09iamVjdFtjdXJLZXldID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYmxvYmxlc3NEYXRhID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3RoaW5nIHBlbmRpbmcgaXRzIGNhbGxiYWNrIHRpbWVcbiAgICAgICAgaWYoISAtLXBlbmRpbmdCbG9icykge1xuICAgICAgICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIob2JqKTsgLy8gYmxvYiAtPiBhcnJheWJ1ZmZlclxuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmopKSB7IC8vIGhhbmRsZSBhcnJheVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqICYmICFpc0J1ZihvYmopKSB7IC8vIGFuZCBvYmplY3RcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHBlbmRpbmdCbG9icyA9IDA7XG4gIHZhciBibG9ibGVzc0RhdGEgPSBkYXRhO1xuICBfcmVtb3ZlQmxvYnMoYmxvYmxlc3NEYXRhKTtcbiAgaWYgKCFwZW5kaW5nQmxvYnMpIHtcbiAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICB9XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///ea82\n")},ef13:function(module,exports){eval("/**\n * An abstraction for slicing an arraybuffer even when\n * ArrayBuffer.prototype.slice is not supported\n *\n * @api public\n */\n\nmodule.exports = function(arraybuffer, start, end) {\n  var bytes = arraybuffer.byteLength;\n  start = start || 0;\n  end = end || bytes;\n\n  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }\n\n  if (start < 0) { start += bytes; }\n  if (end < 0) { end += bytes; }\n  if (end > bytes) { end = bytes; }\n\n  if (start >= bytes || start >= end || bytes === 0) {\n    return new ArrayBuffer(0);\n  }\n\n  var abv = new Uint8Array(arraybuffer);\n  var result = new Uint8Array(end - start);\n  for (var i = start, ii = 0; i < end; i++, ii++) {\n    result[ii] = abv[i];\n  }\n  return result.buffer;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWYxMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXIuc2xpY2UvaW5kZXguanM/NTM3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFuIGFic3RyYWN0aW9uIGZvciBzbGljaW5nIGFuIGFycmF5YnVmZmVyIGV2ZW4gd2hlblxuICogQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyYXlidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYXJyYXlidWZmZXIuYnl0ZUxlbmd0aDtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBlbmQgPSBlbmQgfHwgYnl0ZXM7XG5cbiAgaWYgKGFycmF5YnVmZmVyLnNsaWNlKSB7IHJldHVybiBhcnJheWJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTsgfVxuXG4gIGlmIChzdGFydCA8IDApIHsgc3RhcnQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA8IDApIHsgZW5kICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPiBieXRlcykgeyBlbmQgPSBieXRlczsgfVxuXG4gIGlmIChzdGFydCA+PSBieXRlcyB8fCBzdGFydCA+PSBlbmQgfHwgYnl0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuICB9XG5cbiAgdmFyIGFidiA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGVuZCAtIHN0YXJ0KTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0LCBpaSA9IDA7IGkgPCBlbmQ7IGkrKywgaWkrKykge1xuICAgIHJlc3VsdFtpaV0gPSBhYnZbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///ef13\n")},faaa:function(module,exports){eval("\n/**\n * Module exports.\n */\n\nmodule.exports = on;\n\n/**\n * Helper for subscriptions.\n *\n * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`\n * @param {String} event name\n * @param {Function} callback\n * @api public\n */\n\nfunction on (obj, ev, fn) {\n  obj.on(ev, fn);\n  return {\n    destroy: function () {\n      obj.removeListener(ev, fn);\n    }\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmFhYS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvb24uanM/MTBkYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBvbjtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIHN1YnNjcmlwdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8RXZlbnRFbWl0dGVyfSBvYmogd2l0aCBgRW1pdHRlcmAgbWl4aW4gb3IgYEV2ZW50RW1pdHRlcmBcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBvbiAob2JqLCBldiwgZm4pIHtcbiAgb2JqLm9uKGV2LCBmbik7XG4gIHJldHVybiB7XG4gICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLnJlbW92ZUxpc3RlbmVyKGV2LCBmbik7XG4gICAgfVxuICB9O1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///faaa\n")},fbef:function(module,exports,__webpack_require__){eval("var Collection = __webpack_require__(/*! ampersand-collection */ \"7bd3\");\nvar Aggregate = __webpack_require__(/*! ../aggregate */ \"9d63\");\n\nmodule.exports = Collection.extend({\n  model: Aggregate,\n  indexes: ['rank'],\n  comparator: 'rank'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmJlZi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvYWdncmVnYXRlL2NvbGxlY3Rpb24uanM/YmJhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ2FtcGVyc2FuZC1jb2xsZWN0aW9uJyk7XG52YXIgQWdncmVnYXRlID0gcmVxdWlyZSgnLi4vYWdncmVnYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGlvbi5leHRlbmQoe1xuICBtb2RlbDogQWdncmVnYXRlLFxuICBpbmRleGVzOiBbJ3JhbmsnXSxcbiAgY29tcGFyYXRvcjogJ3JhbmsnXG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///fbef\n")}}]);